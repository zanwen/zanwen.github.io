<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM核学习（一）工作模式及寄存器资源</title>
    <url>/2024/11/23/1780.html</url>
    <content><![CDATA[<h1 id="can-kao-zi-liao">参考资料</h1>
<p><a href="https://developer.arm.com/documentation/ddi0406/latest/">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p>
<h1 id="arm-he-ar-mv-7-a-r-gong-zuo-mo-shi">ARM核（ARMv7-A/R）工作模式</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123192806705.png" alt="Table B1-1 ARM processor modes  "></p>
<ul>
<li>
<p>从异常模式来看，只有 User 和 System 是非异常模式；</p>
</li>
<li>
<p>从特权级别来看，只有 User 是非特权级别；</p>
</li>
</ul>
<h2 id="privilege-level">Privilege Level</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123192948933.png" alt="Privilege Level"></p>
<h2 id="arm-processor-modes">ARM Processor Modes</h2>
<h3 id="user-mode">User mode</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123193912894.png" alt="image-20241123193912894"></p>
<ul>
<li>操作系统通过在用户模式下运行引用程序来限制其对系统资源的访问，例如文件、进程等。</li>
<li>用户模式下的任何应用程序不能切换模式，除非通过软中断或异常。</li>
</ul>
<h3 id="system-mode">System mode</h3>
<blockquote>
<p>Software executing in System mode executes at PL1. System mode has the same registers available</p>
<p>as User mode, and is not entered by any exception</p>
</blockquote>
<p>在系统模式下运行的软件拥有PL1的特权，能够访问一些受控资源。系统模式和用户模式共用同一套可用的寄存器，并且无法通过任何异常来进入该模式。</p>
<h3 id="supervisor-mode">Supervisor mode</h3>
<blockquote>
<p>Supervisor mode is the default mode to which a Supervisor Call exception is taken.<br>
Executing a SVC (Supervisor Call) instruction generates an Supervisor Call exception, that is taken<br>
to Supervisor mode.<br>
A processor enters Supervisor mode on Reset.</p>
</blockquote>
<p>管理模式是CPU上电后默认的模式，因此在该模式下主要用来做系统的初始化，软中断处理也在该模式下。</p>
<p>当用户模式下的用户程序请求使用硬件资源时，通过软件中断进入该模式。</p>
<h3 id="abort-mode">Abort mode</h3>
<blockquote>
<p>Abort mode is the default mode to which a Data Abort exception or Prefetch Abort exception is<br>
taken</p>
</blockquote>
<p>终止模式是数据终止异常或指令预取终止异常发生时默认进入的模式。</p>
<p>数据终止异常：当用户程序访问非法地址、没有权限读取的地址时会发生该异常。例如linux下编程时经常遇到的<code>segment fault</code>：</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4">以下是一些导致储存器段错误的一般编程错误</a>：</p>
<ul>
<li>引用空指针</li>
<li>引用未初始化的野指针</li>
<li>引用已经被调用free()函数释放了的悬空指针</li>
<li>缓冲区溢出</li>
<li>堆栈溢出</li>
<li>运行未正确编译的程序（尽管存在编译时错误，某些编译器依然会输出可执行文件）</li>
</ul>
</blockquote>
<p>预取指令异常：预取指令是指令流水线中的概念。该异常发生在预取指令时无法获取到正确的可执行指令，我们有时运行错误代码会出现程序跑飞了的情况就是因为预取不到正确的指令了，CPU无法继续正常执行。</p>
<h3 id="undefined-mode">Undefined mode</h3>
<blockquote>
<p>Undefined mode is the default mode to which an instruction-related exception, including any<br>
attempt to execute an UNDEFINED instruction, is taken</p>
</blockquote>
<p>当CPU遇到一个它无法识别的指令时发生该异常。例如在ARM架构的CPU上执行一条Intel指令。</p>
<h3 id="fiq-mode">FIQ mode</h3>
<blockquote>
<p>FIQ mode is the default mode to which an FIQ interrupt is taken.</p>
</blockquote>
<p>FIQ是Fast Interrupt reQuetst，快速中断模式。快速是相当于一般中断模式（IRQ）而言的，用来处理对时间要求比较紧急的中断，主要用于高速数据传输及通道处理中。</p>
<h3 id="irq-mode">IRQ mode</h3>
<p>一般中断模式，也称普通中断模式，用于处理一般的中断请求。通常在硬件中断发生后自动进入该模式，该模式为特权模式，能够自由访问系统硬件资源。</p>
<h1 id="arm-he-ji-cun-qi-zi-yuan">ARM核寄存器资源</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123201917744.png" alt="image-20241123201917744"></p>
<h2 id="gai-lan">概览</h2>
<h3 id="ji-cun-qi-gong-xiang">寄存器共享</h3>
<p>R0~R7这几个寄存器是所有模式共享的，这意味着在模式发生切换时，为了不影响先前模式的寄存器数据，当前模式需要在使用这些寄存器之前先将它们压栈（内存区域中的栈）保存，并在模式退出时出栈以将寄存器恢复成原样。</p>
<p>同样的R8~R12是除了FIQ的所有模式共享的。</p>
<h3 id="ji-cun-qi-du-you">寄存器独有</h3>
<p>对于R8~R12，FIQ由自己独有的寄存器，这是为了提高该模式的处理效率：在进入该模式后，访问这几个寄存器无需压栈保护和出栈复原。<mark>这也是FIQ比IRQ快的原因之一。</mark></p>
<h3 id="yi-chang-mo-shi-ji-cun-qi">异常模式寄存器</h3>
<p>可以发现，对于SP和LR寄存器，除了User和System两个非异常模式，其他模式都对应有自己独立的。它们与异常跳转有关。</p>
<h3 id="pc-ji-cun-qi">PC寄存器</h3>
<p>PC（Program Counter）程序计数器用来指向指令地址，在32位CPU顺序执行的过程中，每条指令相隔4个字节，地址相隔0x4，通过将PC的值依次递增0x4就能实现顺序执行的效果。</p>
<p>但是发生模式切换时，需要修改PC的值以告诉CPU从哪里开始接着执行程序指令。</p>
<h3 id="cpsr-spsr">CPSR/SPSR</h3>
<p>Current Program Status Register，当前程序状态寄存器，其中包含了当前程序执行过程中产生的一些状态位，例如</p>
<ul>
<li>N：negtive，负数标志，例如比较指令 <code>cmp</code> 就是将一个数减去另一个数，如果结果为负，则将N位置1，后续指令可以通过增加条件后缀 <code>lt</code>、<code>le</code>（less than、less than or equals to）结合N标志位来实现类似 <code>if</code>条件的效果</li>
<li>C：carry，进位标志</li>
</ul>
<p>可以理解这个寄存器保存了当前程序的上下文信息。</p>
<p>Saved Program Status Register，暂存的程序状态寄存器。当发生模式切换时，应通过SPSR保存CPSR（之前的程序运行状态），并在返回时将SPSR会写到CPSR。</p>
<h2 id="ji-cun-qi-yong-tu-fen-xi">寄存器用途分析</h2>
<h3 id="tong-yong-ji-cun-qi-r-0-10">通用寄存器R0~10</h3>
<p>用来存放用户的数据，例如函数入参、函数返回值等</p>
<h3 id="zhan-xiang-guan-ji-cun-qi">栈相关寄存器</h3>
<ul>
<li>
<p>R11（fp: frame pointer）：用来记录一个栈空间的开始地址</p>
</li>
<li>
<p>R12（ip：The Intra-Procedure-call scratch register）用来临时存储sp</p>
</li>
<li>
<p>R13（sp：stack pointer）：栈指针寄存器（指向栈顶），压栈时根据该寄存器中的地址存放数据并更新栈指针到下一个位置</p>
</li>
</ul>
<p><mark>栈空间的计算：sp - fp</mark></p>
<h3 id="tiao-zhuan-xiang-guan-branch-ji-cun-qi">跳转相关（branch）寄存器</h3>
<ul>
<li>R14（lr，link register）：在发生跳转（函数调用，中断处理）时，用来保存PC寄存器的值。后面通过将lr会写PC即可实现跳转后的返回。</li>
</ul>
<h3 id="pc-ji-cun-qi-1">PC寄存器</h3>
<p>program counter：用来存放CPU需要执行的指令地址。</p>
<p>之所以称之为counter计数器，是因为指令宽度是固定的（例如ARMv7中是32位字宽），通过在当前指令的地址上偏移固定的指令位宽（例如4个字节+0x4）就能取到顺序的下一条指令。</p>
<h2 id="cpsr-cheng-xu-zhuang-tai-ji-cun-qi">CPSR（程序状态寄存器）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124085427517.png" alt="image-20241124085427517"></p>
<h3 id="tiao-jian-biao-zhi-wei-ke-bei-xu-duo-zhi-ling-she-zhi">条件标志位（可被许多指令设置）</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123230843319.png" alt="image-20241123230843319"></p>
<h3 id="n-fu-hao-tiao-jian-biao-zhi-wei">N-负号条件标志位</h3>
<blockquote>
<p>Negative condition flag. Set to bit[31] of the result of the instruction. If the result is<br>
regarded as a two’s complement signed integer, then the processor sets N to 1 if the result<br>
is negative, and sets N to 0 if it is positive or zero.</p>
</blockquote>
<p>当指令的结果为有符号整数时，处理器会在该结果为负数时将N置1。例如我们有时需要根据条件来跳转：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
	<span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应指令伪代码如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov r0,a // 将a加载到r0寄存器
mov r1,b // 将b加载到r1寄存器
cmp r0,r1 // 通过r0-r1来比较两者的值，如果结果为负数则将N置1，否则置0
bgt foo // b：branch分支跳转 gt：greater than，如果N=0（a&gt;=b），则跳转到foo函数入口地址
ble fun // le：less than or equals to，如果N=1（a&lt;b），则跳转到fun函数入口地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="z-ling-tiao-jian-biao-zhi-wei">Z-零条件标志位</h3>
<blockquote>
<p>Zero condition flag. Set to 1 if the result of the instruction is zero, and to 0 otherwise. A<br>
result of zero often indicates an equal result from a comparison</p>
</blockquote>
<p>当指令结果为0时会将Z置1。Z位为1通常标示了一个结果为0的比较指令，例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对应指令 伪代码如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov r0,a
mov r1,b
cmp r0,r1 // 通过r0-r1来比较两者的值，如果结果为0则将Z置1（当然也会将N置0）
beq foo // b：branch分支跳转 eq：equals to，如果Z=1，则跳转foo函数入口地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="c-jin-wei-tiao-jian-biao-zhi-wei">C-进位条件标志位</h3>
<blockquote>
<p>Carry condition flag. Set to 1 if the instruction results in a carry condition, for example an<br>
unsigned overflow on an addition.</p>
</blockquote>
<p>如果指令的结果产生了进位，则C位会被置1。例如加法过程中的无符号溢出。以 <code>uint32_t</code>为例，最大为 <code>0xFFFFFFFF</code>，如果对其进行加法操作则会产生进位，例如</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> a <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">;</span>
<span class="token class-name">uint32_t</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 产生进位，C被置1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="v-yi-chu-tiao-jian-biao-zhi-wei">V-溢出条件标志位</h3>
<blockquote>
<p>Overflow condition flag. Set to 1 if the instruction results in an overflow condition, for<br>
example a signed overflow on an addition</p>
</blockquote>
<p>如果指令的结果产生了溢出（<mark>超过了数据类型的表示范围</mark>），例如加法中的有符号溢出，则会将该位置1。这里要和C位区分开来，C位是针对无符号的（运算不考虑符号位），V是针对有符号的。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">signed</span> <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
<span class="token keyword">signed</span> <span class="token keyword">char</span> tmp <span class="token operator">=</span> ch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 有符号char最大值为127，加1后为128超过了char的标示范围（-128~127）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="i-f-jin-yong-biao-zhi-wei">I/F-禁用标志位</h3>
<p>I位置1标示禁用IRQ异常，F位置1标示禁用FIQ异常</p>
<blockquote>
<p>In an implementation that does not include the Security Extensions, setting a mask bit masks the<br>
corresponding exception, meaning it cannot be taken</p>
</blockquote>
<h3 id="t-biao-zhi-wei">T标志位</h3>
<p>标示了处理器指令集的状态：</p>
<ul>
<li>ARM状态：32位指令</li>
<li>Thumb状态：16位指令（可以理解位ARM指令的压缩版）</li>
</ul>
<h3 id="m-biao-zhi-wei">M标志位</h3>
<p>标示处理器当前的工作模式，参见本文 <mark>ARM&nbsp;Processor&nbsp;Modes</mark>对应的章节。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM核学习（二）指令集</title>
    <url>/2024/11/24/18972.html</url>
    <content><![CDATA[<h1 id="can-kao-zi-liao">参考资料</h1>
<p><a href="https://developer.arm.com/documentation/ddi0406/cd/?lang=en">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p>
<h1 id="mdk-huan-jing-da-jian">MDK环境搭建</h1>
<h2 id="xia-zai-legacy-support-zhi-chi-bao">下载Legacy Support支持包</h2>
<p><a href="https://armkeil.blob.core.windows.net/legacy/MDK79525.EXE">https://armkeil.blob.core.windows.net/legacy/MDK79525.EXE</a></p>
<p>安装到MDK的安装目录下</p>
<h2 id="xia-zai-arm-gnu-gong-ju-lian">下载ARM GNU工具链</h2>
<p><a href="https://developer.arm.com/-/media/Files/downloads/gnu/13.3.rel1/binrel/arm-gnu-toolchain-13.3.rel1-mingw-w64-i686-arm-none-eabi.exe">https://developer.arm.com/-/media/Files/downloads/gnu/13.3.rel1/binrel/arm-gnu-toolchain-13.3.rel1-mingw-w64-i686-arm-none-eabi.exe</a></p>
<blockquote>
<p><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">下载页面</a></p>
</blockquote>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124092507291.png" alt="image-20241124092507291" style="zoom:50%;">
<h2 id="chuang-jian-xiang-mu">创建项目</h2>
<p>安装Legacy Support之后，可以在Device中对其进行选择</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124091834836.png" alt="image-20241124091834836"></p>
<p>然后选择ARM9E-S（Little Endian）进行仿真</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124092007126.png" alt="image-20241124092007126" style="zoom:50%;">
<p>键入如下代码：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1
	mov r1,#2
	mov r2,#3
	
stop:
	b stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124093601960.png" alt="image-20241124093601960" style="zoom:50%;">
<h2 id="pei-zhi-arm-gnu-gong-ju-lian">配置ARM GNU工具链</h2>
<p>配置交叉编译工具链，即此前下载的ARM GNU的安装路径</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124093644442.png" alt="image-20241124093644442" style="zoom: 50%;">
<h2 id="bian-yi-xiang-mu">编译项目</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124093742741.png" alt="image-20241124093742741" style="zoom:50%;">
<h2 id="fang-zhen-diao-shi-pei-zhi">仿真/调试配置</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124093931756.png" alt="image-20241124093931756" style="zoom: 50%;">
<p>配置代码段开始地址：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124094012862.png" alt="image-20241124094012862" style="zoom:50%;">
<p><mark>注意</mark>：每次修改了编译配置选项后，最好重新编译一下以使其生效：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124094203216.png" alt="image-20241124094203216"></p>
<h2 id="kai-shi-diao-shi">开始调试</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124094253900.png" alt="image-20241124094253900"></p>
<p>如果点击调试按钮后出现如上界面，则仿真环境配置成功了。左侧是ARM核的寄存器（可参考另一篇文章《ARM核（ARMv7-A/R）学习》），右上方是对应的汇编指令。</p>
<p>点击左上方的调试按钮，可以发现立即数1、2、3被依次加载到寄存器R0、R1、R2中了：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124094832406.png" alt="image-20241124094832406" style="zoom:50%;">
<h1 id="zhi-ling-ge-shi">指令格式</h1>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124101014161.png" alt="image-20241124101014161" style="zoom:50%;">
<h2 id="he-fa-li-ji-shu">合法立即数</h2>
<p>立即数使用 <code>#数字</code>来表示</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124102202527.png" alt="image-20241124102202527"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124102256351.png" alt="image-20241124102256351"></p>
<h2 id="ji-cun-qi-yi-wei">寄存器移位</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124102702102.png" alt="image-20241124102702102"></p>
<h1 id="chang-yong-arm-he-zhi-ling">常用ARM核指令</h1>
<p>参见手册中的 <mark>A8.8 Alphabetical list of instructions</mark>章节</p>
<h2 id="shu-ju-chuan-song-zhi-ling">数据传送指令</h2>
<h3 id="mov">MOV</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124103655266.png" alt="image-20241124103655266" style="zoom:50%;">
<h3 id="mvn">MVN</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124103924679.png" alt="image-20241124103924679" style="zoom:50%;">
<h3 id="ldr">LDR</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124104010947.png" alt="image-20241124104010947" style="zoom:50%;">
<p><mark>注意：数字常量前需要加上“=”，这是常量/字面量表示的语法规则</mark></p>
<p>当数据不是合法立即数时，作为MOV的替代指令。这是一条伪指令，底层是通过将数据（<code>=</code>号后面的数字）先存放到内存，再通过LDR(从内存加载到寄存器)指令来实现的。</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124104851454.png" alt="image-20241124104851454" style="zoom: 33%;">
<h2 id="shu-ju-ji-suan-zhi-ling">数据计算指令</h2>
<h3 id="add-jia-fa">ADD加法</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124105251693.png" alt="image-20241124105251693" style="zoom:50%;">
<h3 id="sub-jian-fa">SUB减法</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124105408936.png" alt="image-20241124105408936" style="zoom:50%;">
<p>默认情况下SUB是不会影响CPSR的N标志位的，如果需要则要加上S后缀：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124105935847.png" alt="image-20241124105935847" style="zoom: 33%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124110015698.png" alt="image-20241124110015698" style="zoom:33%;">
<h3 id="mul-cheng-fa">MUL乘法</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124110117129.png" alt="image-20241124110117129"></p>
<h3 id="lian-xi">练习</h3>
<blockquote>
<p>练习1：<br>
(2&lt;&lt;2)-5+0x12345678, 计算的结果存放在r0</p>
<p>练习2：<br>
25-3*5+6 最终的计算结果存放在r0中</p>
</blockquote>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#2
	mov r1,r0,lsl #2
	sub r1,r1,#5
	ldr r0,=0x12345678
	add r1,r1,r0
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#3
	mov r1,#5
	mul r2,r0,r1 @r0=3*5
	mov r1,#25
	sub r0,r1,r2 @r0=25-15
	add r0,r0,#6 @r0=10+6
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="wei-yun-suan-zhi-ling">位运算指令</h2>
<h3 id="and">AND</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124112800154.png" alt="image-20241124112800154" style="zoom:50%;">
<h3 id="orr-an-wei-huo">ORR-按位或</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124112835561.png" alt="image-20241124112835561" style="zoom:50%;">
<h3 id="eor-an-wei-yi-huo-exclusive-or">EOR-按位异或（Exclusive OR）</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124113112400.png" alt="image-20241124113112400" style="zoom:50%;">
<h3 id="bic-wei-qing-chu-zhi-ling">BIC-位清除指令</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124113149176.png" alt="image-20241124113149176" style="zoom:50%;">
<h3 id="lian-xi-1">练习</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124113304642.png" alt="image-20241124113304642" style="zoom:50%;">
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	ldr r0,=0x12345678
	ldr r1,=0xFFFF0000
	bic r1,r0,r1
	mov r0,r0,lsr #16
	add r0,r0,r1
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	ldr r0,=0xabcd
	
	mov r1,#0x7
	bic r0,r1,lsl #1
	
	mov r1,#0x5
	orr r0,r1,lsl #1
	
	mov r1,#0x1f
	bic r0,r1,lsl #7
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="bi-jiao-zhi-ling-cmp">比较指令CMP</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124114532330.png" alt="image-20241124114532330" style="zoom:50%;">
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#5
	mov r1,#6
	mov r2,#10
	
	cmp r0,r1
	addgt r1,r1,#1
	
	cmp r0,r2
	addle r2,r2,#1
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124114808027.png" alt="image-20241124114808027" style="zoom: 50%;">
<h2 id="tiao-zhuan-zhi-ling">跳转指令</h2>
<h3 id="b-bl">B/BL</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124125817106.png" alt="image-20241124125817106"></p>
<blockquote>
<p>Branch causes a branch to a target address.</p>
</blockquote>
<p>B指令用于跳转到一个目标地址（指令存放地址），该指令会修改PC的值，就像从处理器的顺序执行路径开了一个分岔一样，让处理器从既定的顺序指令序列跳到了另一个指令序列。常用于函数调用、中断处理。</p>
<p>BL指令在B指令的基础之上增加了一个操作：将跳转前PC的值保存到LR寄存器中。这样如果想从分岔回到原来的路径继续执行，只需将LR会写PC即可。</p>
<h4 id="si-xun-huan-de-shi-xian">死循环的实现</h4>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1
	mov r1,#2
	b _start
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="han-shu-diao-yong">函数调用</h4>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1
	mov r1,#2
	bl add
	
	mov r3,r2
	
stop:
	b _start
	
add:
	add r2,r0,r1
	mov pc,lr
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过单步调试观察PC的变化我们可以发现每条汇编指令的地址是按照编写顺序从上到下依次编址的，每条指令地址相隔4个字节，也即偏移量为0x4</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1 @instruction address =&gt; 0x00000000
	mov r1,#2 @instruction address =&gt; 0x00000004
	bl add	  @instruction address =&gt; 0x00000008
	
	mov r3,r2 @instruction address =&gt; 0x0000000C
	
stop:
	b _start  @instruction address =&gt; 0x00000010
	
add:
	add r2,r0,r1 @instruction address =&gt; 0x00000014
	mov pc,lr    @instruction address =&gt; 0x00000018<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="gei-pc-fu-zhi">给PC赋值</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124125452912.png" alt="image-20241124125452912"></p>
<p>B/BL指令有个限制：跳转的目标地址和当前PC中的指令地址之间的偏移量不能超过32M大小。如果超过了这个范围，我们可以直接赋值PC来实现跳转。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1 			
	mov r1,#2
	ldr pc,=add_label
back_label:
	mov r3,#10
	
stop:
	b stop

add_label:
	add r2,r0,r1
	ldr pc,=back_label
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中标签名字面量（<code>add_label</code>、<code>back_label</code>、<code>stop</code>）本质上就是给标签名冒号后的指令地址取了个别名，其值就是冒号后第一条指令的地址；且标签声明不属于指令，也就不占用内存空间，因此 <code>ldr pc,=add_label</code>等价于 <code>ldr pc,=0x00000014</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1 			@0x00000000
	mov r1,#2			@0x00000004
	ldr pc,=add_label	@0x00000008
back_label:
	mov r3,#10			@0x0000000C
	
stop:
	b stop				@0x00000010

add_label:
	add r2,r0,r1 		@0x00000014
	ldr pc,=back_label	@0x00000018
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="lian-xi-2">练习</h4>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124131659348.png" alt="image-20241124131659348" style="zoom:50%;">
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0		@sum=0
	mov r1,#1		@i=1
loop:
	cmp r1,#100
	bgt stop		@stop loop if r1 &gt; 100
	add r0,r0,r1	@sum+=i
	add r1,r1,#1	@i++
	b loop			@continue loop
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="dan-ge-shu-ju-fang-wen-yi-ci-xing-fang-wen-yi-ge-zi-kuan-shu-ju">单个数据访问（一次性访问一个字宽数据）</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124132933599.png" alt="image-20241124132933599" style="zoom:50%;">
<h3 id="ji-cun-qi-jian-jie-xun-zhi">寄存器间接寻址</h3>
<p><mark>LDR &lt;目标寄存器&gt; [源寄存器]</mark>：从源寄存器指定的地址中加载数据到目标寄存器</p>
<p><mark>LDR &lt;源寄存器&gt; [目标寄存器]</mark>：将源寄存器中的数据存储到目标寄存器指定的内存地址中</p>
<p>如下代码将数据 <code>0x12345678</code> 写（存储）到内存地址 <code>0x40000000</code>中，并从改地址读（加载）数据到R2寄存器中</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000
	ldr r1,=0x12345678
	
	str r1,[r0]		@write 0x12345678 to memory address 0x40000000 =&gt; *r0 = r1
	ldr r2,[r0]		@read 0x12345678 from memory address 0x40000000 =&gt; r2 = *r0
	
	b stop
	
stop:
	b stop

	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>点击调试后，需要映射一下当前程序可访问的内存空间：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124143904811.png" alt="image-20241124143904811" style="zoom: 50%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124143956075.png" alt="image-20241124143956075" style="zoom:50%;">
<blockquote>
<p>0x40000000,0x4000FFFF</p>
</blockquote>
<p>然后可以打开内存查看窗口：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124144137121.png" alt="image-20241124144137121" style="zoom: 50%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124144919193.png" alt="image-20241124144919193" style="zoom: 33%;">
<p>然后步进到 <code>str r1,[r0]</code>执行之后，会发现数据已被写入对应的内存。这里值得注意的是，存储方式是字节小端法。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124145026768.png" alt="image-20241124145026768"></p>
<p>再进一步，数据从内存加载到了R2寄存器中</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124145228766.png" alt="image-20241124145228766" style="zoom:50%;">
<h3 id="ji-di-zhi-bian-zhi-xun-zhi">基地址变址寻址</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124150404357.png" alt="参考手册 A8.5 Memory accesses"></p>
<h4 id="pian-yi-liang-xun-zhi">偏移量寻址</h4>
<blockquote>
<p>Offset addressing<br>
The offset value is applied to an address obtained from the base register. The result is used as the<br>
address for the memory access. The value of the base register is unchanged.<br>
The assembly language syntax for this mode is:<br>
<code>[&lt;Rn&gt;, &lt;offset&gt;]</code></p>
</blockquote>
<p><code>LDR/STR [&lt;Rn&gt;, &lt;offset&gt;]</code>：Rn为基地址，offset为偏移字节数</p>
<p>类比理解：C语言中通过指针加偏移量来访问内存（<code>num = *(p+1)</code>），该操作不会改变指针的值。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000
	ldr r1,=0x12345678
	
	str r1,[r0, #4]		@ *(r0+4)=r1
	ldr r2,[r0, #4]		@ r2=*(r0+4)
	
	b stop
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>注意：每次点击debug后做一下内存映射：</mark></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124150820281.png" alt="image-20241124150820281" style="zoom: 50%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124150924297.png" alt="image-20241124150924297" style="zoom:33%;">
<h4 id="qian-suo-yin-xun-zhi">前索引寻址</h4>
<blockquote>
<p>Pre-indexed addressing<br>
The offset value is applied to an address obtained from the base register. The result is used as the<br>
address for the memory access, and written back into the base register.<br>
The assembly language syntax for this mode is:<br>
<code>[&lt;Rn&gt;, &lt;offset&gt;]!</code></p>
</blockquote>
<p><code>LDR/STR [&lt;Rn&gt;, &lt;offset&gt;]!</code>：Rn为基地址，offset为偏移字节数。</p>
<p>该指令在偏移量寻址的基础上加了个 <mark>!</mark>，标示在内存访问之后将访问的地址回写基地址Rn。</p>
<p>类比理解：<code>num = *p++ =&gt; num = *p; p++;</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000
	ldr r1,=0x12345678
	
	str r1,[r0, #4]!		@ *(r0+4)=r1 r0+=4
	ldr r2,[r0]		@ r2=*r0
	
	b stop
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124152950125.png" alt="image-20241124152950125"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124153051739.png" alt="image-20241124153051739"></p>
<h4 id="hou-suo-yin-xun-zhi">后索引寻址</h4>
<blockquote>
<p>Post-indexed addressing<br>
The address obtained from the base register is used, unchanged, as the address for the memory<br>
access. The offset value is applied to the address, and written back into the base register<br>
The assembly language syntax for this mode is:<br>
<code>[&lt;Rn&gt;], &lt;offset&gt;</code></p>
</blockquote>
<p><code>LDR/STR [&lt;Rn&gt;], &lt;offset&gt;</code>：Rn为基地址，offset为偏移字节数。</p>
<p>该指令先从Rn访问内存，然后再将偏移量更新到Rn中。</p>
<p>类比理解：<code>num = *p; p += offset</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000
	ldr r1,=0x12345678
	
	str r1,[r0],#4	@ *(r0)=r1 r0+=4
	
	sub r0,r0,#4	@ r0-=4
	ldr r2,[r0]		@ r2=*r0
	
	b stop
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124153832192.png" alt="image-20241124153832192"></p>
<h4 id="zong-jie">🌟总结</h4>
<ul>
<li>偏移量寻址：就是在给定地址上加减一个偏移量来访问内存（relative）</li>
<li>前索引：先对给定地址增减偏移量进行更新，再访问更新后的地址</li>
<li>后索引：先访问给定地址，再对给定地址加减偏移量并更新</li>
</ul>
<h4 id="lian-xi-3">练习</h4>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124154157004.png" alt="image-20241124154157004"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1 				@i=1
	mov r1,#0x40000000 		@p
	
	bl write_data
	
	mov r0,#1				@i=1
	mov r1,#0x40000000 		@p=&gt;0x40000000
	ldr r2,=0x40000100		@q=&gt;0x40000100
	mov r3,#0				@num=0

	bl read_data
	
stop:
	b stop
	
write_data:
	str r0,[r1],#4 			@*p++=i
	add r0,r0,#1			@i++
	cmp r0,#10
	ble write_data 			@while(i&lt;=10)
	
	mov pc,lr				@return
	
read_data:
	ldr r3,[r1],#4			@num=*p++
	str r3,[r2],#4			@*q++=num
	add r0,r0,#1			@i++
	cmp r0,#10
	ble read_data			@while(i&lt;=10)
	
	mov pc,lr				@return
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124160123984.png" alt="image-20241124160123984"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124160205062.png" alt="image-20241124160205062"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	ldr r0,=0x1234
	ldr r1,=0x40000000 		@p=0x40000000
	str r0,[r1],#4			@*p++=0x1234
	
	ldr r0,=0xabcd
	str r0,[r1],#-4			@*p=0xabcd, p-=4
	
	ldr r2,[r1],#4			@num1=*p++
	ldr r3,[r1]				@num2=*p
	add r0,r2,r3			@sum=num1+num2
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="duo-ge-shu-ju-fang-wen">多个数据访问</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124162052165.png" alt="image-20241124162052165" style="zoom:50%;">
<h3 id="zhi-ling-mo-shi">指令模式</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124162139880.png" alt="image-20241124162139880" style="zoom:50%;">
<p>以STM（Store Multiple，写多个数据为例，LDM是类似的）：</p>
<ul>
<li>STMIA：Increase After，先向基地址写入数据，然后递增基地址</li>
<li>STMIB：Increase Before，先递增基地址，再向基地址写入数据</li>
<li>STMDA：Decrease After，先向基地址写入数据，然后递减基地址</li>
<li>STMDB：Decrease Before，先递减基地址，再向基地址写入数据</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000			@p=0x40000000
	mov r1,#0x11				@buf[3] = {0x11,0x22,0x33}
	mov r2,#0x22
	mov r3,#0x33
	
	stmia r0!,{r1-r3} 			@*p++=buf[i]
	
stop:
	b stop
	
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124163643693.png" alt="image-20241124163643693"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000			@p=0x40000000
	mov r1,#0x11				@buf[3] = {0x11,0x22,0x33}
	mov r2,#0x22
	mov r3,#0x33
	
	stmia r0!,{r1-r3} 			@*p++=buf[i++]
	
	ldmdb r0!,{r4-r6}			@buf2[i++]=*--p
	
stop:
	b stop
	
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124163945572.png" alt="image-20241124163945572"></p>
<h2 id="zhan-cao-zuo-zhi-ling">栈操作指令</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124164247925.png" alt="image-20241124164247925"></p>
<h3 id="zhan-zeng-chang-mo-shi">栈增长模式</h3>
<p><mark>自底向上：栈顶指针随着入栈而递增（地址）；自顶向下：栈顶指针随着入栈而递减</mark></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124164335289.png" alt="image-20241124164335289"></p>
<h3 id="kong-dui-zhan-he-man-dui-zhan">空堆栈和满堆栈</h3>
<p><mark>其实就是栈顶指针指向栈顶元素（满堆栈）还是指向下一个入栈元素要存放的位置（空堆栈）</mark></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124164412290.png" alt="image-20241124164412290"></p>
<h3 id="shi-li-ya-zhan-bao-cun-chu-zhan-hui-fu">示例：压栈保存，出栈恢复</h3>
<blockquote>
<p>在程序上下文发生切换时（例如函数调用、中断处理），我们通常需要先将先前程序执行状态相关的信息进行保存，然后在返回时进行恢复。</p>
</blockquote>
<p>如下程序以通用寄存器的暂存和恢复为例来模拟这一过程：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#0x11				
	mov r2,#0x22
	mov r3,#0x33
	
	@first: set stack pointer(start address of stack, from high address to low)
	ldr sp,=0x4000fff0		
	@push to save general purpose registers and decrease stack pointer
	stmfd sp!,{r1-r3}		
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124170153676.png" alt="image-20241124170153676"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#0x11				
	mov r2,#0x22
	mov r3,#0x33
	
	@first: set stack pointer(start address of stack, from high address to low)
	ldr sp,=0x4000fff0		
	@push to save general purpose registers and decrease stack pointer
	stmfd sp!,{r1-r3}		
	
	@do something with general purpose registers
	mov r1,#0x00				
	mov r2,#0x00
	mov r3,#0x00
	
	@pop stack to recover general purpose registers
	ldmfd sp!,{r1-r3}
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124170518808.png" alt="image-20241124170518808"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124170639885.png" alt="image-20241124170639885"></p>
<h2 id="cpsr-spsr-cao-zuo-zhi-ling">CPSR/SPSR操作指令</h2>
<h3 id="mrs-move-to-register-from-special-register">MRS（Move to Register from Special register）</h3>
<blockquote>
<p>Move to Register from Special register moves the value from the CPSR or SPSR of the current mode into an ARM<br>
core register.<br>
An MRS that accesses the SPSR is UNPREDICTABLE if executed in User or System mode.<br>
An MRS that is executed in User mode and accesses the CPSR returns an UNKNOWN value for the<br>
CPSR.{E, A, I, F, M} fields.</p>
</blockquote>
<p><code>MRS{&lt;c&gt;}{&lt;q&gt;} &lt;Rd&gt;, &lt;spec_reg&gt;  </code></p>
<h3 id="msr-move-register-immediate-to-special-register">MSR（Move register/immediate to Special Register）</h3>
<blockquote>
<p>Move to Special register from ARM core register moves the value of an ARM core register to the CPSR or the SPSR of the current mode.</p>
</blockquote>
<p><code>MSR&lt;c&gt; &lt;spec_reg&gt;, #&lt;const&gt;  </code></p>
<p><code>MSR{&lt;c&gt;}{&lt;q&gt;} &lt;spec_reg&gt;, &lt;Rn&gt;  </code></p>
<h3 id="zong-jie-1">🌟总结</h3>
<p><mark>MRS、MSR分辨</mark>：</p>
<ul>
<li>R在前面，则操作数1为通用寄存器（要将CPSR读到Rd）；</li>
<li>S在前面，操作数为特殊寄存器（要将通用寄存器写到CPSR）</li>
</ul>
<h3 id="lian-xi-4">练习</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124171837704.png" alt="image-20241124171837704"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mrs r0,cpsr 		@move to r0 from cpsr
	mov r1,#1
	bic r0,r1,lsl #7	@bit clear bit7 of cpsr
	msr cpsr,r0			@write back to cpsr
	
	b stop
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124172405608.png" alt="image-20241124172405608"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mrs r0,cpsr 		@move to r0 from cpsr
	mov r1,#1
	bic r0,r1,lsl #7	@bit clear bit7 of cpsr
	msr cpsr,r0			@write back to cpsr
	
	mrs r0,cpsr
	orr r0,r1, lsl #7	@set bit7 of cpsr
	msr cpsr,r0			@write back to cpsr
	
	b stop
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="the-end">The END</h1>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
        <tag>指令集</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM核学习（三）指令流水线分析及伪指令</title>
    <url>/2024/11/24/14899.html</url>
    <content><![CDATA[<h1 id="zhi-ling-liu-shui-xian-fen-xi">指令流水线分析</h1>
<h2 id="qian-yan">前言</h2>
<p>在ARM核中，为增加处理器指令流的速度，ARM7系列使用3级流水线。允许多个操作同时处理，而非顺<br>
序执行。<mark>不同的ARM核，流水线的级数是不一样的，ARM核版本越高，流水线级数越多。对于软件工</mark><br>
<mark>程师编程而言，统一按照三级流水线来分析就可以了。</mark></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124174742518.png" alt="image-20241124174742518" style="zoom: 33%;">
<blockquote>
<p>在MDK中断点调试时会发现PC指向的当前代码行，这是因为MDK调试屏蔽了底层流水线细节，以避免产生歧义。</p>
</blockquote>
<p>在ARM状态，指令位宽为32位4字节，因此当PC预取（例如）0x8地址的指令时，0x4地址的指令正在被解码、0x0地址的指令正在被执行。Thumb状态是压缩格式的指令集，指令位宽是16位2字节，因此偏差是2。</p>
<h2 id="zui-jia-liu-shui-xian-fen-xi-jin-cao-zuo-ji-cun-qi">最佳流水线分析（仅操作寄存器）</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124175951254.png" alt="image-20241124175951254" style="zoom:50%;">
<h2 id="nei-cun-fang-wen-zhi-ling-liu-shui-xian">内存访问指令流水线</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124180204732.png" alt="image-20241124180204732"></p>
<p>由于内存访问效率较低，因此在执行LDR指令时，无法在一个指令周期内完成（需要E、M、W三个周期）。这样，即使它前面的D跑得快，但解码的指令无法移交给E（它手上的活还没干完），只能干等，F也是一样。</p>
<h2 id="fen-zhi-tiao-zhuan-liu-shui-xian-ju-li">分支（跳转）流水线举例</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124181209542.png" alt="image-20241124181209542"></p>
<p>在E执行跳转指令时，跑在它前面的F、D不得不丢弃已完成的工（解码 <code>0x3004 SUB</code>，预取 <code>0x3008 AND</code>）作，转而从目标地址重新开始F、D、E流程。</p>
<p>图中E执行 <code>BL 0X8FEC</code>时，F正在预取 <code>0x3008</code>地址的指令，在该指令周期结束时，PC指向 <code>0x3008</code>，且由于是 <code>BL</code>跳转，因此该值会被保存到 <code>LR</code>寄存器中。</p>
<p>当执行 <code>L</code>指令时，会将<code>LR</code>回写到 <code>PC</code>中，但是由于此前对于 <code>0X3004</code>的解码工作被丢弃了，因此处理器会自动执行一个 <code>A</code>指令，将 <code>PC</code>调整到 <code>0x3004</code>的位置接着执行。</p>
<h2 id="zong-jie">总结</h2>
<ul>
<li>当只有寄存器操作（操作效率和CPU处于同一量级）时，指令流线效率是最高的：在每个指令周期，流水线上的三个工人F、D、E都在不停互相配合，高效完成指令执行所需的三个阶段的工作。</li>
<li>当访问内存（外设）时，由于物理特性，处理器的工作效率远高于外设，因此工人E只能放慢节奏和外设协同把活干了，这期间即使F、D完成了手头上的活，由于不能向D、E移交，因此也只能干等着。导致了级联停顿（stall）的效应。</li>
<li>当发生跳转时，工人F、D超前完成的工作只能被迫丢弃，转而从新的指令地址重新开始干活，且如果跳转回来，之前干完的活还得重新再干一次。</li>
</ul>
<h1 id="chang-yong-wei-zhi-ling-fen-xi">常用伪指令分析</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124183925641.png" alt="image-20241124183925641"></p>
<h2 id="ldr-r-0-0-x-12345678-fen-xi">LDR R0,=0x12345678 分析</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124184043373.png" alt="image-20241124184043373"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124184314696.png" alt="image-20241124184314696"></p>
<p>编译器会将常量 <code>0x12345678</code>预先放到某个内存中（通常是所有代码指令之后），并将LDR翻译成一条读内存的指令。</p>
<h2 id="ldr-r-0-label-fen-xi">LDR R0,=label 分析</h2>
<p>标签本质上是一个常量，它的值就是标签后第一条指令的地址，可以理解为给这个地址取了个别名。</p>
<h3 id="dai-ma-duan-qi-shi-di-zhi-wei-0-x-0">代码段起始地址为0x0</h3>
<p>对于给定的代码段起始地址和指令位宽，每条指令的存放地址在编译阶段都可以确定，如下将代码段的起始地址配置为 <code>0x0</code>：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124185737443.png" alt="image-20241124185737443" style="zoom:33%;">
<p>对于ARM状态下（指令位宽为4字节），如下代码的每条指令都可以顺序计算其存储地址</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#1			@0x00000000
	mov r2,#2			@0x00000004
	ldr r3,=addr		@0x00000008
	ldr r4,[r3]			@0x0000000C
	
stop:
	b stop				@0x00000010
	
addr:					@给0x00000014取了个别名叫addr
	.word 0x12345678	@0x00000014 在这个地址存放一个字的数据
		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是：标签的声明并不属于指令，因此不占用地址空间。其中 <code>ldr r3,=addr</code>等价于 <code>ldr r3,=0x00000014</code>。</p>
<p><code>ldr r3,=addr</code>（将addr表示的地址值加载到R3）分析如下：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124190511217.png" alt="image-20241124190511217"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124190550278.png" alt="image-20241124190550278"></p>
<p><code>ldr r4,[r3]</code>：从R3对应的地址读取数据（该数据 <code>0x12345678</code> 在编译阶段通过 <code>.word</code>伪指令预先存储在了内存空间中）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124190809542.png" alt="image-20241124190809542"></p>
<h3 id="dai-ma-duan-qi-shi-di-zhi-wei-0-x-2000">代码段起始地址为0x2000</h3>
<p>将代码段起始地址改为0x2000，计算规则是一样的，在编译阶段就能确定各个指令以及 <code>.word</code>数据存放的地址（注意修改后需要重新编译下）：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124200510540.png" alt="image-20241124200510540" style="zoom:33%;">
<p>调试前需要修改下内存映射，默认是从0x0开始执行的，我们需要让0x0到0x2000及其后的一段内存都可执行：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124200751229.png" alt="image-20241124200751229" style="zoom:50%;">
<p>然后在 <code>_start</code>的第一条指令打个断点，跳过从0x0到0x2000之间的无效指令：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124201005483.png" alt="image-20241124201005483" style="zoom: 33%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124200325028.png" alt="image-20241124200325028" style="zoom:33%;">
<h3 id="zong-jie-1">总结</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124195231017.png" alt="image-20241124195231017" style="zoom: 50%;">
<h2 id="ldr-r-0-label-fen-xi-1">LDR R0,label 分析</h2>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#1			
	mov r2,#2			
	ldr r3,addr			
	mov r4,r3			
stop:
	b stop				
addr:	
	.word 0x12345678	
		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ldr r3,=addr</code>可以理解为将标签 <code>addr</code>的值当做常量加载到R3中，而 <code>ldr r3,addr</code>则是从 <code>addr</code>对应的地址加载数据到R3中，相当于 <code>R3=p</code>和 <code>R3=*p</code>的关系</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124201244164.png" alt="image-20241124201244164" style="zoom: 33%;">
<h2 id="adr-r-0-label-dong-tai-huo-qu-biao-qian-di-zhi">ADR R0,label 动态获取标签地址</h2>
<blockquote>
<p>This instruction adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register.</p>
</blockquote>
<p>ADR 是 “Address” 的缩写，它是一条用于生成地址的伪指令。ADR 指令用于计算一个目标地址，并将其存储到指定的寄存器中。目标地址是基于当前 PC 加上一个偏移量计算得出的，因此它只能访问当前代码段附近的地址。</p>
<h3 id="strong-zhi-ling-ge-shi-strong"><strong>指令格式</strong></h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ADR &lt;Rd&gt;, &lt;label&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>&lt;Rd&gt;</code>：目标寄存器，用于存储计算出的地址。</li>
<li><code>&lt;label&gt;</code>：目标地址标签，必须位于当前指令前后一定范围内。</li>
</ul>
<h3 id="shi-li">示例</h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#1			
	mov r2,#2			
	adr r3,addr			
	ldr r4,[r3]		
stop:
	b stop				
addr:	
	.word 0x12345678	
		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124202620567.png" alt="image-20241124202620567"></p>
<h3 id="dui-bi-ldr-r-0-label">对比 LDR R0,=label</h3>
<p>如下图，<code>LDR R0,=label</code>编译时，编译器会根据代码段起始地址和指令位宽计算出label对应的地址值（<code>0x00000014</code>），并单独开辟一个内存（<code>0x00000018</code>）存放这个<mark>写死</mark>的数据，在运行时通过LDR读取这个内存中写死的label地址值到R3中。</p>
<p>如果起始地址为 <code>0x2000</code>，那么编译器就会在内存中存放一个写死的 <code>0x2014</code>，显然这是一种<mark>静态的做法</mark>（和编译时设置的代码段起始地址是<mark>强绑定的</mark>），如果程序换一个地址空间运行，这个写死的地址值就没有意义了。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124203311920.png" alt="image-20241124203311920"></p>
<p>而 <code>ADR R0,label</code>则是运行时动态获取标签对应的地址值，例如编译器知道执行当前指令时，通过在PC上偏移4个字节就能寻址到label对应的地址，那么通过 <code>ADD</code>指令就能在<mark>运行时动态获取</mark>该label对应的地址。这种做法是<mark>不依赖编译时设定的代码段起始地址的，无论使用什么起始地址，都能够得到一个正确的标签地址</mark>。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124204230866.png" alt="image-20241124204230866"></p>
<h2 id="ru-he-pan-bie-dai-ma-zai-shi-ji-nei-cun-zhong-yun-xing-de-di-zhi">🌟如何判别代码在实际内存中运行的地址？</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124204803253.png" alt="image-20241124204803253"></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
        <tag>指令流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM核学习（五）异常处理</title>
    <url>/2024/11/25/17360.html</url>
    <content><![CDATA[<h1 id="can-kao-zi-liao">参考资料</h1>
<p><a href="https://developer.arm.com/documentation/ddi0406/cd/?lang=en">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p>
<ul>
<li>B1.8 Exception handling</li>
</ul>
<p><a href="https://developer.arm.com/documentation/den0013/latest/">ARM® Cortex™-A Series Programmer’s Guide Version: 4.0</a></p>
<h1 id="yi-chang-jie-shao">异常介绍</h1>
<h2 id="shi-yao-shi-yi-chang">什么是异常</h2>
<p>异常是处理器核在执行程序指令的过程中突然遇到了异常的事情，这些事件包括<strong>硬件中断、指令执行错误、用户程序请求服务、内存访问异常、取指令异常</strong>等，几乎每种处理器都支持特定的异常处理，<mark>中断也是异常的一种</mark>。</p>
<h2 id="arm-de-yi-chang-yuan">ARM的异常源</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125214514494.png" alt="image-20241125214514494"></p>
<h2 id="fiq-jiao-irq-kuai-de-yuan-yin">FIQ较IRQ快的原因</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125214951043.png" alt="image-20241125214951043"></p>
<h1 id="arm-he-yi-chang-chu-li-guo-cheng">ARM核异常处理过程</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125215607973.png" alt="image-20241125215607973"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125214441652.png" alt="处理器工作模式切换"></p>
<h2 id="yi-chang-xiang-liang-biao">异常向量表</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125215846276.png" alt="image-20241125215846276"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125215810206.png" alt="image-20241125215810206"></p>
<blockquote>
<p>[!NOTE]</p>
<p>ARM核怎么知道异常向量表放在内存哪个地方呢？</p>
<ol>
<li>Cortex-A架构版本之前，是由协处理器（<a href="https://developer.arm.com/documentation/den0013/d/ARM-Processor-Modes-and-Registers/Registers/Coprocessor-15?lang=en">Coprocessor 15</a>） <code>CP15</code>的<code>C1</code>寄存器来决定的，且只能存放在 <code>0xFFFF0000</code>和<code>0x00000000</code>两者中的一个。</li>
<li>从Cortex-A架构版本开始，由协处理器 <code>CP15</code>的<code>c12</code>寄存器来决定，且不限制起始地址</li>
</ol>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125221405786.png" alt="Table B1-3 The vector tables"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125222433967.png" alt="image-20241125222433967"></p>
<blockquote>
<p><a href="https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities/Exception-mode-summary?lang=en">https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities/Exception-mode-summary?lang=en</a></p>
</blockquote>
<h2 id="cortex-a-chu-li-qi-yi-chang-xiang-liang-biao-ji-di-zhi-zhi-ding">Cortex-A处理器异常向量表基地址指定</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125223320833.png" alt="image-20241125223320833"></p>
<blockquote>
<p><a href="https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities?lang=en">https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities?lang=en</a></p>
</blockquote>
<blockquote>
<p>The first column in <a href="https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities?lang=en#CEGHDCAE">Table 11.1</a> gives the vector offset within the vector table associated with the particular type of exception. This is a table of instructions that the ARM core jumps to when an exception is raised. These instructions are located in a specific place in memory. The default vector base address is <code>0x00000000</code>, but most ARM cores permit the vector base address to be moved to <code>0xFFFF0000</code> (or <code>HIVECS</code>). <strong>All Cortex-A series processors permit this, and it is the default address selected by the Linux kernel. Cores that implement the Security Extensions can additionally set the vector base address, separately for Secure and Non-secure states, using the CP15 Vector Base Address registers.</strong></p>
<p><a href="https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities/The-Vector-table?lang=en">https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities/The-Vector-table?lang=en</a></p>
</blockquote>
<h3 id="cp-15-c-1">CP15 c1</h3>
<blockquote>
<p><a href="https://documentation-service.arm.com/static/602cf701083323480d479d18?token=">https://documentation-service.arm.com/static/602cf701083323480d479d18?token=</a></p>
</blockquote>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125225458216.png" alt="image-20241125225458216" style="zoom:50%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125225614769.png" alt="Table 4-52 SCTLR bit assignments (continued)  "></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125225701958.png" alt="image-20241125225701958"></p>
<h3 id="cp-15-c-12">CP15 c12</h3>
<blockquote>
<p><a href="https://developer.arm.com/documentation/ddi0406/cd/?lang=en">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125230347930.png" alt="image-20241125230347930"></p>
<blockquote>
<p>[!NOTE]</p>
<p>其中高位[31:5]是向量表的基地址，低位[4:0]是异常向量的偏移量（offset）</p>
</blockquote>
<h1 id="the-end">The End</h1>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
        <tag>异常</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM核学习（四）ATPS标准_汇编与C混合编程_volatile关键字</title>
    <url>/2024/11/24/59994.html</url>
    <content><![CDATA[<h1 id="can-kao-zi-liao">参考资料</h1>
<p><a href="https://developer.arm.com/documentation/dui0041/latest/Thumb-Procedure-Call-Standard/About-the-Thumb-Procedure-Call-Standard">The ARM-THUMB Procedure Call Standard</a></p>
<h1 id="atpcs-biao-zhun">ATPCS标准</h1>
<h2 id="atpcs-biao-zhun-jie-shao">ATPCS标准介绍</h2>
<p>ATPCS是<mark>ARM-Thumb Procedure Call Standard</mark>的缩写，也就是<mark>ARM-Thumb的程序调用标准</mark>。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124210132131.png" alt="image-20241124210132131"></p>
<h2 id="ji-cun-qi-jiao-se">寄存器角色</h2>
<blockquote>
<p>The first four registers r0-r3 are used to pass parameter values into a routine and result values out of a routine and to hold intermediate values within a routine (but, in general, only between subroutine calls). In ARM-state, register r12— also called IP— can also be used to hold intermediate values between subroutine calls.</p>
</blockquote>
<p><mark>r0-r3</mark>通常用来传递函数参数、返回函数结果和保存函数执行过程中产生的中间变量（例如 <code>sum=a+b</code>需要先将 <code>a+b</code>的计算结果存到寄存器中再写到 <code>sum</code>对应的内存）。</p>
<p>在ARM状态下，<mark>r12，也称为IP</mark>寄存器也可以用来保存临时变量，尤其是当其他通用寄存器（r0-r11）已被使用时。</p>
<blockquote>
<p><code>r12</code> (IP) is a <strong>general-purpose register</strong>, not reserved for any specific use in standard ARM programming.</p>
<p>The <strong>ARM Procedure Call Standard (AAPCS)</strong> defines it as a <strong>scratch register</strong>. This means:</p>
<ul>
<li>The <strong>caller</strong> can use it freely to store temporary values.</li>
<li>The <strong>callee</strong> (the function being called) does not preserve its value. If <code>r12</code> is used by the caller before calling another function, its value will be lost unless explicitly saved.</li>
</ul>
</blockquote>
<blockquote>
<p>Typically, the registers from r4 to r11 are used to hold the values of a routine’s local variables. They are also labeled v1-v8. Only v1-v4 can be used uniformly by the whole Thumb instruction set (shown emboldened).</p>
</blockquote>
<p>一般地，<mark>r4-r11</mark>用来保存函数的局部变量，他们被标记为v1-v8。Thumb指令集只能使用v1-v4。</p>
<blockquote>
<p>In all variants of the procedure call standard, registers r12-r15 have special roles. In these roles they are labeled IP, SP, LR and PC (or ip, sp, lr, and pc, but this standard uses the upper case name for the special role)</p>
</blockquote>
<p><mark>r12-r15</mark>有着特殊的角色，例如IP（临时保存SP），SP（指向栈顶），LR（跳转时用来保存PC）、PC，并且使用大写来标示他们的特殊角色。</p>
<blockquote>
<p>In some variants of the procedure call standard, r9 and r10 also have a special role. In these roles, r9 is labeled SB and r10 is labeled SL (or sb and sl).<br>
Only registers r0-r7, SP, LR and PC are ubiquitously available in Thumb state. Their synonyms and special names are shown emboldened. Few Thumb instructions can access the high registers, v5-v8, SB, SL and IP.<br>
In Thumb-state, r7 is often used as a work register and is also labeled WR</p>
</blockquote>
<h2 id="can-shu-chuan-di">参数传递</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124212508273.png" alt="image-20241124212508273"></p>
<p><mark>在定义函数时，参数数量尽量不要超过4个，这样效率较好</mark></p>
<h2 id="han-shu-fan-hui-zhi">函数返回值</h2>
<ul>
<li>返回值为一个32位的整数时，可以通过寄存器0返回</li>
<li>返回值为一个64位整数时，可以通过R0和R1返回，依此类推</li>
</ul>
<h2 id="zhan-zheng-fen-xi">栈帧分析</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124213834303.png" alt="image-20241124213834303" style="zoom:50%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124213931226.png" alt="image-20241124213931226"></p>
<h1 id="fan-hui-bian-fen-xi-atpcs-biao-zhun">反汇编分析ATPCS标准</h1>
<h2 id="zhun-bei-hui-bian-he-c-wen-jian">准备汇编和C文件</h2>
<p>准备一个汇编启动文件和一个C文件：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125151255393.png" alt="image-20241125151255393"></p>
<p>在 <code>asm.s</code>中，在调用 <code>main_label</code>函数之前，我们操作了下R0-R2，并设置了SP，模拟在调用函数前做了一些操作</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x11			
	mov r1,#0x22
    mov r2,#0x33
    mov sp,#0x00002000
	bl main_label	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main_label</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	b <span class="token operator">=</span> i<span class="token operator">++</span> <span class="token operator">+</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="jin-yong-bian-yi-you-hua">禁用编译优化</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125151330962.png" alt="image-20241125151330962" style="zoom: 50%;">
<h2 id="diao-shi-fen-xi-amp-nei-cun-ying-she">调试分析&amp;内存映射</h2>
<p>在点击debug后，步进之前，我们先添加一下内存映射 <code>0x00001000,0x00002000</code>，因为在 <code>asm.s</code>中我们有设置过SP <code>mov sp,#0x00002000</code>（<mark>注意每次点击debug后都需要手动映射下</mark>）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125102205035.png" alt="image-20241125102205035"></p>
<p>接着我们步进，在调用 <code>main_label</code>函数之前，对R0-R2，SP(R13)有所使用（模拟函数调用前操作过相关的寄存器）：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125104048265.png" alt="image-20241125104048265"></p>
<p>寄存器状态示例：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132148176.png" alt="image-20241125132148176" style="zoom:50%;">
<h2 id="han-shu-diao-yong-fen-xi">函数调用分析</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125115716832.png" alt="image-20241125115716832"></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124213834303.png" alt="image-20241124213834303" style="zoom:50%;">
<p>参照ATPCS标准，我们接着分析 <code>main_label</code>函数的执行。</p>
<h3 id="jiang-sp-zan-cun-dao-ip">将SP暂存到IP</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125104614719.png" alt="image-20241125104614719"></p>
<p>首先将<code>R13(SP)</code>送到了<code>R12(IP)</code>进行保存（这里可以看出<code>IP</code>的临时保存作用，将函数调用前的SP栈顶指针暂存起来以便后续恢复）：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132222836.png" alt="image-20241125132222836"></p>
<p>接着我们看下一条指令的执行：</p>
<p>压栈PC,LR,IP,FP</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125105604588.png" alt="image-20241125105604588"></p>
<p>将<code>R11(FP)、R12(IP)、R14(LR)、PC(R15)</code>通过 <code>STMDB</code>指令进行压栈（参考另一篇文章《ARM核学习（二）指令集》），值得注意的是：</p>
<ul>
<li>ATPCS标准规定使用<mark>满减栈模式</mark>（从高地址向低地址增长，栈顶指针SP指向最后一个入栈的数据地址）</li>
<li><code>STM</code>：多数据传输指令，同时将多个数据进行压栈</li>
<li><code>DB</code>： <mark>Decrease&nbsp;Before</mark>（先递减SP然后压栈数据），这里压栈4个寄存器（字宽4字节），所以SP会递减4*4=16</li>
<li>同时压栈多个寄存器时，序号（Rn中的n）大的寄存器对应栈的高地址，序号小的则对应低地址</li>
</ul>
<p>寄存器状态示意图：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132238290.png" alt="image-20241125132238290" style="zoom:50%;">
<h3 id="she-zhi-zhan-ji-zhi-fp-zhan-di-shu-ju-de-di-zhi">设置栈基址FP（栈底数据的地址）</h3>
<p>将R12(IP，之前保存了SP，即调用方caller的SP)，通过 <code>SUB</code>指令减4，赋值给R11（FP，栈基值，被调方callee即 <code>main_label</code>函数的栈的起始地址）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125115123312.png" alt="image-20241125115123312"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125120006973.png" alt="image-20241125120006973"></p>
<p>寄存器示意图:</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132458366.png" alt="image-20241125132458366"></p>
<blockquote>
<p>caller表示调用方，callee表示被调方</p>
</blockquote>
<h3 id="zeng-jia-sp-kuo-da-zhan-kong-jian">增加SP，扩大栈空间</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125121914111.png" alt="image-20241125121914111"></p>
<p>接着通过 <code>SUB</code>指令，将SP(R13)减去 <code>0x00000010</code>（即16字节，4个字），相当于将SP下移了四个存储单元</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132531947.png" alt="image-20241125132531947"></p>
<p>这样就相当于在栈中空出四个存储单元，为什么要这样做呢，我们接着往下看</p>
<h3 id="han-shu-ru-can-ya-zhan">函数入参压栈</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125131249986.png" alt="image-20241125131249986"></p>
<p>这里将R0写到R11（FP，栈基址）向下偏移 <code>0x0018</code>（即24字节，六个字）对应的存储单元中：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125133004294.png" alt="image-20241125133004294"></p>
<p>同样的，将R1写到FP向下偏移 <code>0x001C</code>（28个字节，7个字）的存储单元中：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125134213403.png" alt="image-20241125134213403"></p>
<p>根据ATPCS标准的规范，<code>r0</code>通常用来传递第一个参数<code>a1</code>，<code>r1</code>通常用来传递第二个参数<code>a2</code>，因此上述操作起始就是将函数的两个入参 <code>main_label(int argc, const char *argv[])</code> 压栈</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125131207660.png" alt="image-20241125131207660" style="zoom:33%;">
<h3 id="han-shu-ju-bu-bian-liang-ya-zhan">函数局部变量压栈</h3>
<p>对应 <code>int i = 0</code></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125133712296.png" alt="image-20241125133712296"></p>
<p>先将常量 <code>0</code>传输到寄存器R3中（这里R3作为通用寄存器存放临时的常量），再通过 <code>STR</code>指令压栈：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125134430454.png" alt="image-20241125134430454"></p>
<p>同样的，将局部变量 <code>b</code>压栈：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125134728492.png" alt="image-20241125134728492"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125134805022.png" alt="image-20241125134805022"></p>
<h3 id="ji-yu-zhan-he-ji-cun-qi-zuo-yun-suan">基于栈和寄存器做运算</h3>
<p>接着就到了 <code>b = i++ + ++i;</code>这一行代码的执行，它的过程是这样的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">++</span>i<span class="token punctuation">;</span>
b <span class="token operator">=</span> i <span class="token operator">+</span> i<span class="token punctuation">;</span>
i<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125135029185.png" alt="image-20241125135029185"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125135429854.png" alt="image-20241125135429854"></p>
<p>接着分析，我们会发现处理器的行为与我们在C语言的预期步骤是有出入的，这可能是因为指令重排序的原因，<mark>但无论怎样重排序，其结果与C语言的预期步骤得出的结果要保持一致。</mark></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125141616740.png" alt="image-20241125141616740"></p>
<h3 id="diao-yong-zi-han-shu-zi-guo-cheng-subroutine">调用子函数/子过程（subroutine）</h3>
<p>这与我们从汇编开始调用 <code>main_label</code>的分析思路是一样的，这里不在赘述。</p>
<h3 id="han-shu-fan-hui">函数返回</h3>
<p>接下来我们看一看 <code>main_label</code>函数的最后一行 <code>return 0;</code>都做了什么：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125144155014.png" alt="image-20241125144155014"></p>
<p>首先将常量 <code>0</code>（返回值）传输到R3进行临时保存；然后根据ATPCS标准，应该将返回值通过R0来传递，因此又将R3传输到了R0</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125144454192.png" alt="image-20241125144454192" style="zoom:33%;">
<p>接着通过 <code>SUB</code>，将R13(SP)指向R11(FP)向下偏移<code>0xC</code>的位置。如下图，SP指向这个位置后，相当于将函数参数和局部变量出栈释放了（对应图中灰色部分）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125144022274.png" alt="image-20241125144022274"></p>
<p>接着通过 <code>LDMIA</code>将还保存在栈中的调用方的<code>LR, SP, FP</code>恢复到<code>R14, R13, R11</code>中</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125145835783.png" alt="image-20241125145835783"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125145806719.png" alt="image-20241125145806719"></p>
<p>接着通过 <code>BX</code>指令根据LR(R14)跳转回调用方：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125150802906.png" alt="image-20241125150802906"></p>
<blockquote>
<p>为什么通过LR可以跳转回去呢？</p>
</blockquote>
<p>这是因为我们是通过 <code>bl main_label</code>跳转的，<code>l</code>后缀会将当前PC暂存到LR中，因此可以通过 <code>BX R14</code>跳转回去。</p>
<h1 id="hui-bian-yu-c-hun-he-bian-cheng">汇编与C混合编程</h1>
<h2 id="hui-bian-yu-yan-diao-yong-c-yu-yan">汇编语言调用C语言</h2>
<h3 id="zai-kan-c-yu-yan-cheng-xu-ru-kou">再看C语言程序入口</h3>
<blockquote>
<p>C语言程序的入口是main函数吗？</p>
</blockquote>
<p>经过上文的分析，我们知道C语言函数的执行过程是依赖栈的，在函数代码真正执行前需要将调用方程序状态相关的寄存器压栈保护（例如 <code>LR, SP, FP</code>）、函数参数压栈，如果有局部变量则也需要压栈，执行过程中的运算是基于栈和寄存器的配合来完成的。</p>
<p>因此每个函数的在执行前都需要设置栈的起始地址（SP），<code>main</code>当然也不例外，而这需要借助汇编来完成。</p>
<h3 id="mei-you-she-zhi-sp-han-shu-wu-fa-zheng-chang-zhi-xing">没有设置SP，函数无法正常执行</h3>
<p>让我们来看下如下程序：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125154604074.png" alt="image-20241125154604074"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x2			
	mov r1,#0x3
	bl add	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">int add(int a, int b) {
    return a + b;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>调试前需要先禁用编译器优化并重新编译：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125154632764.png" alt="image-20241125154632764" style="zoom:33%;">
<p>调试时会发现，函数执行前的压栈导致SP变成了<code>0xFFFFFFF0</code>，并且接着步进，程序无法按照预期结束。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125155225192.png" alt="image-20241125155225192"></p>
<p>这是因为调用函数时没有设置SP，SP默认为零值：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125155435833.png" alt="image-20241125155435833"></p>
<h3 id="han-shu-diao-yong-qian-xu-yao-zheng-que-she-zhi-sp">函数调用前需要正确设置SP</h3>
<p>于是我们在函数调用前，设置一下栈指针SP，并将相应的内存范围映射一下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x2			
	mov r1,#0x3
    ldr sp,=0x4000FFF0
	bl add	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>注意，这里要将SP设置为4的整数倍</mark></p>
<p><code>0x40000000,0x4000FFFF</code></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125160139087.png" alt="image-20241125160139087" style="zoom: 50%;">
<p>调整后发现可以正常执行到 <code>stop</code>，并且函数返回值 <code>2+3=5</code>也通过R0传递了过来</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125164223712.png" alt="image-20241125164223712"></p>
<p>我们还可以打开函数调用栈窗口来更直观地观察入参压栈的过程：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125164542704.png" alt="image-20241125164542704" style="zoom: 50%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125165001604.png" alt="image-20241125165001604"></p>
<h2 id="c-yu-yan-nei-qian-hui-bian">C语言内嵌汇编</h2>
<h3 id="ge-shi">格式</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125165243027.png" alt="image-20241125165243027" style="zoom: 50%;">
<h3 id="shi-li">示例</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125172126182.png" alt="image-20241125172126182"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x2			
	mov r1,#0x3
    ldr sp,=0x4000FFF0
	bl add	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>
    
    <span class="token keyword">asm</span><span class="token punctuation">(</span>
        <span class="token string">"add r0,%1,%2\n"</span>
        <span class="token string">"mov %0,r0\n"</span>
        <span class="token operator">:</span><span class="token string">"=r"</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        <span class="token operator">:</span><span class="token string">"r"</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
        <span class="token operator">:</span><span class="token string">"r0"</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意：可以通过%n引用输入列表、输出列表中的寄存器，从输出列表开始编号，输出列表的编号接着输入列表的最后一个</p>
</blockquote>
<ul>
<li>
<p>通过 <code>asm</code>关键字内嵌一段汇编代码</p>
</li>
<li>
<p><code>:"r"(a), "r"(b)</code>：<mark>输入列表</mark>，声明将C程序中哪些变量输入到内嵌汇编的通用寄存器中（具体哪个寄存器是无法预知的，可以通过 <code>%</code>进行引用）。<mark>如果没有输入，则留一个空的冒号即可，但不能去掉该行。</mark></p>
</li>
<li>
<p><code>"add r0,%1,%2\n"</code>：<mark>汇编指令</mark>，通过 <code>%1</code>、<code>%2</code>引用输入列表的中的变量 <code>a</code>、<code>b</code>对应的寄存器，并通过 <code>add</code>指令将这两个寄存器相加，结果存入 <code>r0</code>；<mark>注意，换行是不可省略的，标示这条指令结束</mark></p>
</li>
<li>
<p><code>:"=r"(c)</code>：<mark>输出列表</mark>，声明将C程序的哪些变量的值由内嵌汇编输出。<code>=</code>标示了该汇编结束时需要将寄存器写入变量中。</p>
</li>
<li>
<p><code>"mov %0,r0\n"</code>：<mark>汇编指令</mark>，将 <code>r0</code>中的值输入到 <code>%0</code>引用的寄存器中，由于引用编号是从输出列表开始的，因此引用的就是变量 <code>c</code>关联的寄存器</p>
</li>
</ul>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125165906124.png" alt="image-20241125165906124"></p>
<p>调试前别忘了映射下内存 <code>0x40000000,0x4000FFFF</code></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125174751017.png" alt="image-20241125174751017"></p>
<h1 id="volatile-guan-jian-zi">volatile关键字</h1>
<h2 id="gcc-bian-yi-you-hua">gcc编译优化</h2>
<h3 id="shi-li-cheng-xu">示例程序</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125181741845.png" alt="image-20241125181741845"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
    ldr sp,=0x4000FFF0
	bl add	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> global_a <span class="token operator">=</span> <span class="token number">0x3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> global_b <span class="token operator">=</span> <span class="token number">0x4</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> global_a <span class="token operator">+</span> global_b<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>global_a <span class="token operator">&gt;</span> global_b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="kai-qi-bian-yi-qi-you-hua">开启编译器优化</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125181830904.png" alt="image-20241125181830904" style="zoom: 50%;">
<h3 id="you-hua-hou-de-hui-bian-zhi-ling-fen-xi">优化后的汇编指令分析</h3>
<p>内存映射：<code>0x40000000,0x4000FFFF</code></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125181717824.png" alt="image-20241125181717824"></p>
<p>可以发现在执行 <code>int c = global_a + global_b;</code>时从内存读取 <code>global_a</code>和 <code>global_b</code>的值到<code>R2, R3</code>中；但是执行 <code>if(global_a &gt; global_b)</code>，并没重新从内存读取 <code>global_a</code>和 <code>global_b</code>的值，而是使用了此前<code>R2, R3</code>的快照。</p>
<h3 id="bian-yi-qi-you-hua-si-xiang-ji-bi-duan">编译器优化思想及弊端</h3>
<blockquote>
<p>[!NOTE]</p>
<p>根据另一篇文章《ARM核学习（三）指令流水线分析及伪指令》的分析，这是因为内存访问操作较低，无法发挥指令流水线的最佳性能，因此编译器优化会使用寄存器快照代替内存访问</p>
</blockquote>
<p>那么在<mark>并发场景</mark>下，如果在执行 <code>if(global_a &gt; global_b)</code>时发生了上下文切换，并且全局变量 <code>global_a</code>和 <code>global_b</code>的值被修改，那么 <code>R2, R3</code>中的值就不是最新的，因而会产生并发问题。</p>
<h2 id="volatile-guan-jian-zi-de-zuo-yong">volatile关键字的作用</h2>
<blockquote>
<p>[!TIP]</p>
<p><code>volatile</code>关键字的语意是易变的，被该关键字修饰的变量在读写时能够禁止编译器优化，从而使得每次读 <code>volatile</code>变量强制从内存读取最新值（在CPU Cache模型中每次写 <code>volatile</code>变量 也会立即将寄存器中的值刷新到内存）</p>
</blockquote>
<p>下面我们给 <code>global_a</code>和 <code>global_b</code>加上 <code>volatile</code>修饰后再来调试下：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125184042361.png" alt="image-20241125184042361"></p>
<p>可以发现 <code>if(global_a &gt; global_b)</code>时，通过 <code>LDR</code>指令，强制从内存读值了。</p>
<h1 id="the-end">The End</h1>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
        <tag>ATPS</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32系统时钟初始化源码解析（SPL库，STM32F103ZE）</title>
    <url>/2024/11/23/19447.html</url>
    <content><![CDATA[<h1 id="yi-bei-jing">一、背景</h1>
<h2 id="kai-fa-huan-jing">开发环境</h2>
<ul>
<li>STM32F103ZET6</li>
</ul>
<h2 id="yuan-li-tu">原理图</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123160212385.png" alt="image-20241123160212385"></p>
<h3 id="hse-gao-su-wai-bu-jing-zhen-high-speed-external-oscillator">HSE-高速外部晶振High Speed External oscillator</h3>
<p>通过23、24号引脚接入8M的高速外部晶振。</p>
<h3 id="hsi-di-su-wai-bu-jing-zhen-low-speed-external-oscillator">HSI-低速外部晶振Low Speed External oscillator</h3>
<p>通过GPIO引脚PC14和PC15的复用接入32.768kHz低速外部晶振。</p>
<h2 id="yi-cube-de-tu-xing-hua-pei-zhi-wei-li-shuo-ming">以Cube的图形化配置为例说明</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123160112667.png" alt="image-20241123160112667"></p>
<p>MCU内置了两个RC震荡电路：</p>
<ul>
<li>HSI RC，High Speed Internal RC，8M高速内部RC震荡电路</li>
<li>LSI RC，Low Speed Internal RC，40kHz低速内部RC震荡电路</li>
</ul>
<h3 id="wei-shi-yao-mcu-nei-zhi-liao-huan-xu-yao-wai-jie-jing-zhen">为什么MCU内置了，还需要外接晶振</h3>
<ul>
<li>
<p>RC震荡电路容易受到其他电路干扰，导致信号不稳定，且精度远比晶振低。</p>
</li>
<li>
<p>由于MCU的微小封装，无法内嵌较大的晶振</p>
</li>
<li>
<p>将晶振的灵活选择权交给开发者</p>
</li>
</ul>
<h3 id="cube-pei-zhi-jie-xi">Cube配置解析</h3>
<p>外接晶振通过引脚接入MCU，但由于MCU的主频较高，一般将HSE通过PLL（锁相环，用来倍频）提高频率再作为系统时钟SYSCLK的来源。</p>
<p>图中 <mark>Mux</mark>是多路选择器 <mark>Multiplex</mark>的缩写，可以看到我们的8M HSE经过了1分频（即不分频），连接到了PLL Source Mux，通过这个多路选择器，我们使用HSE而不是HSI作为PLL的时钟来源（HSE在精度和稳定性上要比HSI好很多）。</p>
<p>接着经过了PLLMul，即锁相环倍频（PLL Multiply），将HSE的频率放大了9倍得到PLLCLK（8M * 9 = 72M），并连接到了System Clock Mux（即系统时钟多路选择器），这里我们当然选择稳定、高精度、高频的PLLCLK作为系统时钟。</p>
<h1 id="er-shi-zhong-chu-shi-hua-guo-cheng-yuan-ma-fen-xi-spl-ku">二、时钟初始化过程源码分析（SPL库）</h1>
<h2 id="shang-dian-fu-wei-hou-hui-fa-sheng-shi-yao">上电/复位后会发生什么？</h2>
<p>MCU启动的汇编文件 <code>startup.s</code>会被执行：</p>
<p><code>startup_stm32f10x_hd.s</code></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">Reset_Handler   PROC
                EXPORT  Reset_Handler             [WEAK]
                IMPORT  __main
                IMPORT  SystemInit
                LDR     R0, =SystemInit
                BLX     R0               
                LDR     R0, =__main
                BX      R0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>执行SystemInit函数</mark></p>
<p>将 <code>SystemInit</code> 函数的入口地址加载到寄存器R0，通过 <code>BLX</code>跳转到其对应的代码段执行该函数，其中就包括了系统时钟的初始化过程。</p>
<p><mark>执行main函数</mark></p>
<p>将 <code>main</code> 函数的入口地址加载到寄存器R0，通过 <code>BX</code>跳转到其对应的代码段执行该函数，执行用户代码。</p>
<blockquote>
<p>该初始化顺序遵循ARM的CMSIS（Cortex Microcontroller Software Interface Standard）标准</p>
</blockquote>
<h2 id="system-init">SystemInit</h2>
<p><a href="https://www.st.com/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32F107参考手册</a></p>
<h3 id="qi-yong-hsi-xian-rang-mcu-you-xin-tiao">启用HSI，先让MCU有心跳</h3>
<p>在<code>system_stm32f10x.c</code>中找到 <code>SystemInit</code>函数，条件编译显示灰色的部分可以忽略</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Set HSION bit */</span>
RCC<span class="token operator">-&gt;</span>CR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0x00000001</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>先开启HSI高速内部时钟（时钟相当于MCU心跳，先让MCU有心跳能够工作，后面再将时钟源通过多路选择器切换为我们配置的HSE），将寄存器的第0位设置为1：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123165840693.png" alt="image-20241123165840693"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123165911410.png" alt="image-20241123165911410"></p>
<h3 id="fu-wei-shi-zhong-xiang-guan-ji-cun-qi-bi-te-wei">复位时钟相关寄存器比特位</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xF8FF0000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>该操作会将CFGR（时钟配置）寄存器如下比特位清零：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123170556835.png" alt="image-20241123170556835"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123170704055.png" alt="image-20241123170704055"></p>
<p>选择HSI（上一步已经开启了）作为系统时钟，其他的（HPRE, PPRE1, PPRE2, ADCPRE and MCO）分析过程类似。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Reset HSEON, CSSON and PLLON bits */</span>
RCC<span class="token operator">-&gt;</span>CR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFEF6FFFF</span><span class="token punctuation">;</span>

<span class="token comment">/* Reset HSEBYP bit */</span>
RCC<span class="token operator">-&gt;</span>CR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFFFBFFFF</span><span class="token punctuation">;</span>

<span class="token comment">/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFF80FFFF</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样的，也是将一些位清零，将系统时钟初始化为仅由HSI作为时钟源的初始状态</p>
<h3 id="set-sys-clock-she-zhi-xi-tong-shi-zhong">SetSysClock设置系统时钟</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Enable HSE */</span>    
RCC<span class="token operator">-&gt;</span>CR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CR_HSEON<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">/* Wait till HSE is ready and if Time out is reached exit */</span>
<span class="token keyword">do</span>
<span class="token punctuation">{</span>
  HSEStatus <span class="token operator">=</span> RCC<span class="token operator">-&gt;</span>CR <span class="token operator">&amp;</span> RCC_CR_HSERDY<span class="token punctuation">;</span>
  StartUpCounter<span class="token operator">++</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>HSEStatus <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>StartUpCounter <span class="token operator">!=</span> HSE_STARTUP_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里开启了HSE外部高速时钟，并等待HSE的状态转变为READY（由硬件置位）。</p>
<h3 id="xi-tong-shi-zhong-shu">系统时钟树</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* HCLK = SYSCLK */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_HPRE_DIV1<span class="token punctuation">;</span>
  
<span class="token comment">/* PCLK2 = HCLK */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_PPRE2_DIV1<span class="token punctuation">;</span>

<span class="token comment">/* PCLK1 = HCLK */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_PPRE1_DIV2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将系统时钟作为AHB和APB2的时钟源（对应HCLK和PCLK2），将系统时钟2分频，作为APB1的时钟源（对应PCLK2）。</p>
<blockquote>
<p>AHB挂载了Cortex核、DMA等主动单元</p>
<p>APB2挂载了GPIO、USRAT1、ADC等需要高速率时钟的单元</p>
<p>APB1则挂载了TIMER、I2C等不需要那么高频的单元</p>
</blockquote>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123172121666.png" alt="image-20241123172121666" style="zoom: 50%;">
<h3 id="pll-bei-pin">PLL倍频</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */</span>
    RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token operator">~</span><span class="token punctuation">(</span>RCC_CFGR_PLLSRC <span class="token operator">|</span> RCC_CFGR_PLLXTPRE <span class="token operator">|</span>
                                        RCC_CFGR_PLLMULL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>RCC_CFGR_PLLSRC_HSE <span class="token operator">|</span> RCC_CFGR_PLLMULL9<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>将PLL时钟来源RCC_CFGR_PLLSRC、HSE进入PLL后的分频RCC_CFGR_PLLXTPRE、PLL倍频系数RCC_CFGR_PLLMULL清零；</li>
<li>选择PLL时钟来源为HSE（RCC_CFGR_PLLSRC_HSE），倍频系数为9（RCC_CFGR_PLLMULL9）</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Enable PLL */</span>
    RCC<span class="token operator">-&gt;</span>CR <span class="token operator">|=</span> RCC_CR_PLLON<span class="token punctuation">;</span>

    <span class="token comment">/* Wait till PLL is ready */</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>RCC<span class="token operator">-&gt;</span>CR <span class="token operator">&amp;</span> RCC_CR_PLLRDY<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动PLL锁相环，并等待它稳定。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Select PLL as system clock source */</span>
   RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token operator">~</span><span class="token punctuation">(</span>RCC_CFGR_SW<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_SW_PLL<span class="token punctuation">;</span>    

   <span class="token comment">/* Wait till PLL is used as system clock source */</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_SWS<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0x08</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过系统时钟的多路选择器将PLL选择为系统时钟源，并等待此切换完成。</p>
]]></content>
      <categories>
        <category>STM32</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>SPL</tag>
        <tag>STM32F103ZE</tag>
        <tag>时钟</tag>
      </tags>
  </entry>
  <entry>
    <title>UART接收缓冲区溢出异常（HAL_UART_ERROR_ORE）问题记录</title>
    <url>/2024/11/12/13750.html</url>
    <content><![CDATA[<h1 id="wen-ti-bei-jing">问题背景</h1>
<h2 id="kai-fa-huan-jing">开发环境</h2>
<ul>
<li>硬件：GD32F407VET6开发版</li>
<li>IDE：STM32CubeMX + Clion + ARM GNU</li>
<li>烧录：OpenOCD</li>
</ul>
<h2 id="shi-yan-mu-biao">实验目标</h2>
<p>使用Cube配置串口USART1及其中断，引脚复用PA9/PA10，通过使能接收中断 <code>Receive_IT</code>，实现接收7字节时，在中断回调中处理该7个字节数据（简单回传，即echo），并再次开启接收中断，从而实现不断接收7字节、回传7字节的功能。</p>
<h2 id="yu-dao-wen-ti">遇到问题</h2>
<p>发送字节数为7时，能够正常echo；但是不为7时，本来期望是单次发送字节数：</p>
<ul>
<li>大于7字节时，应该也能每次触发中断，只是多余的字节数被丢弃了而已</li>
<li>少于7字节时（例如5），则通过再次发送也能触发中断</li>
</ul>
<p>但实验过程中发现这两种情况下，会发送echo了一两次之后，后面无论发送多少数据都无法再echo的情况</p>
<h1 id="qing-jing-zai-xian">情景再现</h1>
<h2 id="cube-pei-zhi">Cube配置</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212649840.png" alt="image-20241112212649840"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212742297.png" alt="image-20241112212742297"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212813159.png" alt="image-20241112212813159"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212840656.png" alt="image-20241112212840656"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212935188.png" alt="image-20241112212935188"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212959621.png" alt="image-20241112212959621"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213059038.png" alt="image-20241112213059038"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213254243.png" alt="image-20241112213254243"></p>
<h2 id="dao-ru-clion">导入Clion</h2>
<h3 id="bian-yi-pei-zhi-jiao-cha-bian-yi">编译配置-交叉编译</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213601046.png" alt="image-20241112213601046"></p>
<h3 id="cmake-pei-zhi">Cmake配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213656961.png" alt="image-20241112213656961"></p>
<h3 id="open-ocd-shao-lu-pei-zhi">OpenOCD烧录配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213740944.png" alt="image-20241112213740944"></p>
<p><code>daplink.cfg</code>：</p>
<pre class="line-numbers language-none"><code class="language-none"># choose st-link/j-link/dap-link etc.
adapter driver cmsis-dap
transport select swd

# 0x10000 = 64K Flash Size
# set FLASH_SIZE 0x20000

# 512KB Flash
set FLASH_SIZE 0x80000

source [find target/stm32f4x.cfg]

# download speed = 10MHz
# adapter speed 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="dai-ma-liu-cheng">代码流程</h2>
<ul>
<li>上电后启用接收中断</li>
<li>在接收完毕回调中echo，并再次启用接收中断</li>
</ul>
<p><code>main.c</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 0 */</span>
<span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 0 */</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">/* USER CODE BEGIN 1 */</span>
    <span class="token function">__HAL_RCC_HSI_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__HAL_RCC_SYSCLK_CONFIG</span><span class="token punctuation">(</span>RCC_SYSCLKSOURCE_HSI<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE END 1 */</span>

    <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

    <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* USER CODE BEGIN Init */</span>

    <span class="token comment">/* USER CODE END Init */</span>

    <span class="token comment">/* Configure the system clock */</span>
    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* USER CODE BEGIN SysInit */</span>

    <span class="token comment">/* USER CODE END SysInit */</span>

    <span class="token comment">/* Initialize all configured peripherals */</span>
    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE BEGIN 2 */</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE END 2 */</span>

    <span class="token comment">/* Infinite loop */</span>
    <span class="token comment">/* USER CODE BEGIN WHILE */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//        HAL_UART_Transmit_IT(&amp;huart1, (uint8_t *)"Hello, World!\r\n", 14);</span>
        <span class="token comment">//        HAL_Delay(1000);</span>
        <span class="token comment">/* USER CODE END WHILE */</span>

        <span class="token comment">/* USER CODE BEGIN 3 */</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="yuan-ma-fen-xi">源码分析</h1>
<h2 id="qi-yong-jie-shou-zhong-duan-hal-uart-receive-it">启用接收中断HAL_UART_Receive_IT</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>HAL_UART_Receive_IT -&gt; UART_Start_Receive_IT</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">huart<span class="token operator">-&gt;</span>pRxBuffPtr <span class="token operator">=</span> pData<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxXferSize <span class="token operator">=</span> Size<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxXferCount <span class="token operator">=</span> Size<span class="token punctuation">;</span>

huart<span class="token operator">-&gt;</span>ErrorCode <span class="token operator">=</span> HAL_UART_ERROR_NONE<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxState <span class="token operator">=</span> HAL_UART_STATE_BUSY_RX<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
<span class="token comment">/* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */</span>
<span class="token function">__HAL_UART_ENABLE_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">,</span> UART_IT_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* Enable the UART Data Register not empty Interrupt */</span>
<span class="token function">__HAL_UART_ENABLE_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">,</span> UART_IT_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>pRxBuffPtr</code> ：<strong>保存我们传入的buf指针</strong></li>
<li><code>RxXferSize</code> ：<strong>保存我们传入的buf大小</strong></li>
<li><code>RxXferCount</code>： <strong>初始化待接收数据数量</strong></li>
<li><code>ErrorCode</code>：初始化错误码为 no error</li>
<li><code>RxState</code>：<strong>标识UART处于接收状态（Data Reception process is ongoing）</strong></li>
<li>开启UART异常中断
<ul>
<li>帧异常（Frame error）</li>
<li>噪声异常（noise error）</li>
<li><em><strong>接收缓冲区溢出异常（overrun error）</strong></em></li>
</ul>
</li>
<li>开启接收寄存器非空中断（Enable the UART Data Register not empty Interrupt）</li>
</ul>
<h2 id="uart-zhong-duan-xiang-liang-biao">UART中断向量表</h2>
<p><em><strong>startup_stm32f407vetx.s</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>word     USART1_IRQHandler                 <span class="token comment">/* USART1                       */</span>       <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em><strong>stm32f4xx_it.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* USER CODE BEGIN USART1_IRQn 0 */</span>

  <span class="token comment">/* USER CODE END USART1_IRQn 0 */</span>
  <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN USART1_IRQn 1 */</span>

  <span class="token comment">/* USER CODE END USART1_IRQn 1 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="shu-ju-jie-shou-chu-li">数据接收处理</h2>
<p><em><strong>stm32f4xx_it.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* If no error occurs */</span>
    errorflags <span class="token operator">=</span> <span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>USART_SR_PE <span class="token operator">|</span> USART_SR_FE <span class="token operator">|</span> USART_SR_ORE <span class="token operator">|</span> USART_SR_NE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorflags <span class="token operator">==</span> RESET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* UART in mode Receiver -------------------------------------------------*/</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cr1its <span class="token operator">&amp;</span> USART_CR1_RXNEIE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">UART_Receive_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行接收数据逻辑（UART_Receive_IT）的前置条件：</p>
<ul>
<li>没有UART相关的异常（errorflags）</li>
<li>接收寄存器非空（USART_SR_RXNE）</li>
<li>接收寄存器非空中断使能是开启的（USART_CR1_RXNEIE）</li>
</ul>
<h2 id="zhu-zi-jie-shou-shu-ju-data-register">逐字接收数据（Data Register）</h2>
<p><em><strong>stm32f4xx_hal_uart.c/UART_Receive_IT</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Check that a Rx process is ongoing */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>RxState <span class="token operator">==</span> HAL_UART_STATE_BUSY_RX<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>pdata8bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>Instance<span class="token operator">-&gt;</span>DR <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span> <span class="token number">0x00FF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	huart<span class="token operator">-&gt;</span>pRxBuffPtr <span class="token operator">+=</span> <span class="token number">1U</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>huart<span class="token operator">-&gt;</span>RxXferCount <span class="token operator">==</span> <span class="token number">0U</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*Call legacy weak Rx complete callback*/</span>
		<span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>判断UART是不是处于接收进程中
<ul>
<li>我们之前调用过 <code>HAL_UART_Receive_IT</code>，里面会置位这个状态 <code>huart-&gt;RxState = HAL_UART_STATE_BUSY_RX</code></li>
</ul>
</li>
<li>从DR（UART数据寄存器）中读取一个字节到用户自定义缓冲区中（我们调用 <code>HAL_UART_Receive_IT</code> 时传入过一个7字节的<code>buf</code>）</li>
<li>递减剩余待接收数据数量 <code>huart-&gt;RxXferCount</code>（之前被初始化为7）
<ul>
<li>如果递减为0，则说明接收的字节数填满了用户指定缓冲区大小</li>
<li>然后调用 <code>HAL_UART_RxCpltCallback</code>，这是一个 <code>weak</code>函数（默认是一个空实现），用户可以声明一个对应的非 <code>weak</code>版以实现回调处理。这个理念是经典的<strong>hook钩子函数</strong>。</li>
</ul>
</li>
</ul>
<h2 id="zhong-xie-huan-chong-qu-jie-shou-wan-bi-hui-diao">重写缓冲区接收完毕回调</h2>
<p>原型：</p>
<p><em><strong>stm32f4xx_hal_uart.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__weak <span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Prevent unused argument(s) compilation warning */</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* NOTE: This function should not be modified, when the callback is needed,
             the HAL_UART_RxCpltCallback could be implemented in the user file
     */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重写：</p>
<p><em><strong>main.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 0 */</span>
<span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 0 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>将缓冲区7字节数据通过UART TX发送，采用轮询方式（每发一个字节轮询发送状态），超时时间100ms</li>
<li>重新开启接收中断，以实现下一次的echo</li>
</ul>
<h2 id="ding-chang-7-zi-jie-echo-ce-shi">定长7字节echo测试</h2>
<p>至此，定长7字节数据echo功能就实现了</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241113084959956.png" alt="image-20241113084959956"></p>
<h2 id="chao-7-zi-jie-echo-ce-shi">超7字节echo测试</h2>
<p><img src="C:/Users/86157/AppData/Roaming/Typora/typora-user-images/image-20241113085040298.png" alt="image-20241113085040298"></p>
<p>为什么超过我们指定的缓冲区大小（<code>HAL_UART_Transmit</code>的入参 <code>Size</code>）后，功能就不整行了呢？</p>
<h2 id="uart-zhong-duan-isr-yi-chang-liu-cheng">UART中断ISR-异常流程</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* If no error occurs */</span>
    errorflags <span class="token operator">=</span> <span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>USART_SR_PE <span class="token operator">|</span> USART_SR_FE <span class="token operator">|</span> USART_SR_ORE <span class="token operator">|</span> USART_SR_NE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorflags <span class="token operator">==</span> RESET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">UART_Receive_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
     
     <span class="token comment">/* If some errors occur */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>errorflags <span class="token operator">!=</span> RESET<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cr3its <span class="token operator">&amp;</span> USART_CR3_EIE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>
                                  <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cr1its <span class="token operator">&amp;</span> <span class="token punctuation">(</span>USART_CR1_RXNEIE <span class="token operator">|</span> USART_CR1_PEIE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* UART Over-Run interrupt occurred
         huart-&gt;ErrorCode |= HAL_UART_ERROR_ORE;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>没有异常时，会执行 <code>UART_Receive_IT</code>逐字接收数据并在填满缓冲区后触发接收完毕回调 <code>HAL_UART_RxCpltCallback</code></li>
<li>但是当我们发送8字节时，会触发UART的接收溢出错误，继而转向异常处理流程</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token comment">/* Call UART Error Call back function if need be --------------------------*/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>ErrorCode <span class="token operator">!=</span> HAL_UART_ERROR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">/*Call legacy weak error callback*/</span>
    <span class="token function">HAL_UART_ErrorCallback</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为异常处理流程不会执行我们自定义的 <code>HAL_UART_RxCpltCallback</code>，也就没有重新开启接收中断 <code>HAL_UART_RxCpltCallback</code>，所以就出现了发送8字节时，后续没有回传的现象：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241113085040298.png" alt="image-20241113085040298"></p>
<h1 id="si-kao-yi-liu-wen-ti">思考/遗留问题</h1>
<h2 id="usart-sr-ore-shi-ru-he-bei-she-zhi-de">USART_SR_ORE是如何被设置的</h2>
<p>为什么发送8字节时会触发USART_SR_ORE错误？</p>
]]></content>
      <categories>
        <category>STM32</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>Clion</tag>
        <tag>GD32</tag>
        <tag>HAL</tag>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解I2C时序（以I2C实时时钟PCF8563为案例）</title>
    <url>/2024/11/16/31289.html</url>
    <content><![CDATA[<h1 id="yi-qian-yan">一、前言</h1>
<h2 id="ying-jian-bei-jing">硬件背景</h2>
<ul>
<li>GD32F407VET6</li>
<li>I2C实时时钟PCF8563</li>
</ul>
<h2 id="yuan-li-tu">原理图</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116194724707.png" alt="image-20241116194724707" style="zoom: 33%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116194750339.png" alt="image-20241116194750339" style="zoom:33%;">
<h2 id="wen-dang-zi-liao">文档资料</h2>
<ul>
<li><a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a></li>
<li><a href="https://atta.szlcsc.com/upload/public/pdf/source/20230921/9DB04F89E1E4336DD7CCB7C268B77442.pdf">I 2 C 实时时钟/日历芯片 PCF8563</a></li>
</ul>
<h1 id="er-en-zhi-pu-nxp-i-2-c-zong-xian-xie-yi-shi-xu-jie-xi">二、恩智浦（NXP）I2C总线协议时序解析</h1>
<blockquote>
<p>参见<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的</p>
<p>**6 Electrical specifications and timing for I/O stages and bus lines  **</p>
<p>**Table 11. Characteristics of the SDA and SCL bus lines for Standard, Fast, and Fast-mode Plus I2C-bus devices **</p>
</blockquote>
<h2 id="overview">Overview</h2>
<h3 id="sda-scl-zong-xian-te-xing">SDA/SCL总线特性</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116195121046.png" alt="image-20241116195121046"></p>
<h3 id="shi-xu-ding-yi">时序定义</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202433638.png" alt="image-20241116202433638"></p>
<h2 id="i-2-c-chuan-shu-kong-zhi">I2C传输控制</h2>
<p>I2C规定单次通信需要遵循如下两个控制</p>
<h3 id="shu-ju-chuan-shu-kong-zhi">数据传输控制</h3>
<p><mark>在SCL为低时可以修改SDA；SCL为高时，SDA应该保持不变。</mark></p>
<p>在SCL为低电平时，准备SDA（发送方）；在SCL为高时，保持SDA（在此期间接送方会读取SDA）。</p>
<p>这一点在<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的 <strong>3.1.3 Data validity</strong>说明如下：</p>
<blockquote>
<p>The data on the SDA line must be stable during the HIGH period of the clock. The HIGH or LOW state of the data line can only change when the clock signal on the SCL line is LOW (see Figure 4). One clock pulse is generated for each data bit transferred.</p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214251742.png" alt="image-20241116214251742"></p>
<h2 id="qi-shi-zhong-zhi-kong-zhi">起始/终止控制</h2>
<p>在SCL为高时，拉低SDA（需要提前准备好SDA为高）；在SCL为低时，拉高SDA（需要提前准备好SDA为低）。</p>
<p><mark>可以发现为了区分数据传输控制，特意在SCL为高时操作SDA。</mark></p>
<p>这一点在<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的 <strong>3.1.4 START and STOP conditions</strong> 说明如下：</p>
<blockquote>
<p>All transactions begin with a START (S) and are terminated by a STOP (P) (see Figure 5). A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition. A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition.</p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214423843.png" alt="image-20241116214423843"></p>
<h2 id="f-sub-scl-sub-shi-zhong-xian-pin-lu-frequency-for-scl">f<sub>SCL</sub>时钟线频率（frequency for SCL）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116201656138.png" alt="image-20241116201656138"></p>
<p>该参数规定了I2C的SCL时钟线的频率，以Fast-mode为例，最大为400kHz。这意味着我们在操作SCL时，将SCL置0的时间+随后将SCL置1的时间之和不能小于 1/400kHz = 2.5us：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116201725124.png" alt="image-20241116201725124"></p>
<h2 id="t-sub-hd-sta-sub-qi-shi-xin-hao-bao-chi-shi-jian-hol-d-time-for-start-condition">t<sub>HD;STA</sub>起始信号保持时间（HolD time for START condition）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202607065.png" alt="image-20241116202607065"></p>
<p>该参数规定了起始信号（START condition）需要保持的时间（在SCL为高电平时，将SDA由高拉低后需要保持的时间）</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202932000.png" alt="image-20241116202932000" style="zoom: 50%;">
<p>这里有两个细节需要注意一下：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204002371.png" alt="image-20241116204002371"></p>
<ol>
<li>hold time (<mark>repeated</mark>) START condition：<mark>repeated</mark>表明第一个起始信号后的重复起始信号都需要遵循这个规则，例如在<a href="https://atta.szlcsc.com/upload/public/pdf/source/20230921/9DB04F89E1E4336DD7CCB7C268B77442.pdf">PCF8563</a>中提到的 <mark>写地址，读数据</mark>模式中，在第一个S（起始信号）之后有一个 <mark>dummy&nbsp;write</mark>（指定后面连续读的起始寄存器地址），然后又有一个S，紧接着才是真正的连续读数据。这里第二个S就属于 <mark>repeated&nbsp;START&nbsp;condition</mark>。</li>
</ol>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116203555124.png" alt="image-20241116203555124" style="zoom: 33%;">
<ol start="2">
<li>
<p><mark>After this period, the first clock pulse is generated</mark>：暗示我们在这个t<sub>HD;STA</sub>周期（相当于I2C通信的准备阶段）过后，主设备应该生成第一个时钟脉冲开始传输数据。因此时序定义里也给出了如下示意图，<strong>暗示我们在延时t<sub>HD;STA</sub>之后，应该将SCL拉低</strong>（图中 <mark>1<sup>st</sup>&nbsp;clock&nbsp;cycle</mark>也进一步印证了这一点）。</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204645958.png" alt="image-20241116204645958" style="zoom:50%;">
</li>
</ol>
<h2 id="t-sub-low-sub-t-sub-high-sub-shi-zhong-xian-gao-di-dian-ping-zhou-qi-kong-zhi-scl-low-high-period">t<sub>LOW</sub>/t<sub>HIGH</sub>时钟线高低电平周期控制（SCL low/high period）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204955105.png" alt="image-20241116204955105"></p>
<p>该参数规定了我们传输数据拉高拉低SCL时，其高低电平应该持续的时间，以Fast-mode为例，SCL低电平最低持续1.3us，高电平则最低0.6us</p>
<h2 id="t-sub-su-sta-sub-qi-shi-xin-hao-jian-li-zhun-bei-shi-jian-set-up-time-for-start">t<sub>SU;STA</sub> 起始信号建立（准备）时间（SetUp time for START）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116205306146.png" alt="image-20241116205306146"></p>
<p>该参数规定了起始信号的建立（准备）时间，这个参数有点难理解。我们参照时序定义来看下：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116205502756.png" alt="image-20241116205502756" style="zoom: 50%;">
<p>和t<sub>HD;STA</sub>对比来看，t<sub>HD;STA</sub>规定了起始信号的保持时间（SCL为高时，拉低SDA并保持）。</p>
<p>t<sub>SU;STA</sub> 则是用于重复起始信号的（每次通信至少对应一个START和STOP，连续的多次通信中紧接着前一次通信STOP之后的START可称为 <mark>repeated START</mark>，前面介绍的 <mark>写地址，连续读模式</mark>对应的START,START,STOP中第二个START也是如此）。</p>
<p>对于重复起始信号而言，SCL可能是以低电平开始的（例如上一次通信将SCL拉低了），为了满足实现起始信号（拉低SDA）的<mark>前置条件（SCL为高，SDA为高）</mark>，该参数规定了在拉低SDA之前，SDA应该在SCL为高期间保持高电平的时间。</p>
<h2 id="qi-shi-zhong-zhi-xin-hao-de-shi-xian">起始/终止信号的实现</h2>
<p>这里我们已经可以写出起始信号的伪代码了（所有延时以 Fast-mode 为例）：</p>
<p><code>I2C_Start()</code></p>
<pre class="line-numbers language-none"><code class="language-none">// 前置条件
SDA = HIGH
SCL = HIGH
// 前置条件建立（准备）时间
delay 0.6us

// 起始信号(SCL,SDA为高时，拉低SDA)
SDA = LOW
// 起始信号保持时间
delay 0.6

// 开始第一个时钟周期低电平阶段
SCL = 0;
delay 1.3us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的C语言实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SCL_PIN</span>    <span class="token expression">GPIO_PIN_6</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SDA_PIN</span>    <span class="token expression">GPIO_PIN_7</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_PORT</span>  <span class="token expression">GPIOB</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_RCU</span>   <span class="token expression">RCU_GPIOB</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start setup</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start hold</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>注意</mark>：这里第22行，并没有和伪代码中的1.3us保持一致，是因为在后续的数据传输中，置位SDA后是需要一个setup时延的（例如1us），无形之间延长了SCL低电平的时间（相当于变成为2us），详见后文分析。</p>
<h2 id="t-sub-hd-dat-sub-shu-ju-bao-chi-shi-jian-hol-d-time-for-data">t<sub>HD;DAT</sub>数据保持时间（HolD time for DATA）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116212042232.png" alt="image-20241116212042232"></p>
<p>可以发现该参数对应两种条件： <mark>CBUS compatible controllers</mark>和 <mark>I2C-bus devices</mark>，我们这里只关心I2C，要求持续的最小时间为0，相当于不需要控制时延，暂时可以忽略该参数。</p>
<h2 id="t-sub-su-dat-sub-shu-ju-jian-li-zhun-bei-shi-jian-set-up-time-for-data">t<sub>SU;DAT</sub>数据建立（准备）时间（SetUp time for DATA）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116212548515.png" alt="image-20241116212548515"></p>
<p>该参数规定了SDA建立（准备）时间，也即在SCL为低时，置位SDA为下一个要发送的数据后，到拉高SCL（以让接收方读取数据）之前应该保持的时间：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214624147.png" alt="image-20241116214624147" style="zoom:50%;">
<p>我们每次发送数据都遵循如下流程</p>
<ul>
<li>拉低SCL，并延时t<sub>LOW</sub></li>
<li>准备SDA（下一次要发送的数据），并延时t<sub>SU;DAT</sub></li>
<li>拉高SCL，并延时/t<sub>HIGH</sub></li>
</ul>
<h2 id="fa-song-yi-ge-zi-jie-de-shi-xian">发送一个字节的实现</h2>
<p>至此，我们可以写出发送一个字节的伪代码了（接着之前的 <code>I2C_Start</code>）：</p>
<p><code>I2C_SendByte</code></p>
<pre class="line-numbers language-none"><code class="language-none">uint8_t byte
// 需要循环8次，发送一个字节8个bit
for(i = 0 ; i &lt; 8 ; i++) {
    // 此前I2C_Start的结尾以将SCL拉低，这里我们可以直接准备SDA
    SDA = (byte &amp; (0x08 &gt;&gt; i)) ? HIGH : LOW
    delay 1us // SDA建立时间，这期间SCL仍未低电平，因此一共持续了2us
    
    SCL = HIGH
    delay 1us // SCL高电平周期
    
    SCL = LOW // 开启下一个时钟周期
    delay 1us // SCL低电平周期
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应GD32F4的C语言实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start setup</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start hold</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>byte <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// data set-up</span>

        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="t-sub-r-sub-t-sub-f-sub-shang-sheng-yan-xia-jiang-yan-shi-jian-rising-falling-edge">t<sub>r</sub> / t<sub>f</sub>上升沿/下降沿时间（Rising/Falling edge）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116220318791.png" alt="image-20241116220318791"></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116220810270.png" alt="image-20241116220810270" style="zoom:33%;">
<p>这两个参数规定了SCL和SDA的上升沿（r-rising edge）、下降沿（f-falling edge）的时间控制。这个参数和GPIO对应电气特性中的压摆率（<mark>Slew&nbsp;Rate</mark>）。</p>
<p>以GD32F4为例，对应标准库函数 <code>gpio_output_options_set</code>中的 <code>speed</code>参数，即控制GPIO引脚跳变时，物理电路电平转换所需的时延（例如电容充放电过程需要一定的时间）。</p>
<h2 id="t-sub-su-sto-sub-zhong-zhi-xin-hao-jian-li-zhun-bei-shi-jian-set-up-time-for-stop">t<sub>SU;STO</sub>终止信号建立（准备）时间（SetUp time for STOP）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116221510344.png" alt="image-20241116221510344"></p>
<p>由于终止信号（拉高SDA）是有前置条件的（SCL为高，SDA为低），该参数规定了在拉高SDA之前，SDA在SCL为高期间保持低电平的时间：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222328620.png" alt="image-20241116222328620"></p>
<h2 id="t-sub-buf-sub-zong-xian-shi-fang-shi-jian-b-us-free-time">t<sub>BUF</sub>总线释放时间（BUs Free time）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222447598.png" alt="image-20241116222447598"></p>
<p>该参数规定了在一个终止信号（P）和下一个起始信号（S）之间，总线应该被释放（SCL/SDA保持高电平）的时间：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222631166.png" alt="image-20241116222631166"></p>
<h2 id="zhong-zhi-xin-hao-de-shi-xian">终止信号的实现</h2>
<p>至此，我们可以实现终止信号的伪代码了：</p>
<p><code>I2C_Stop</code></p>
<pre class="line-numbers language-none"><code class="language-none">// 前置条件：SDA为低，SCL为高
// 此前I2C_SendByte的结尾已将SCL拉低，这里可以直接准备SDA
SDA = 0
delay 1us // 为了确保SCL低电平周期大于1.3us，这里补充一个1us
SCL = HIGH
delay 1us // SCL高电平周期
delay 1us // 补充1us，确保&gt;总线释放时间1.3us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应C语言实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//stop setup</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//bus free time between a STOP and START condition</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="t-sub-vd-dat-sub-t-sub-vd-ack-sub-shu-ju-ack-you-xiao-shi-jian-valid-time-for-data-ack">t<sub>VD;DAT</sub>/t<sub>VD;ACK</sub>数据/ACK有效时间（Valid time for DATA/ACK）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116223438554.png" alt="image-20241116223438554"></p>
<p>个人理解这两个参数是在接收的场景下使用的，在作为接收方释放SDA（拉高SDA）之后，发送方会通过拉高/拉低SDA来准备ACK/数据比特，然后我们需要等待t<sub>VD;DAT</sub>/t<sub>VD;ACK</sub>这样一个时间确保发送方准备好SDA了，然后我们再拉高SCL（让发送方保持SDA），并读取SDA。</p>
<h2 id="jie-shou-ack-shu-ju-zi-jie-dai-ma-shi-xian">接收ACK/数据字节代码实现</h2>
<p>至此，我们可以实现接收ack和数据字节的代码了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_IN</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_OUT</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_READ</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_input_bit_get</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

bool <span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bool success <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// release bus</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    success <span class="token operator">=</span> <span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">;</span> <span class="token comment">// read ack</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl low</span>
    <span class="token keyword">return</span> success<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">receive_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// slave keep data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// read data</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// let slave prepare next data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="san-i-2-c-wan-zheng-dai-ma">三、I2C完整代码</h1>
<h2 id="code-hal-i-2-c-soft-h-code"><code>hal_i2c_soft.h</code></h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/16.</span>
<span class="token comment">//</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HAL_I2C_SOFT_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HAL_I2C_SOFT_H</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"gd32f4xx.h"</span></span>

<span class="token keyword">void</span> <span class="token function">hal_i2c_soft_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bool <span class="token function">hal_i2c_soft_write</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
bool <span class="token function">hal_i2c_soft_read</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">hal_i2c_soft_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">//HAL_I2C_SOFT_H</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="code-hal-i-2-c-soft-c-code"><code>hal_i2c_soft.c</code></h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/16.</span>
<span class="token comment">//</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hal_i2c_soft.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"systick.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"logger.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SCL_PIN</span>    <span class="token expression">GPIO_PIN_6</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SDA_PIN</span>    <span class="token expression">GPIO_PIN_7</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_PORT</span>  <span class="token expression">GPIOB</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_RCU</span>   <span class="token expression">RCU_GPIOB</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_IN</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_OUT</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_READ</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_input_bit_get</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token keyword">void</span> <span class="token function">hal_i2c_soft_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使能GPIOB时钟</span>
    <span class="token function">rcu_periph_clock_enable</span><span class="token punctuation">(</span>I2C_GPIO_RCU<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 配置PB6（SCL）和PB7（SDA）为开漏输出模式</span>
    <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SCL_PIN <span class="token operator">|</span> I2C_SDA_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_output_options_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_OTYPE_OD<span class="token punctuation">,</span> GPIO_OSPEED_50MHZ<span class="token punctuation">,</span> I2C_SCL_PIN <span class="token operator">|</span> I2C_SDA_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将SCL和SDA线拉高</span>
    <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN <span class="token operator">|</span> I2C_SDA_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start setup</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start hold</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//stop setup</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//bus free time between a STOP and START condition</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool <span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bool success <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// release bus</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    success <span class="token operator">=</span> <span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">;</span> <span class="token comment">// read ack</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl low</span>
    <span class="token keyword">return</span> success<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">send_ack</span><span class="token punctuation">(</span>bool ack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// set sda to reponse ack/nack</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sda setup</span>

    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// let slave read ack</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reset scl for next operation</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>byte <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// data set-up</span>

        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">receive_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// slave keep data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// read data</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// let slave prepare next data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool <span class="token function">start_for_write</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">send_byte</span><span class="token punctuation">(</span>dev_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write dev_addr failed"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">send_byte</span><span class="token punctuation">(</span>reg_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write reg_addr failed"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool <span class="token function">start_for_read</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">send_byte</span><span class="token punctuation">(</span>dev_addr <span class="token operator">|</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// read from slave</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write dev_addr for read failed"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">hal_i2c_soft_write</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">start_for_write</span><span class="token punctuation">(</span>dev_addr<span class="token punctuation">,</span> reg_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">send_byte</span><span class="token punctuation">(</span><span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write data[%d] failed"</span><span class="token punctuation">,</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        data<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">hal_i2c_soft_read</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// dummy write for register address</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">start_for_write</span><span class="token punctuation">(</span>dev_addr<span class="token punctuation">,</span> reg_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// continuous read</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">start_for_read</span><span class="token punctuation">(</span>dev_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">receive_byte</span><span class="token punctuation">(</span>buf<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">send_ack</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">receive_byte</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">send_ack</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>I2C</tag>
        <tag>时序要求</tag>
        <tag>PCF8563</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/11/12/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>论时序要求的重要性（移位寄存器控制数码管）</title>
    <url>/2024/11/15/31801.html</url>
    <content><![CDATA[<h1 id="1-wen-ti-bei-jing">1. 问题背景</h1>
<h2 id="ying-jian-bei-jing">硬件背景</h2>
<ul>
<li>移位寄存器：<a href="https://item.szlcsc.com/79848.html?fromZone=s_s__%2274HC595N%22">SN74HC595N</a></li>
<li>两个4位共阳数码管</li>
</ul>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/20241115163627.png" alt=""></p>
<h2 id="yi-wei-suo-cun-luo-ji-set-reset">移位/锁存逻辑——set/reset</h2>
<p>在学习GD32F407VET时，将学习STC8实现的数码管模块移植过来，发现了一个很奇怪的问题。其中移位操作的实现如下（封装了对两个串联移位寄存器的移位操作，控制8个数码管中显示哪一个，以及控制数码管显示内容）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现单独指定某个数码管显示某个数是没有问题的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 要显示1~8对应的码表</span>
<span class="token class-name">uint8_t</span> code<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0xF9</span><span class="token punctuation">,</span> <span class="token number">0xA4</span><span class="token punctuation">,</span> <span class="token number">0xB0</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">,</span> <span class="token number">0x92</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0xF8</span><span class="token punctuation">,</span> <span class="token number">0x80</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">Int_NixieTube_DisplaySingle</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> code<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但是想使用 <code>for</code>控制数码管轮流显示1~8时，就发现显示的内容并不符合预期：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Int_NixieTube_DisplaySingle</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> code<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="yi-wei-suo-cun-luo-ji-write">移位/锁存逻辑——write</h2>
<p>但是将其中 <code>gpio_bit</code> 的 <code>set/reset</code>换成 <code>write</code>之后，发现数码管能够按照预期显示了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">,</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">,</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">,</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">,</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看这些函数的实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">GPIO_BOP</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">GPIO_BC</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">,</span> bit_status bit_value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>RESET <span class="token operator">!=</span> bit_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">GPIO_BOP</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">GPIO_BC</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现 <code>write</code>只不过将 <code>set/reset</code>包成了一个函数，唯一不同的就是多了一个 <code>if</code>判断。</p>
<p>但是，一个<code>if</code> 的耗时又能对程序产生什么影响呢？我百思不得其解。</p>
<h1 id="2-shi-xu-yao-qiu-yin-fa-de-xie-an">2. 时序要求引发的血案</h1>
<h2 id="xiao-xiao-if-an-cang-xuan-ji">小小if暗藏玄机</h2>
<p>在各种 <code>Google, GPT</code>之后，结合代码上下文，发现代码中使用了 <code>nop</code>来增加时延，再结合移位寄存器需要根据我们通过GPIO发送的SRCLK（移位时钟）、RCLK（锁存时钟）的上升沿来进行移位操作和锁存操作（将移位寄存器更新到锁存寄存器 storage register）。</p>
<p>我设置的GD32F407的主频是168MHz，这个比STC8时的24MHz还是要快几倍的，计算一下<code>nop</code>对应一个时钟周期的时间为 <code>1/168MHz</code>约为 <code>5.95ns</code>、<code>1/24MHz</code>约为 <code>41.67ns</code>。</p>
<p>这样看来，一个 <code>if</code>判断还真有可能引发了血案，其所消耗的时钟周期（增加的时延）可能正好满足了移位寄存器的<strong>时序要求</strong>，从而使得数码管能够正常显示。</p>
<h2 id="shu-ju-shou-ce-bu-ke-shao">数据手册不可少</h2>
<p>在想到可能时时延导致的问题后，不妨看一下芯片对应的官方手册，看能否找到答案。</p>
<p>这里要注意的是，一定要找与芯片型号、品牌一致的：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241115170556369.png" alt="image-20241115170556369"></p>
<h2 id="timing-requirements">Timing Requirements</h2>
<p>这里我们主要看时序要求（Timing Requirements ）相关的章节</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241115170729345.png" alt="image-20241115170729345"></p>
<h3 id="set-up-time">Set-up time</h3>
<p>其中描述了，我们在使用串行信号线 <code>SER</code>、移位寄存器时钟线 <code>SRCLK</code>、锁存器时钟线 <code>RCLK</code> 来操作 <a href="https://item.szlcsc.com/79848.html?fromZone=s_s__%2274HC595N%22">SN74HC595N</a> 时，需要的准备时间，例如</p>
<h4 id="ser-before-srclk">SER before SRCLK↑</h4>
<p>在操作SRCLK上升沿将SER存入移位寄存器之前，SER应该预备的时间，以125ns为例，伪代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
SRCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="srclk-before-rclk">SRCLK↑ before RCLK↑</h4>
<p>在操作完所有的移位后，将移位寄存器更新到锁存寄存器（即更新到电路，控制数码管的段选和片选），需要操作RCLK上升沿。</p>
<p>该参数规定了，RCLK上升沿应该与SRCLK上升沿保持的时间间隔</p>
<h3 id="pulse-duration">Pulse duration</h3>
<p>其中描述了SRCLK、RCLK被置位后应该持续一段时间，所以我们还需要在上述基础上增加两个延时（以100ns为例）</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
wait 100ns
SRCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再加上锁存的操作：</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
wait 100ns
SRCLK = 1;

wait 100ns
RCLK = 0;
wait 100ns
RCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="zai-kan-if-he-nop">再看if和nop</h2>
<p>之前对于时序控制的理解并不深刻，简单的以为使用 <code>nop</code>停顿一下就好。现在看来，无论是不同主频对应的 <code>nop</code>时延不同，还是 <code>if</code>耗时也能影响数码管的生死，都在提醒我们时序控制不可小觑。</p>
<p>在使用MCU对外围设备/芯片交互</p>
<p>、控制时，一定要严格按照芯片要求的时序控制，结合MCU自身指令耗时来编写程序。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里宁愿多等一点，也不要让 SN74HC595N 无法准确移位、锁存数据。</p>
]]></content>
      <categories>
        <category>GD32</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>GD32</tag>
        <tag>时序要求</tag>
        <tag>SN74HC595NSR</tag>
        <tag>移位寄存器</tag>
      </tags>
  </entry>
</search>
