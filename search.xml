<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM核学习（一）工作模式及寄存器资源</title>
    <url>/2024/11/23/1780.html</url>
    <content><![CDATA[<h1 id="can-kao-zi-liao">参考资料</h1>
<p><a href="https://developer.arm.com/documentation/ddi0406/latest/">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p>
<h1 id="arm-he-ar-mv-7-a-r-gong-zuo-mo-shi">ARM核（ARMv7-A/R）工作模式</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123192806705.png" alt="Table B1-1 ARM processor modes  "></p>
<ul>
<li>
<p>从异常模式来看，只有 User 和 System 是非异常模式；</p>
</li>
<li>
<p>从特权级别来看，只有 User 是非特权级别；</p>
</li>
</ul>
<h2 id="privilege-level">Privilege Level</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123192948933.png" alt="Privilege Level"></p>
<h2 id="arm-processor-modes">ARM Processor Modes</h2>
<h3 id="user-mode">User mode</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123193912894.png" alt="image-20241123193912894"></p>
<ul>
<li>操作系统通过在用户模式下运行引用程序来限制其对系统资源的访问，例如文件、进程等。</li>
<li>用户模式下的任何应用程序不能切换模式，除非通过软中断或异常。</li>
</ul>
<h3 id="system-mode">System mode</h3>
<blockquote>
<p>Software executing in System mode executes at PL1. System mode has the same registers available</p>
<p>as User mode, and is not entered by any exception</p>
</blockquote>
<p>在系统模式下运行的软件拥有PL1的特权，能够访问一些受控资源。系统模式和用户模式共用同一套可用的寄存器，并且无法通过任何异常来进入该模式。</p>
<h3 id="supervisor-mode">Supervisor mode</h3>
<blockquote>
<p>Supervisor mode is the default mode to which a Supervisor Call exception is taken.<br>
Executing a SVC (Supervisor Call) instruction generates an Supervisor Call exception, that is taken<br>
to Supervisor mode.<br>
A processor enters Supervisor mode on Reset.</p>
</blockquote>
<p>管理模式是CPU上电后默认的模式，因此在该模式下主要用来做系统的初始化，软中断处理也在该模式下。</p>
<p>当用户模式下的用户程序请求使用硬件资源时，通过软件中断进入该模式。</p>
<h3 id="abort-mode">Abort mode</h3>
<blockquote>
<p>Abort mode is the default mode to which a Data Abort exception or Prefetch Abort exception is<br>
taken</p>
</blockquote>
<p>终止模式是数据终止异常或指令预取终止异常发生时默认进入的模式。</p>
<p>数据终止异常：当用户程序访问非法地址、没有权限读取的地址时会发生该异常。例如linux下编程时经常遇到的<code>segment fault</code>：</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4">以下是一些导致储存器段错误的一般编程错误</a>：</p>
<ul>
<li>引用空指针</li>
<li>引用未初始化的野指针</li>
<li>引用已经被调用free()函数释放了的悬空指针</li>
<li>缓冲区溢出</li>
<li>堆栈溢出</li>
<li>运行未正确编译的程序（尽管存在编译时错误，某些编译器依然会输出可执行文件）</li>
</ul>
</blockquote>
<p>预取指令异常：预取指令是指令流水线中的概念。该异常发生在预取指令时无法获取到正确的可执行指令，我们有时运行错误代码会出现程序跑飞了的情况就是因为预取不到正确的指令了，CPU无法继续正常执行。</p>
<h3 id="undefined-mode">Undefined mode</h3>
<blockquote>
<p>Undefined mode is the default mode to which an instruction-related exception, including any<br>
attempt to execute an UNDEFINED instruction, is taken</p>
</blockquote>
<p>当CPU遇到一个它无法识别的指令时发生该异常。例如在ARM架构的CPU上执行一条Intel指令。</p>
<h3 id="fiq-mode">FIQ mode</h3>
<blockquote>
<p>FIQ mode is the default mode to which an FIQ interrupt is taken.</p>
</blockquote>
<p>FIQ是Fast Interrupt reQuetst，快速中断模式。快速是相当于一般中断模式（IRQ）而言的，用来处理对时间要求比较紧急的中断，主要用于高速数据传输及通道处理中。</p>
<h3 id="irq-mode">IRQ mode</h3>
<p>一般中断模式，也称普通中断模式，用于处理一般的中断请求。通常在硬件中断发生后自动进入该模式，该模式为特权模式，能够自由访问系统硬件资源。</p>
<h1 id="arm-he-ji-cun-qi-zi-yuan">ARM核寄存器资源</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123201917744.png" alt="image-20241123201917744"></p>
<h2 id="gai-lan">概览</h2>
<h3 id="ji-cun-qi-gong-xiang">寄存器共享</h3>
<p>R0~R7这几个寄存器是所有模式共享的，这意味着在模式发生切换时，为了不影响先前模式的寄存器数据，当前模式需要在使用这些寄存器之前先将它们压栈（内存区域中的栈）保存，并在模式退出时出栈以将寄存器恢复成原样。</p>
<p>同样的R8~R12是除了FIQ的所有模式共享的。</p>
<h3 id="ji-cun-qi-du-you">寄存器独有</h3>
<p>对于R8~R12，FIQ由自己独有的寄存器，这是为了提高该模式的处理效率：在进入该模式后，访问这几个寄存器无需压栈保护和出栈复原。<mark>这也是FIQ比IRQ快的原因之一。</mark></p>
<h3 id="yi-chang-mo-shi-ji-cun-qi">异常模式寄存器</h3>
<p>可以发现，对于SP和LR寄存器，除了User和System两个非异常模式，其他模式都对应有自己独立的。它们与异常跳转有关。</p>
<h3 id="pc-ji-cun-qi">PC寄存器</h3>
<p>PC（Program Counter）程序计数器用来指向指令地址，在32位CPU顺序执行的过程中，每条指令相隔4个字节，地址相隔0x4，通过将PC的值依次递增0x4就能实现顺序执行的效果。</p>
<p>但是发生模式切换时，需要修改PC的值以告诉CPU从哪里开始接着执行程序指令。</p>
<h3 id="cpsr-spsr">CPSR/SPSR</h3>
<p>Current Program Status Register，当前程序状态寄存器，其中包含了当前程序执行过程中产生的一些状态位，例如</p>
<ul>
<li>N：negtive，负数标志，例如比较指令 <code>cmp</code> 就是将一个数减去另一个数，如果结果为负，则将N位置1，后续指令可以通过增加条件后缀 <code>lt</code>、<code>le</code>（less than、less than or equals to）结合N标志位来实现类似 <code>if</code>条件的效果</li>
<li>C：carry，进位标志</li>
</ul>
<p>可以理解这个寄存器保存了当前程序的上下文信息。</p>
<p>Saved Program Status Register，暂存的程序状态寄存器。当发生模式切换时，应通过SPSR保存CPSR（之前的程序运行状态），并在返回时将SPSR会写到CPSR。</p>
<h2 id="ji-cun-qi-yong-tu-fen-xi">寄存器用途分析</h2>
<h3 id="tong-yong-ji-cun-qi-r-0-10">通用寄存器R0~10</h3>
<p>用来存放用户的数据，例如函数入参、函数返回值等</p>
<h3 id="zhan-xiang-guan-ji-cun-qi">栈相关寄存器</h3>
<ul>
<li>
<p>R11（fp: frame pointer）：用来记录一个栈空间的开始地址</p>
</li>
<li>
<p>R12（ip：The Intra-Procedure-call scratch register）用来临时存储sp</p>
</li>
<li>
<p>R13（sp：stack pointer）：栈指针寄存器（指向栈顶），压栈时根据该寄存器中的地址存放数据并更新栈指针到下一个位置</p>
</li>
</ul>
<p><mark>栈空间的计算：sp - fp</mark></p>
<h3 id="tiao-zhuan-xiang-guan-branch-ji-cun-qi">跳转相关（branch）寄存器</h3>
<ul>
<li>R14（lr，link register）：在发生跳转（函数调用，中断处理）时，用来保存PC寄存器的值。后面通过将lr会写PC即可实现跳转后的返回。</li>
</ul>
<h3 id="pc-ji-cun-qi-1">PC寄存器</h3>
<p>program counter：用来存放CPU需要执行的指令地址。</p>
<p>之所以称之为counter计数器，是因为指令宽度是固定的（例如ARMv7中是32位字宽），通过在当前指令的地址上偏移固定的指令位宽（例如4个字节+0x4）就能取到顺序的下一条指令。</p>
<h2 id="cpsr-cheng-xu-zhuang-tai-ji-cun-qi">CPSR（程序状态寄存器）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124085427517.png" alt="image-20241124085427517"></p>
<h3 id="tiao-jian-biao-zhi-wei-ke-bei-xu-duo-zhi-ling-she-zhi">条件标志位（可被许多指令设置）</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123230843319.png" alt="image-20241123230843319"></p>
<h3 id="n-fu-hao-tiao-jian-biao-zhi-wei">N-负号条件标志位</h3>
<blockquote>
<p>Negative condition flag. Set to bit[31] of the result of the instruction. If the result is<br>
regarded as a two’s complement signed integer, then the processor sets N to 1 if the result<br>
is negative, and sets N to 0 if it is positive or zero.</p>
</blockquote>
<p>当指令的结果为有符号整数时，处理器会在该结果为负数时将N置1。例如我们有时需要根据条件来跳转：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
	<span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应指令伪代码如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov r0,a // 将a加载到r0寄存器
mov r1,b // 将b加载到r1寄存器
cmp r0,r1 // 通过r0-r1来比较两者的值，如果结果为负数则将N置1，否则置0
bgt foo // b：branch分支跳转 gt：greater than，如果N=0（a&gt;=b），则跳转到foo函数入口地址
ble fun // le：less than or equals to，如果N=1（a&lt;b），则跳转到fun函数入口地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="z-ling-tiao-jian-biao-zhi-wei">Z-零条件标志位</h3>
<blockquote>
<p>Zero condition flag. Set to 1 if the result of the instruction is zero, and to 0 otherwise. A<br>
result of zero often indicates an equal result from a comparison</p>
</blockquote>
<p>当指令结果为0时会将Z置1。Z位为1通常标示了一个结果为0的比较指令，例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对应指令 伪代码如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov r0,a
mov r1,b
cmp r0,r1 // 通过r0-r1来比较两者的值，如果结果为0则将Z置1（当然也会将N置0）
beq foo // b：branch分支跳转 eq：equals to，如果Z=1，则跳转foo函数入口地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="c-jin-wei-tiao-jian-biao-zhi-wei">C-进位条件标志位</h3>
<blockquote>
<p>Carry condition flag. Set to 1 if the instruction results in a carry condition, for example an<br>
unsigned overflow on an addition.</p>
</blockquote>
<p>如果指令的结果产生了进位，则C位会被置1。例如加法过程中的无符号溢出。以 <code>uint32_t</code>为例，最大为 <code>0xFFFFFFFF</code>，如果对其进行加法操作则会产生进位，例如</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> a <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">;</span>
<span class="token class-name">uint32_t</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 产生进位，C被置1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="v-yi-chu-tiao-jian-biao-zhi-wei">V-溢出条件标志位</h3>
<blockquote>
<p>Overflow condition flag. Set to 1 if the instruction results in an overflow condition, for<br>
example a signed overflow on an addition</p>
</blockquote>
<p>如果指令的结果产生了溢出（<mark>超过了数据类型的表示范围</mark>），例如加法中的有符号溢出，则会将该位置1。这里要和C位区分开来，C位是针对无符号的（运算不考虑符号位），V是针对有符号的。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">signed</span> <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
<span class="token keyword">signed</span> <span class="token keyword">char</span> tmp <span class="token operator">=</span> ch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 有符号char最大值为127，加1后为128超过了char的标示范围（-128~127）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="i-f-jin-yong-biao-zhi-wei">I/F-禁用标志位</h3>
<p>I位置1标示禁用IRQ异常，F位置1标示禁用FIQ异常</p>
<blockquote>
<p>In an implementation that does not include the Security Extensions, setting a mask bit masks the<br>
corresponding exception, meaning it cannot be taken</p>
</blockquote>
<h3 id="t-biao-zhi-wei">T标志位</h3>
<p>标示了处理器指令集的状态：</p>
<ul>
<li>ARM状态：32位指令</li>
<li>Thumb状态：16位指令（可以理解位ARM指令的压缩版）</li>
</ul>
<h3 id="m-biao-zhi-wei">M标志位</h3>
<p>标示处理器当前的工作模式，参见本文 <mark>ARM&nbsp;Processor&nbsp;Modes</mark>对应的章节。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM核学习（三）指令流水线分析及伪指令</title>
    <url>/2024/11/24/14899.html</url>
    <content><![CDATA[<h1 id="zhi-ling-liu-shui-xian-fen-xi">指令流水线分析</h1>
<h2 id="qian-yan">前言</h2>
<p>在ARM核中，为增加处理器指令流的速度，ARM7系列使用3级流水线。允许多个操作同时处理，而非顺<br>
序执行。<mark>不同的ARM核，流水线的级数是不一样的，ARM核版本越高，流水线级数越多。对于软件工</mark><br>
<mark>程师编程而言，统一按照三级流水线来分析就可以了。</mark></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124174742518.png" alt="image-20241124174742518" style="zoom: 33%;">
<blockquote>
<p>在MDK中断点调试时会发现PC指向的当前代码行，这是因为MDK调试屏蔽了底层流水线细节，以避免产生歧义。</p>
</blockquote>
<p>在ARM状态，指令位宽为32位4字节，因此当PC预取（例如）0x8地址的指令时，0x4地址的指令正在被解码、0x0地址的指令正在被执行。Thumb状态是压缩格式的指令集，指令位宽是16位2字节，因此偏差是2。</p>
<h2 id="zui-jia-liu-shui-xian-fen-xi-jin-cao-zuo-ji-cun-qi">最佳流水线分析（仅操作寄存器）</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124175951254.png" alt="image-20241124175951254" style="zoom:50%;">
<h2 id="nei-cun-fang-wen-zhi-ling-liu-shui-xian">内存访问指令流水线</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124180204732.png" alt="image-20241124180204732"></p>
<p>由于内存访问效率较低，因此在执行LDR指令时，无法在一个指令周期内完成（需要E、M、W三个周期）。这样，即使它前面的D跑得快，但解码的指令无法移交给E（它手上的活还没干完），只能干等，F也是一样。</p>
<h2 id="fen-zhi-tiao-zhuan-liu-shui-xian-ju-li">分支（跳转）流水线举例</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124181209542.png" alt="image-20241124181209542"></p>
<p>在E执行跳转指令时，跑在它前面的F、D不得不丢弃已完成的工（解码 <code>0x3004 SUB</code>，预取 <code>0x3008 AND</code>）作，转而从目标地址重新开始F、D、E流程。</p>
<p>图中E执行 <code>BL 0X8FEC</code>时，F正在预取 <code>0x3008</code>地址的指令，在该指令周期结束时，PC指向 <code>0x3008</code>，且由于是 <code>BL</code>跳转，因此该值会被保存到 <code>LR</code>寄存器中。</p>
<p>当执行 <code>L</code>指令时，会将<code>LR</code>回写到 <code>PC</code>中，但是由于此前对于 <code>0X3004</code>的解码工作被丢弃了，因此处理器会自动执行一个 <code>A</code>指令，将 <code>PC</code>调整到 <code>0x3004</code>的位置接着执行。</p>
<h2 id="zong-jie">总结</h2>
<ul>
<li>当只有寄存器操作（操作效率和CPU处于同一量级）时，指令流线效率是最高的：在每个指令周期，流水线上的三个工人F、D、E都在不停互相配合，高效完成指令执行所需的三个阶段的工作。</li>
<li>当访问内存（外设）时，由于物理特性，处理器的工作效率远高于外设，因此工人E只能放慢节奏和外设协同把活干了，这期间即使F、D完成了手头上的活，由于不能向D、E移交，因此也只能干等着。导致了级联停顿（stall）的效应。</li>
<li>当发生跳转时，工人F、D超前完成的工作只能被迫丢弃，转而从新的指令地址重新开始干活，且如果跳转回来，之前干完的活还得重新再干一次。</li>
</ul>
<h1 id="chang-yong-wei-zhi-ling-fen-xi">常用伪指令分析</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124183925641.png" alt="image-20241124183925641"></p>
<h2 id="ldr-r-0-0-x-12345678-fen-xi">LDR R0,=0x12345678 分析</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124184043373.png" alt="image-20241124184043373"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124184314696.png" alt="image-20241124184314696"></p>
<p>编译器会将常量 <code>0x12345678</code>预先放到某个内存中（通常是所有代码指令之后），并将LDR翻译成一条读内存的指令。</p>
<h2 id="ldr-r-0-label-fen-xi">LDR R0,=label 分析</h2>
<p>标签本质上是一个常量，它的值就是标签后第一条指令的地址，可以理解为给这个地址取了个别名。</p>
<h3 id="dai-ma-duan-qi-shi-di-zhi-wei-0-x-0">代码段起始地址为0x0</h3>
<p>对于给定的代码段起始地址和指令位宽，每条指令的存放地址在编译阶段都可以确定，如下将代码段的起始地址配置为 <code>0x0</code>：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124185737443.png" alt="image-20241124185737443" style="zoom:33%;">
<p>对于ARM状态下（指令位宽为4字节），如下代码的每条指令都可以顺序计算其存储地址</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#1			@0x00000000
	mov r2,#2			@0x00000004
	ldr r3,=addr		@0x00000008
	ldr r4,[r3]			@0x0000000C
	
stop:
	b stop				@0x00000010
	
addr:					@给0x00000014取了个别名叫addr
	.word 0x12345678	@0x00000014 在这个地址存放一个字的数据
		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是：标签的声明并不属于指令，因此不占用地址空间。其中 <code>ldr r3,=addr</code>等价于 <code>ldr r3,=0x00000014</code>。</p>
<p><code>ldr r3,=addr</code>（将addr表示的地址值加载到R3）分析如下：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124190511217.png" alt="image-20241124190511217"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124190550278.png" alt="image-20241124190550278"></p>
<p><code>ldr r4,[r3]</code>：从R3对应的地址读取数据（该数据 <code>0x12345678</code> 在编译阶段通过 <code>.word</code>伪指令预先存储在了内存空间中）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124190809542.png" alt="image-20241124190809542"></p>
<h3 id="dai-ma-duan-qi-shi-di-zhi-wei-0-x-2000">代码段起始地址为0x2000</h3>
<p>将代码段起始地址改为0x2000，计算规则是一样的，在编译阶段就能确定各个指令以及 <code>.word</code>数据存放的地址（注意修改后需要重新编译下）：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124200510540.png" alt="image-20241124200510540" style="zoom:33%;">
<p>调试前需要修改下内存映射，默认是从0x0开始执行的，我们需要让0x0到0x2000及其后的一段内存都可执行：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124200751229.png" alt="image-20241124200751229" style="zoom:50%;">
<p>然后在 <code>_start</code>的第一条指令打个断点，跳过从0x0到0x2000之间的无效指令：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124201005483.png" alt="image-20241124201005483" style="zoom: 33%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124200325028.png" alt="image-20241124200325028" style="zoom:33%;">
<h3 id="zong-jie-1">总结</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124195231017.png" alt="image-20241124195231017" style="zoom: 50%;">
<h2 id="ldr-r-0-label-fen-xi-1">LDR R0,label 分析</h2>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#1			
	mov r2,#2			
	ldr r3,addr			
	mov r4,r3			
stop:
	b stop				
addr:	
	.word 0x12345678	
		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ldr r3,=addr</code>可以理解为将标签 <code>addr</code>的值当做常量加载到R3中，而 <code>ldr r3,addr</code>则是从 <code>addr</code>对应的地址加载数据到R3中，相当于 <code>R3=p</code>和 <code>R3=*p</code>的关系</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124201244164.png" alt="image-20241124201244164" style="zoom: 33%;">
<h2 id="adr-r-0-label-dong-tai-huo-qu-biao-qian-di-zhi">ADR R0,label 动态获取标签地址</h2>
<blockquote>
<p>This instruction adds an immediate value to the PC value to form a PC-relative address, and writes the result to the destination register.</p>
</blockquote>
<p>ADR 是 “Address” 的缩写，它是一条用于生成地址的伪指令。ADR 指令用于计算一个目标地址，并将其存储到指定的寄存器中。目标地址是基于当前 PC 加上一个偏移量计算得出的，因此它只能访问当前代码段附近的地址。</p>
<h3 id="strong-zhi-ling-ge-shi-strong"><strong>指令格式</strong></h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ADR &lt;Rd&gt;, &lt;label&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>&lt;Rd&gt;</code>：目标寄存器，用于存储计算出的地址。</li>
<li><code>&lt;label&gt;</code>：目标地址标签，必须位于当前指令前后一定范围内。</li>
</ul>
<h3 id="shi-li">示例</h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#1			
	mov r2,#2			
	adr r3,addr			
	ldr r4,[r3]		
stop:
	b stop				
addr:	
	.word 0x12345678	
		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124202620567.png" alt="image-20241124202620567"></p>
<h3 id="dui-bi-ldr-r-0-label">对比 LDR R0,=label</h3>
<p>如下图，<code>LDR R0,=label</code>编译时，编译器会根据代码段起始地址和指令位宽计算出label对应的地址值（<code>0x00000014</code>），并单独开辟一个内存（<code>0x00000018</code>）存放这个<mark>写死</mark>的数据，在运行时通过LDR读取这个内存中写死的label地址值到R3中。</p>
<p>如果起始地址为 <code>0x2000</code>，那么编译器就会在内存中存放一个写死的 <code>0x2014</code>，显然这是一种<mark>静态的做法</mark>（和编译时设置的代码段起始地址是<mark>强绑定的</mark>），如果程序换一个地址空间运行，这个写死的地址值就没有意义了。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124203311920.png" alt="image-20241124203311920"></p>
<p>而 <code>ADR R0,label</code>则是运行时动态获取标签对应的地址值，例如编译器知道执行当前指令时，通过在PC上偏移4个字节就能寻址到label对应的地址，那么通过 <code>ADD</code>指令就能在<mark>运行时动态获取</mark>该label对应的地址。这种做法是<mark>不依赖编译时设定的代码段起始地址的，无论使用什么起始地址，都能够得到一个正确的标签地址</mark>。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124204230866.png" alt="image-20241124204230866"></p>
<h2 id="ru-he-pan-bie-dai-ma-zai-shi-ji-nei-cun-zhong-yun-xing-de-di-zhi">🌟如何判别代码在实际内存中运行的地址？</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124204803253.png" alt="image-20241124204803253"></p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
        <tag>指令流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM核学习（二）指令集</title>
    <url>/2024/11/24/18972.html</url>
    <content><![CDATA[<h1 id="can-kao-zi-liao">参考资料</h1>
<p><a href="https://developer.arm.com/documentation/ddi0406/cd/?lang=en">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p>
<h1 id="mdk-huan-jing-da-jian">MDK环境搭建</h1>
<h2 id="xia-zai-legacy-support-zhi-chi-bao">下载Legacy Support支持包</h2>
<p><a href="https://armkeil.blob.core.windows.net/legacy/MDK79525.EXE">https://armkeil.blob.core.windows.net/legacy/MDK79525.EXE</a></p>
<p>安装到MDK的安装目录下</p>
<h2 id="xia-zai-arm-gnu-gong-ju-lian">下载ARM GNU工具链</h2>
<p><a href="https://developer.arm.com/-/media/Files/downloads/gnu/13.3.rel1/binrel/arm-gnu-toolchain-13.3.rel1-mingw-w64-i686-arm-none-eabi.exe">https://developer.arm.com/-/media/Files/downloads/gnu/13.3.rel1/binrel/arm-gnu-toolchain-13.3.rel1-mingw-w64-i686-arm-none-eabi.exe</a></p>
<blockquote>
<p><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">下载页面</a></p>
</blockquote>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124092507291.png" alt="image-20241124092507291" style="zoom:50%;">
<h2 id="chuang-jian-xiang-mu">创建项目</h2>
<p>安装Legacy Support之后，可以在Device中对其进行选择</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124091834836.png" alt="image-20241124091834836"></p>
<p>然后选择ARM9E-S（Little Endian）进行仿真</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124092007126.png" alt="image-20241124092007126" style="zoom:50%;">
<p>键入如下代码：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1
	mov r1,#2
	mov r2,#3
	
stop:
	b stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124093601960.png" alt="image-20241124093601960" style="zoom:50%;">
<h2 id="pei-zhi-arm-gnu-gong-ju-lian">配置ARM GNU工具链</h2>
<p>配置交叉编译工具链，即此前下载的ARM GNU的安装路径</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124093644442.png" alt="image-20241124093644442" style="zoom: 50%;">
<h2 id="bian-yi-xiang-mu">编译项目</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124093742741.png" alt="image-20241124093742741" style="zoom:50%;">
<h2 id="fang-zhen-diao-shi-pei-zhi">仿真/调试配置</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124093931756.png" alt="image-20241124093931756" style="zoom: 50%;">
<p>配置代码段开始地址：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124094012862.png" alt="image-20241124094012862" style="zoom:50%;">
<p><mark>注意</mark>：每次修改了编译配置选项后，最好重新编译一下以使其生效：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124094203216.png" alt="image-20241124094203216"></p>
<h2 id="kai-shi-diao-shi">开始调试</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124094253900.png" alt="image-20241124094253900"></p>
<p>如果点击调试按钮后出现如上界面，则仿真环境配置成功了。左侧是ARM核的寄存器（可参考另一篇文章《ARM核（ARMv7-A/R）学习》），右上方是对应的汇编指令。</p>
<p>点击左上方的调试按钮，可以发现立即数1、2、3被依次加载到寄存器R0、R1、R2中了：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124094832406.png" alt="image-20241124094832406" style="zoom:50%;">
<h1 id="zhi-ling-ge-shi">指令格式</h1>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124101014161.png" alt="image-20241124101014161" style="zoom:50%;">
<h2 id="he-fa-li-ji-shu">合法立即数</h2>
<p>立即数使用 <code>#数字</code>来表示</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124102202527.png" alt="image-20241124102202527"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124102256351.png" alt="image-20241124102256351"></p>
<h2 id="ji-cun-qi-yi-wei">寄存器移位</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124102702102.png" alt="image-20241124102702102"></p>
<h1 id="chang-yong-arm-he-zhi-ling">常用ARM核指令</h1>
<p>参见手册中的 <mark>A8.8 Alphabetical list of instructions</mark>章节</p>
<h2 id="shu-ju-chuan-song-zhi-ling">数据传送指令</h2>
<h3 id="mov">MOV</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124103655266.png" alt="image-20241124103655266" style="zoom:50%;">
<h3 id="mvn">MVN</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124103924679.png" alt="image-20241124103924679" style="zoom:50%;">
<h3 id="ldr">LDR</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124104010947.png" alt="image-20241124104010947" style="zoom:50%;">
<p><mark>注意：数字常量前需要加上“=”，这是常量/字面量表示的语法规则</mark></p>
<p>当数据不是合法立即数时，作为MOV的替代指令。这是一条伪指令，底层是通过将数据（<code>=</code>号后面的数字）先存放到内存，再通过LDR(从内存加载到寄存器)指令来实现的。</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124104851454.png" alt="image-20241124104851454" style="zoom: 33%;">
<h2 id="shu-ju-ji-suan-zhi-ling">数据计算指令</h2>
<h3 id="add-jia-fa">ADD加法</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124105251693.png" alt="image-20241124105251693" style="zoom:50%;">
<h3 id="sub-jian-fa">SUB减法</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124105408936.png" alt="image-20241124105408936" style="zoom:50%;">
<p>默认情况下SUB是不会影响CPSR的N标志位的，如果需要则要加上S后缀：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124105935847.png" alt="image-20241124105935847" style="zoom: 33%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124110015698.png" alt="image-20241124110015698" style="zoom:33%;">
<h3 id="mul-cheng-fa">MUL乘法</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124110117129.png" alt="image-20241124110117129"></p>
<h3 id="lian-xi">练习</h3>
<blockquote>
<p>练习1：<br>
(2&lt;&lt;2)-5+0x12345678, 计算的结果存放在r0</p>
<p>练习2：<br>
25-3*5+6 最终的计算结果存放在r0中</p>
</blockquote>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#2
	mov r1,r0,lsl #2
	sub r1,r1,#5
	ldr r0,=0x12345678
	add r1,r1,r0
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#3
	mov r1,#5
	mul r2,r0,r1 @r0=3*5
	mov r1,#25
	sub r0,r1,r2 @r0=25-15
	add r0,r0,#6 @r0=10+6
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="wei-yun-suan-zhi-ling">位运算指令</h2>
<h3 id="and">AND</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124112800154.png" alt="image-20241124112800154" style="zoom:50%;">
<h3 id="orr-an-wei-huo">ORR-按位或</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124112835561.png" alt="image-20241124112835561" style="zoom:50%;">
<h3 id="eor-an-wei-yi-huo-exclusive-or">EOR-按位异或（Exclusive OR）</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124113112400.png" alt="image-20241124113112400" style="zoom:50%;">
<h3 id="bic-wei-qing-chu-zhi-ling">BIC-位清除指令</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124113149176.png" alt="image-20241124113149176" style="zoom:50%;">
<h3 id="lian-xi-1">练习</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124113304642.png" alt="image-20241124113304642" style="zoom:50%;">
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	ldr r0,=0x12345678
	ldr r1,=0xFFFF0000
	bic r1,r0,r1
	mov r0,r0,lsr #16
	add r0,r0,r1
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	ldr r0,=0xabcd
	
	mov r1,#0x7
	bic r0,r1,lsl #1
	
	mov r1,#0x5
	orr r0,r1,lsl #1
	
	mov r1,#0x1f
	bic r0,r1,lsl #7
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="bi-jiao-zhi-ling-cmp">比较指令CMP</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124114532330.png" alt="image-20241124114532330" style="zoom:50%;">
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#5
	mov r1,#6
	mov r2,#10
	
	cmp r0,r1
	addgt r1,r1,#1
	
	cmp r0,r2
	addle r2,r2,#1
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124114808027.png" alt="image-20241124114808027" style="zoom: 50%;">
<h2 id="tiao-zhuan-zhi-ling">跳转指令</h2>
<h3 id="b-bl">B/BL</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124125817106.png" alt="image-20241124125817106"></p>
<blockquote>
<p>Branch causes a branch to a target address.</p>
</blockquote>
<p>B指令用于跳转到一个目标地址（指令存放地址），该指令会修改PC的值，就像从处理器的顺序执行路径开了一个分岔一样，让处理器从既定的顺序指令序列跳到了另一个指令序列。常用于函数调用、中断处理。</p>
<p>BL指令在B指令的基础之上增加了一个操作：将跳转前PC的值保存到LR寄存器中。这样如果想从分岔回到原来的路径继续执行，只需将LR会写PC即可。</p>
<h4 id="si-xun-huan-de-shi-xian">死循环的实现</h4>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1
	mov r1,#2
	b _start
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="han-shu-diao-yong">函数调用</h4>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1
	mov r1,#2
	bl add
	
	mov r3,r2
	
stop:
	b _start
	
add:
	add r2,r0,r1
	mov pc,lr
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过单步调试观察PC的变化我们可以发现每条汇编指令的地址是按照编写顺序从上到下依次编址的，每条指令地址相隔4个字节，也即偏移量为0x4</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1 @instruction address =&gt; 0x00000000
	mov r1,#2 @instruction address =&gt; 0x00000004
	bl add	  @instruction address =&gt; 0x00000008
	
	mov r3,r2 @instruction address =&gt; 0x0000000C
	
stop:
	b _start  @instruction address =&gt; 0x00000010
	
add:
	add r2,r0,r1 @instruction address =&gt; 0x00000014
	mov pc,lr    @instruction address =&gt; 0x00000018<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="gei-pc-fu-zhi">给PC赋值</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124125452912.png" alt="image-20241124125452912"></p>
<p>B/BL指令有个限制：跳转的目标地址和当前PC中的指令地址之间的偏移量不能超过32M大小。如果超过了这个范围，我们可以直接赋值PC来实现跳转。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1 			
	mov r1,#2
	ldr pc,=add_label
back_label:
	mov r3,#10
	
stop:
	b stop

add_label:
	add r2,r0,r1
	ldr pc,=back_label
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中标签名字面量（<code>add_label</code>、<code>back_label</code>、<code>stop</code>）本质上就是给标签名冒号后的指令地址取了个别名，其值就是冒号后第一条指令的地址；且标签声明不属于指令，也就不占用内存空间，因此 <code>ldr pc,=add_label</code>等价于 <code>ldr pc,=0x00000014</code>：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1 			@0x00000000
	mov r1,#2			@0x00000004
	ldr pc,=add_label	@0x00000008
back_label:
	mov r3,#10			@0x0000000C
	
stop:
	b stop				@0x00000010

add_label:
	add r2,r0,r1 		@0x00000014
	ldr pc,=back_label	@0x00000018
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="lian-xi-2">练习</h4>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124131659348.png" alt="image-20241124131659348" style="zoom:50%;">
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0		@sum=0
	mov r1,#1		@i=1
loop:
	cmp r1,#100
	bgt stop		@stop loop if r1 &gt; 100
	add r0,r0,r1	@sum+=i
	add r1,r1,#1	@i++
	b loop			@continue loop
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="dan-ge-shu-ju-fang-wen-yi-ci-xing-fang-wen-yi-ge-zi-kuan-shu-ju">单个数据访问（一次性访问一个字宽数据）</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124132933599.png" alt="image-20241124132933599" style="zoom:50%;">
<h3 id="ji-cun-qi-jian-jie-xun-zhi">寄存器间接寻址</h3>
<p><mark>LDR &lt;目标寄存器&gt; [源寄存器]</mark>：从源寄存器指定的地址中加载数据到目标寄存器</p>
<p><mark>LDR &lt;源寄存器&gt; [目标寄存器]</mark>：将源寄存器中的数据存储到目标寄存器指定的内存地址中</p>
<p>如下代码将数据 <code>0x12345678</code> 写（存储）到内存地址 <code>0x40000000</code>中，并从改地址读（加载）数据到R2寄存器中</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000
	ldr r1,=0x12345678
	
	str r1,[r0]		@write 0x12345678 to memory address 0x40000000 =&gt; *r0 = r1
	ldr r2,[r0]		@read 0x12345678 from memory address 0x40000000 =&gt; r2 = *r0
	
	b stop
	
stop:
	b stop

	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>点击调试后，需要映射一下当前程序可访问的内存空间：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124143904811.png" alt="image-20241124143904811" style="zoom: 50%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124143956075.png" alt="image-20241124143956075" style="zoom:50%;">
<blockquote>
<p>0x40000000,0x4000FFFF</p>
</blockquote>
<p>然后可以打开内存查看窗口：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124144137121.png" alt="image-20241124144137121" style="zoom: 50%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124144919193.png" alt="image-20241124144919193" style="zoom: 33%;">
<p>然后步进到 <code>str r1,[r0]</code>执行之后，会发现数据已被写入对应的内存。这里值得注意的是，存储方式是字节小端法。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124145026768.png" alt="image-20241124145026768"></p>
<p>再进一步，数据从内存加载到了R2寄存器中</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124145228766.png" alt="image-20241124145228766" style="zoom:50%;">
<h3 id="ji-di-zhi-bian-zhi-xun-zhi">基地址变址寻址</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124150404357.png" alt="参考手册 A8.5 Memory accesses"></p>
<h4 id="pian-yi-liang-xun-zhi">偏移量寻址</h4>
<blockquote>
<p>Offset addressing<br>
The offset value is applied to an address obtained from the base register. The result is used as the<br>
address for the memory access. The value of the base register is unchanged.<br>
The assembly language syntax for this mode is:<br>
<code>[&lt;Rn&gt;, &lt;offset&gt;]</code></p>
</blockquote>
<p><code>LDR/STR [&lt;Rn&gt;, &lt;offset&gt;]</code>：Rn为基地址，offset为偏移字节数</p>
<p>类比理解：C语言中通过指针加偏移量来访问内存（<code>num = *(p+1)</code>），该操作不会改变指针的值。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000
	ldr r1,=0x12345678
	
	str r1,[r0, #4]		@ *(r0+4)=r1
	ldr r2,[r0, #4]		@ r2=*(r0+4)
	
	b stop
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>注意：每次点击debug后做一下内存映射：</mark></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124150820281.png" alt="image-20241124150820281" style="zoom: 50%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124150924297.png" alt="image-20241124150924297" style="zoom:33%;">
<h4 id="qian-suo-yin-xun-zhi">前索引寻址</h4>
<blockquote>
<p>Pre-indexed addressing<br>
The offset value is applied to an address obtained from the base register. The result is used as the<br>
address for the memory access, and written back into the base register.<br>
The assembly language syntax for this mode is:<br>
<code>[&lt;Rn&gt;, &lt;offset&gt;]!</code></p>
</blockquote>
<p><code>LDR/STR [&lt;Rn&gt;, &lt;offset&gt;]!</code>：Rn为基地址，offset为偏移字节数。</p>
<p>该指令在偏移量寻址的基础上加了个 <mark>!</mark>，标示在内存访问之后将访问的地址回写基地址Rn。</p>
<p>类比理解：<code>num = *p++ =&gt; num = *p; p++;</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000
	ldr r1,=0x12345678
	
	str r1,[r0, #4]!		@ *(r0+4)=r1 r0+=4
	ldr r2,[r0]		@ r2=*r0
	
	b stop
	
stop:
	b stop
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124152950125.png" alt="image-20241124152950125"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124153051739.png" alt="image-20241124153051739"></p>
<h4 id="hou-suo-yin-xun-zhi">后索引寻址</h4>
<blockquote>
<p>Post-indexed addressing<br>
The address obtained from the base register is used, unchanged, as the address for the memory<br>
access. The offset value is applied to the address, and written back into the base register<br>
The assembly language syntax for this mode is:<br>
<code>[&lt;Rn&gt;], &lt;offset&gt;</code></p>
</blockquote>
<p><code>LDR/STR [&lt;Rn&gt;], &lt;offset&gt;</code>：Rn为基地址，offset为偏移字节数。</p>
<p>该指令先从Rn访问内存，然后再将偏移量更新到Rn中。</p>
<p>类比理解：<code>num = *p; p += offset</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000
	ldr r1,=0x12345678
	
	str r1,[r0],#4	@ *(r0)=r1 r0+=4
	
	sub r0,r0,#4	@ r0-=4
	ldr r2,[r0]		@ r2=*r0
	
	b stop
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124153832192.png" alt="image-20241124153832192"></p>
<h4 id="zong-jie">🌟总结</h4>
<ul>
<li>偏移量寻址：就是在给定地址上加减一个偏移量来访问内存（relative）</li>
<li>前索引：先对给定地址增减偏移量进行更新，再访问更新后的地址</li>
<li>后索引：先访问给定地址，再对给定地址加减偏移量并更新</li>
</ul>
<h4 id="lian-xi-3">练习</h4>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124154157004.png" alt="image-20241124154157004"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#1 				@i=1
	mov r1,#0x40000000 		@p
	
	bl write_data
	
	mov r0,#1				@i=1
	mov r1,#0x40000000 		@p=&gt;0x40000000
	ldr r2,=0x40000100		@q=&gt;0x40000100
	mov r3,#0				@num=0

	bl read_data
	
stop:
	b stop
	
write_data:
	str r0,[r1],#4 			@*p++=i
	add r0,r0,#1			@i++
	cmp r0,#10
	ble write_data 			@while(i&lt;=10)
	
	mov pc,lr				@return
	
read_data:
	ldr r3,[r1],#4			@num=*p++
	str r3,[r2],#4			@*q++=num
	add r0,r0,#1			@i++
	cmp r0,#10
	ble read_data			@while(i&lt;=10)
	
	mov pc,lr				@return
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124160123984.png" alt="image-20241124160123984"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124160205062.png" alt="image-20241124160205062"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	ldr r0,=0x1234
	ldr r1,=0x40000000 		@p=0x40000000
	str r0,[r1],#4			@*p++=0x1234
	
	ldr r0,=0xabcd
	str r0,[r1],#-4			@*p=0xabcd, p-=4
	
	ldr r2,[r1],#4			@num1=*p++
	ldr r3,[r1]				@num2=*p
	add r0,r2,r3			@sum=num1+num2
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="duo-ge-shu-ju-fang-wen">多个数据访问</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124162052165.png" alt="image-20241124162052165" style="zoom:50%;">
<h3 id="zhi-ling-mo-shi">指令模式</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124162139880.png" alt="image-20241124162139880" style="zoom:50%;">
<p>以STM（Store Multiple，写多个数据为例，LDM是类似的）：</p>
<ul>
<li>STMIA：Increase After，先向基地址写入数据，然后递增基地址</li>
<li>STMIB：Increase Before，先递增基地址，再向基地址写入数据</li>
<li>STMDA：Decrease After，先向基地址写入数据，然后递减基地址</li>
<li>STMDB：Decrease Before，先递减基地址，再向基地址写入数据</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000			@p=0x40000000
	mov r1,#0x11				@buf[3] = {0x11,0x22,0x33}
	mov r2,#0x22
	mov r3,#0x33
	
	stmia r0!,{r1-r3} 			@*p++=buf[i]
	
stop:
	b stop
	
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124163643693.png" alt="image-20241124163643693"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x40000000			@p=0x40000000
	mov r1,#0x11				@buf[3] = {0x11,0x22,0x33}
	mov r2,#0x22
	mov r3,#0x33
	
	stmia r0!,{r1-r3} 			@*p++=buf[i++]
	
	ldmdb r0!,{r4-r6}			@buf2[i++]=*--p
	
stop:
	b stop
	
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124163945572.png" alt="image-20241124163945572"></p>
<h2 id="zhan-cao-zuo-zhi-ling">栈操作指令</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124164247925.png" alt="image-20241124164247925"></p>
<h3 id="zhan-zeng-chang-mo-shi">栈增长模式</h3>
<p><mark>自底向上：栈顶指针随着入栈而递增（地址）；自顶向下：栈顶指针随着入栈而递减</mark></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124164335289.png" alt="image-20241124164335289"></p>
<h3 id="kong-dui-zhan-he-man-dui-zhan">空堆栈和满堆栈</h3>
<p><mark>其实就是栈顶指针指向栈顶元素（满堆栈）还是指向下一个入栈元素要存放的位置（空堆栈）</mark></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124164412290.png" alt="image-20241124164412290"></p>
<h3 id="shi-li-ya-zhan-bao-cun-chu-zhan-hui-fu">示例：压栈保存，出栈恢复</h3>
<blockquote>
<p>在程序上下文发生切换时（例如函数调用、中断处理），我们通常需要先将先前程序执行状态相关的信息进行保存，然后在返回时进行恢复。</p>
</blockquote>
<p>如下程序以通用寄存器的暂存和恢复为例来模拟这一过程：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#0x11				
	mov r2,#0x22
	mov r3,#0x33
	
	@first: set stack pointer(start address of stack, from high address to low)
	ldr sp,=0x4000fff0		
	@push to save general purpose registers and decrease stack pointer
	stmfd sp!,{r1-r3}		
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124170153676.png" alt="image-20241124170153676"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r1,#0x11				
	mov r2,#0x22
	mov r3,#0x33
	
	@first: set stack pointer(start address of stack, from high address to low)
	ldr sp,=0x4000fff0		
	@push to save general purpose registers and decrease stack pointer
	stmfd sp!,{r1-r3}		
	
	@do something with general purpose registers
	mov r1,#0x00				
	mov r2,#0x00
	mov r3,#0x00
	
	@pop stack to recover general purpose registers
	ldmfd sp!,{r1-r3}
	
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124170518808.png" alt="image-20241124170518808"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124170639885.png" alt="image-20241124170639885"></p>
<h2 id="cpsr-spsr-cao-zuo-zhi-ling">CPSR/SPSR操作指令</h2>
<h3 id="mrs-move-to-register-from-special-register">MRS（Move to Register from Special register）</h3>
<blockquote>
<p>Move to Register from Special register moves the value from the CPSR or SPSR of the current mode into an ARM<br>
core register.<br>
An MRS that accesses the SPSR is UNPREDICTABLE if executed in User or System mode.<br>
An MRS that is executed in User mode and accesses the CPSR returns an UNKNOWN value for the<br>
CPSR.{E, A, I, F, M} fields.</p>
</blockquote>
<p><code>MRS{&lt;c&gt;}{&lt;q&gt;} &lt;Rd&gt;, &lt;spec_reg&gt;  </code></p>
<h3 id="msr-move-register-immediate-to-special-register">MSR（Move register/immediate to Special Register）</h3>
<blockquote>
<p>Move to Special register from ARM core register moves the value of an ARM core register to the CPSR or the SPSR of the current mode.</p>
</blockquote>
<p><code>MSR&lt;c&gt; &lt;spec_reg&gt;, #&lt;const&gt;  </code></p>
<p><code>MSR{&lt;c&gt;}{&lt;q&gt;} &lt;spec_reg&gt;, &lt;Rn&gt;  </code></p>
<h3 id="zong-jie-1">🌟总结</h3>
<p><mark>MRS、MSR分辨</mark>：</p>
<ul>
<li>R在前面，则操作数1为通用寄存器（要将CPSR读到Rd）；</li>
<li>S在前面，操作数为特殊寄存器（要将通用寄存器写到CPSR）</li>
</ul>
<h3 id="lian-xi-4">练习</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124171837704.png" alt="image-20241124171837704"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mrs r0,cpsr 		@move to r0 from cpsr
	mov r1,#1
	bic r0,r1,lsl #7	@bit clear bit7 of cpsr
	msr cpsr,r0			@write back to cpsr
	
	b stop
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124172405608.png" alt="image-20241124172405608"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mrs r0,cpsr 		@move to r0 from cpsr
	mov r1,#1
	bic r0,r1,lsl #7	@bit clear bit7 of cpsr
	msr cpsr,r0			@write back to cpsr
	
	mrs r0,cpsr
	orr r0,r1, lsl #7	@set bit7 of cpsr
	msr cpsr,r0			@write back to cpsr
	
	b stop
stop:
	b stop
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="the-end">The END</h1>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
        <tag>指令集</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM核学习（五）异常处理</title>
    <url>/2024/11/25/17360.html</url>
    <content><![CDATA[<h1 id="can-kao-zi-liao">参考资料</h1>
<p><a href="https://developer.arm.com/documentation/ddi0406/cd/?lang=en">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p>
<ul>
<li>B1.8 Exception handling</li>
</ul>
<p><a href="https://developer.arm.com/documentation/den0013/latest/">ARM® Cortex™-A Series Programmer’s Guide Version: 4.0</a></p>
<h1 id="yi-chang-jie-shao">异常介绍</h1>
<h2 id="shi-yao-shi-yi-chang">什么是异常</h2>
<p>异常是处理器核在执行程序指令的过程中突然遇到了异常的事情，这些事件包括<strong>硬件中断、指令执行错误、用户程序请求服务、内存访问异常、取指令异常</strong>等，几乎每种处理器都支持特定的异常处理，<mark>中断也是异常的一种</mark>。</p>
<h2 id="arm-de-yi-chang-yuan">ARM的异常源</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125214514494.png" alt="image-20241125214514494"></p>
<h2 id="fiq-jiao-irq-kuai-de-yuan-yin">FIQ较IRQ快的原因</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125214951043.png" alt="image-20241125214951043"></p>
<h1 id="arm-he-yi-chang-chu-li-guo-cheng">ARM核异常处理过程</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125215607973.png" alt="image-20241125215607973"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125214441652.png" alt="处理器工作模式切换"></p>
<h2 id="yi-chang-xiang-liang-biao">异常向量表</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125215846276.png" alt="image-20241125215846276"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125215810206.png" alt="image-20241125215810206"></p>
<blockquote>
<p>[!NOTE]</p>
<p>ARM核怎么知道异常向量表放在内存哪个地方呢？</p>
<ol>
<li>Cortex-A架构版本之前，是由协处理器（<a href="https://developer.arm.com/documentation/den0013/d/ARM-Processor-Modes-and-Registers/Registers/Coprocessor-15?lang=en">Coprocessor 15</a>） <code>CP15</code>的<code>C1</code>寄存器来决定的，且只能存放在 <code>0xFFFF0000</code>和<code>0x00000000</code>两者中的一个。</li>
<li>从Cortex-A架构版本开始，由协处理器 <code>CP15</code>的<code>c12</code>寄存器来决定，且不限制起始地址</li>
</ol>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125221405786.png" alt="Table B1-3 The vector tables"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125222433967.png" alt="image-20241125222433967"></p>
<blockquote>
<p><a href="https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities/Exception-mode-summary?lang=en">https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities/Exception-mode-summary?lang=en</a></p>
</blockquote>
<h2 id="cortex-a-chu-li-qi-yi-chang-xiang-liang-biao-ji-di-zhi-zhi-ding">Cortex-A处理器异常向量表基地址指定</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125223320833.png" alt="image-20241125223320833"></p>
<blockquote>
<p><a href="https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities?lang=en">https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities?lang=en</a></p>
</blockquote>
<blockquote>
<p>The first column in <a href="https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities?lang=en#CEGHDCAE">Table 11.1</a> gives the vector offset within the vector table associated with the particular type of exception. This is a table of instructions that the ARM core jumps to when an exception is raised. These instructions are located in a specific place in memory. The default vector base address is <code>0x00000000</code>, but most ARM cores permit the vector base address to be moved to <code>0xFFFF0000</code> (or <code>HIVECS</code>). <strong>All Cortex-A series processors permit this, and it is the default address selected by the Linux kernel. Cores that implement the Security Extensions can additionally set the vector base address, separately for Secure and Non-secure states, using the CP15 Vector Base Address registers.</strong></p>
<p><a href="https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities/The-Vector-table?lang=en">https://developer.arm.com/documentation/den0013/d/Exception-Handling/Exception-priorities/The-Vector-table?lang=en</a></p>
</blockquote>
<h3 id="cp-15-c-1">CP15 c1</h3>
<blockquote>
<p><a href="https://documentation-service.arm.com/static/602cf701083323480d479d18?token=">https://documentation-service.arm.com/static/602cf701083323480d479d18?token=</a></p>
</blockquote>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125225458216.png" alt="image-20241125225458216" style="zoom:50%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125225614769.png" alt="Table 4-52 SCTLR bit assignments (continued)  "></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125225701958.png" alt="image-20241125225701958"></p>
<h3 id="cp-15-c-12">CP15 c12</h3>
<blockquote>
<p><a href="https://developer.arm.com/documentation/ddi0406/cd/?lang=en">ARM Architecture Reference Manual ARMv7-A and ARMv7-R edition</a></p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125230347930.png" alt="image-20241125230347930"></p>
<blockquote>
<p>[!NOTE]</p>
<p>其中高位[31:5]是向量表的基地址，低位[4:0]是异常向量的偏移量（offset）</p>
</blockquote>
<h1 id="svc-swi-yi-chang-chu-li">SVC/SWI异常处理</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126170039244.png" alt="image-20241126170039244"></p>
<h2 id="zai-cao-zuo-xi-tong-zhong-de-yun-yong">在操作系统中的运用</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126170125829.png" alt="image-20241126170125829"></p>
<h2 id="an-li-dai-ma">案例代码</h2>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
    b reset
    b undefined_instruction
    b software_interrupt
    b prefetch_abort
    b data_abort
    b not_used
    b irq_interrupt
    b fiq_interrupt 
    
undefined_instruction:.word undefined_instruction
prefetch_abort:.word prefetch_abort
data_abort:.word data_abort
not_used:.word not_used
irq_interrupt:.word irq_interrupt
fiq_interrupt:.word fiq_interrupt

reset:
    mov r0,#1
    mov r1,#2
    mov r2,#3
    
    swi #8      @will save CPSR to SPSR and set CPSR(T,M), save PC to LR
    
    mov r3,#4
    mov r4,#5
	
software_interrupt:
    ldr sp,=0x4000fff0
    stmfd sp!,{r0-r12,lr}
    
    ldr r0,[lr,#-4]
    mov r1,#0xff
    bic r0,r0,r1,lsl #24
    
    ldmfd sp!,{r0-r12,pc}
    
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ding-yi-yi-chang-xiang-liang-biao">定义异常向量表</h3>
<p>这里我们将异常向量表放在代码段起始地址：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_start:
    b reset
    b undefined_instruction
    b software_interrupt
    b prefetch_abort
    b data_abort
    b not_used
    b irq_interrupt
    b fiq_interrupt <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>异常向量表的指令顺序和地址偏移需要遵循规范，当发生异常跳转时处理器会按照规范从异常向量表找到对应的指令来执行</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126174514822.png" alt="image-20241126174514822"></p>
<h3 id="cheng-xu-ru-kou-reset">程序入口reset</h3>
<p>第一条指令跳转到 <code>reset</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">reset:
    mov r0,#1
    mov r1,#2
    mov r2,#3
    
    swi #8      @will save CPSR to SPSR and set CPSR(T,M), save PC to LR
    
    mov r3,#4
    mov r4,#5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中我们在 <code>swi</code>软中断指令前后增加了一些寄存器操作来验证一些事情：</p>
<ul>
<li>中断返回后，中断前的寄存器应该保持原样</li>
<li>中断返回后，应该接着下一条指令继续执行</li>
</ul>
<h3 id="zhong-duan-tiao-zhuan-arm-he-zi-dong-zuo-de-shi-qing">中断跳转——ARM核自动做的事情</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126175353623.png" alt="image-20241126175353623" style="zoom:50%;">
<ul>
<li>将当前CPSR保存到异常状态下的SPSR中</li>
<li>对CPSR进行如下设置
<ul>
<li>进入ARM状态（对应CPSR的T位）</li>
<li>设置工作模式为相应的异常模式（M位）</li>
<li>禁止中断（设置I位和F位为1）</li>
</ul>
</li>
<li>将当前PC的值保存到LR，以便异常处理完后能够跳转回中断发生的地方继续执行</li>
<li>将当前PC设置到异常向量表的相应位置（由于我们执行的是 <code>swi</code>软中断，因此会根据异常向量表规范，将PC指向向量表的基地址偏移 <code>0x08</code>的位置）</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p>由于使用的是ARM9E-S的核，因此没有手动指定向量表基地址时，默认为 <code>0x00000000</code>。</p>
</blockquote>
<h3 id="zhong-duan-tiao-zhuan-cong-xiang-liang-biao-dao-zhong-duan-fu-wu-cheng-xu">中断跳转——从向量表到中断服务程序</h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_start:
    b reset
    b undefined_instruction
    b software_interrupt
    b prefetch_abort
    b data_abort
    b not_used
    b irq_interrupt
    b fiq_interrupt <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据向量表基地址及偏移量 <code>0x08</code>能够找到我们编写的 <code>b software_interrupt</code>，接着跳转到对应的中断服务程序：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">software_interrupt:
ldr sp,=0x4000fff0
stmfd sp!,{r0-r12,lr}

ldr r0,[lr,#-4]
mov r1,#0xff
bic r0,r0,r1,lsl #24

ldmfd sp!,{r0-r12,pc}^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>设置SP，将R0-12、LR压栈保护；</p>
</li>
<li>
<p>将LR偏移 <code>-4</code>的地址中的内容给到R0，由于LR是由ARM核中断跳转时设置的，因此我们回头看看中断跳转的地方：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126181400176.png" alt="image-20241126181400176"></p>
</li>
<li>
<p>接着将 <code>0xff</code>送入R1，并将R1左移24位后作为掩码将R0中的高8位清零，得到中断号 <code>#8</code></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126181736106.png" alt="image-20241126181736106"></p>
</li>
<li>
<p><code>ldmfd sp!,{r0-r12,pc}</code>，准备返回，出栈复原R0-R12，将LR（指向 <code>mov r3,#4</code>）送到PC，中断返回</p>
</li>
</ul>
<blockquote>
<p>[!IMPORTANT]</p>
<p>这里需要注意的是，<code>ldmfd sp!,{r0-r12,pc}^</code>中的 <code>^</code>，会将SPSR暂存的值写回CPSR</p>
</blockquote>
<h1 id="zong-jie">总结</h1>
<h2 id="yi-chang-chan-sheng-shi-arm-he-zi-dong-zuo-de-shi-qing">异常产生时，ARM核自动做的事情</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126190902985.png" alt="image-20241126190902985"></p>
<h2 id="yi-chang-sheng-cheng-zhi-qian-wo-men-xu-yao-zuo-de-shi-qing">异常生成之前，我们需要做的事情</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126192006040.png" alt="image-20241126192006040"></p>
<h2 id="yi-chang-fan-hui">异常返回</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126192130322.png" alt="image-20241126192130322"></p>
<blockquote>
<p>[!NOTE]</p>
<p><code>S</code>后缀表明在原有指令基础上，同时将SPSR恢复到C</p>
</blockquote>
<h1 id="the-end">The End</h1>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
        <tag>异常</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM核学习（四）ATPS标准_汇编与C混合编程_volatile关键字</title>
    <url>/2024/11/24/59994.html</url>
    <content><![CDATA[<h1 id="can-kao-zi-liao">参考资料</h1>
<p><a href="https://developer.arm.com/documentation/dui0041/latest/Thumb-Procedure-Call-Standard/About-the-Thumb-Procedure-Call-Standard">The ARM-THUMB Procedure Call Standard</a></p>
<h1 id="atpcs-biao-zhun">ATPCS标准</h1>
<h2 id="atpcs-biao-zhun-jie-shao">ATPCS标准介绍</h2>
<p>ATPCS是<mark>ARM-Thumb Procedure Call Standard</mark>的缩写，也就是<mark>ARM-Thumb的程序调用标准</mark>。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124210132131.png" alt="image-20241124210132131"></p>
<h2 id="ji-cun-qi-jiao-se">寄存器角色</h2>
<blockquote>
<p>The first four registers r0-r3 are used to pass parameter values into a routine and result values out of a routine and to hold intermediate values within a routine (but, in general, only between subroutine calls). In ARM-state, register r12— also called IP— can also be used to hold intermediate values between subroutine calls.</p>
</blockquote>
<p><mark>r0-r3</mark>通常用来传递函数参数、返回函数结果和保存函数执行过程中产生的中间变量（例如 <code>sum=a+b</code>需要先将 <code>a+b</code>的计算结果存到寄存器中再写到 <code>sum</code>对应的内存）。</p>
<p>在ARM状态下，<mark>r12，也称为IP</mark>寄存器也可以用来保存临时变量，尤其是当其他通用寄存器（r0-r11）已被使用时。</p>
<blockquote>
<p><code>r12</code> (IP) is a <strong>general-purpose register</strong>, not reserved for any specific use in standard ARM programming.</p>
<p>The <strong>ARM Procedure Call Standard (AAPCS)</strong> defines it as a <strong>scratch register</strong>. This means:</p>
<ul>
<li>The <strong>caller</strong> can use it freely to store temporary values.</li>
<li>The <strong>callee</strong> (the function being called) does not preserve its value. If <code>r12</code> is used by the caller before calling another function, its value will be lost unless explicitly saved.</li>
</ul>
</blockquote>
<blockquote>
<p>Typically, the registers from r4 to r11 are used to hold the values of a routine’s local variables. They are also labeled v1-v8. Only v1-v4 can be used uniformly by the whole Thumb instruction set (shown emboldened).</p>
</blockquote>
<p>一般地，<mark>r4-r11</mark>用来保存函数的局部变量，他们被标记为v1-v8。Thumb指令集只能使用v1-v4。</p>
<blockquote>
<p>In all variants of the procedure call standard, registers r12-r15 have special roles. In these roles they are labeled IP, SP, LR and PC (or ip, sp, lr, and pc, but this standard uses the upper case name for the special role)</p>
</blockquote>
<p><mark>r12-r15</mark>有着特殊的角色，例如IP（临时保存SP），SP（指向栈顶），LR（跳转时用来保存PC）、PC，并且使用大写来标示他们的特殊角色。</p>
<blockquote>
<p>In some variants of the procedure call standard, r9 and r10 also have a special role. In these roles, r9 is labeled SB and r10 is labeled SL (or sb and sl).<br>
Only registers r0-r7, SP, LR and PC are ubiquitously available in Thumb state. Their synonyms and special names are shown emboldened. Few Thumb instructions can access the high registers, v5-v8, SB, SL and IP.<br>
In Thumb-state, r7 is often used as a work register and is also labeled WR</p>
</blockquote>
<h2 id="can-shu-chuan-di">参数传递</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124212508273.png" alt="image-20241124212508273"></p>
<p><mark>在定义函数时，参数数量尽量不要超过4个，这样效率较好</mark></p>
<h2 id="han-shu-fan-hui-zhi">函数返回值</h2>
<ul>
<li>返回值为一个32位的整数时，可以通过寄存器0返回</li>
<li>返回值为一个64位整数时，可以通过R0和R1返回，依此类推</li>
</ul>
<h2 id="zhan-zheng-fen-xi">栈帧分析</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124213834303.png" alt="image-20241124213834303" style="zoom:50%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124213931226.png" alt="image-20241124213931226"></p>
<h1 id="fan-hui-bian-fen-xi-atpcs-biao-zhun">反汇编分析ATPCS标准</h1>
<h2 id="zhun-bei-hui-bian-he-c-wen-jian">准备汇编和C文件</h2>
<p>准备一个汇编启动文件和一个C文件：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125151255393.png" alt="image-20241125151255393"></p>
<p>在 <code>asm.s</code>中，在调用 <code>main_label</code>函数之前，我们操作了下R0-R2，并设置了SP，模拟在调用函数前做了一些操作</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x11			
	mov r1,#0x22
    mov r2,#0x33
    mov sp,#0x00002000
	bl main_label	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main_label</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	b <span class="token operator">=</span> i<span class="token operator">++</span> <span class="token operator">+</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="jin-yong-bian-yi-you-hua">禁用编译优化</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125151330962.png" alt="image-20241125151330962" style="zoom: 50%;">
<h2 id="diao-shi-fen-xi-amp-nei-cun-ying-she">调试分析&amp;内存映射</h2>
<p>在点击debug后，步进之前，我们先添加一下内存映射 <code>0x00001000,0x00002000</code>，因为在 <code>asm.s</code>中我们有设置过SP <code>mov sp,#0x00002000</code>（<mark>注意每次点击debug后都需要手动映射下</mark>）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125102205035.png" alt="image-20241125102205035"></p>
<p>接着我们步进，在调用 <code>main_label</code>函数之前，对R0-R2，SP(R13)有所使用（模拟函数调用前操作过相关的寄存器）：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125104048265.png" alt="image-20241125104048265"></p>
<p>寄存器状态示例：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132148176.png" alt="image-20241125132148176" style="zoom:50%;">
<h2 id="han-shu-diao-yong-fen-xi">函数调用分析</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125115716832.png" alt="image-20241125115716832"></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241124213834303.png" alt="image-20241124213834303" style="zoom:50%;">
<p>参照ATPCS标准，我们接着分析 <code>main_label</code>函数的执行。</p>
<h3 id="jiang-sp-zan-cun-dao-ip">将SP暂存到IP</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125104614719.png" alt="image-20241125104614719"></p>
<p>首先将<code>R13(SP)</code>送到了<code>R12(IP)</code>进行保存（这里可以看出<code>IP</code>的临时保存作用，将函数调用前的SP栈顶指针暂存起来以便后续恢复）：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132222836.png" alt="image-20241125132222836"></p>
<p>接着我们看下一条指令的执行：</p>
<p>压栈PC,LR,IP,FP</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125105604588.png" alt="image-20241125105604588"></p>
<p>将<code>R11(FP)、R12(IP)、R14(LR)、PC(R15)</code>通过 <code>STMDB</code>指令进行压栈（参考另一篇文章《ARM核学习（二）指令集》），值得注意的是：</p>
<ul>
<li>ATPCS标准规定使用<mark>满减栈模式</mark>（从高地址向低地址增长，栈顶指针SP指向最后一个入栈的数据地址）</li>
<li><code>STM</code>：多数据传输指令，同时将多个数据进行压栈</li>
<li><code>DB</code>： <mark>Decrease&nbsp;Before</mark>（先递减SP然后压栈数据），这里压栈4个寄存器（字宽4字节），所以SP会递减4*4=16</li>
<li>同时压栈多个寄存器时，序号（Rn中的n）大的寄存器对应栈的高地址，序号小的则对应低地址</li>
</ul>
<p>寄存器状态示意图：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132238290.png" alt="image-20241125132238290" style="zoom:50%;">
<h3 id="she-zhi-zhan-ji-zhi-fp-zhan-di-shu-ju-de-di-zhi">设置栈基址FP（栈底数据的地址）</h3>
<p>将R12(IP，之前保存了SP，即调用方caller的SP)，通过 <code>SUB</code>指令减4，赋值给R11（FP，栈基值，被调方callee即 <code>main_label</code>函数的栈的起始地址）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125115123312.png" alt="image-20241125115123312"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125120006973.png" alt="image-20241125120006973"></p>
<p>寄存器示意图:</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132458366.png" alt="image-20241125132458366"></p>
<blockquote>
<p>caller表示调用方，callee表示被调方</p>
</blockquote>
<h3 id="zeng-jia-sp-kuo-da-zhan-kong-jian">增加SP，扩大栈空间</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125121914111.png" alt="image-20241125121914111"></p>
<p>接着通过 <code>SUB</code>指令，将SP(R13)减去 <code>0x00000010</code>（即16字节，4个字），相当于将SP下移了四个存储单元</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125132531947.png" alt="image-20241125132531947"></p>
<p>这样就相当于在栈中空出四个存储单元，为什么要这样做呢，我们接着往下看</p>
<h3 id="han-shu-ru-can-ya-zhan">函数入参压栈</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125131249986.png" alt="image-20241125131249986"></p>
<p>这里将R0写到R11（FP，栈基址）向下偏移 <code>0x0018</code>（即24字节，六个字）对应的存储单元中：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125133004294.png" alt="image-20241125133004294"></p>
<p>同样的，将R1写到FP向下偏移 <code>0x001C</code>（28个字节，7个字）的存储单元中：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125134213403.png" alt="image-20241125134213403"></p>
<p>根据ATPCS标准的规范，<code>r0</code>通常用来传递第一个参数<code>a1</code>，<code>r1</code>通常用来传递第二个参数<code>a2</code>，因此上述操作起始就是将函数的两个入参 <code>main_label(int argc, const char *argv[])</code> 压栈</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125131207660.png" alt="image-20241125131207660" style="zoom:33%;">
<h3 id="han-shu-ju-bu-bian-liang-ya-zhan">函数局部变量压栈</h3>
<p>对应 <code>int i = 0</code></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125133712296.png" alt="image-20241125133712296"></p>
<p>先将常量 <code>0</code>传输到寄存器R3中（这里R3作为通用寄存器存放临时的常量），再通过 <code>STR</code>指令压栈：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125134430454.png" alt="image-20241125134430454"></p>
<p>同样的，将局部变量 <code>b</code>压栈：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125134728492.png" alt="image-20241125134728492"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125134805022.png" alt="image-20241125134805022"></p>
<h3 id="ji-yu-zhan-he-ji-cun-qi-zuo-yun-suan">基于栈和寄存器做运算</h3>
<p>接着就到了 <code>b = i++ + ++i;</code>这一行代码的执行，它的过程是这样的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">++</span>i<span class="token punctuation">;</span>
b <span class="token operator">=</span> i <span class="token operator">+</span> i<span class="token punctuation">;</span>
i<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125135029185.png" alt="image-20241125135029185"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125135429854.png" alt="image-20241125135429854"></p>
<p>接着分析，我们会发现处理器的行为与我们在C语言的预期步骤是有出入的，这可能是因为指令重排序的原因，<mark>但无论怎样重排序，其结果与C语言的预期步骤得出的结果要保持一致。</mark></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125141616740.png" alt="image-20241125141616740"></p>
<h3 id="diao-yong-zi-han-shu-zi-guo-cheng-subroutine">调用子函数/子过程（subroutine）</h3>
<p>这与我们从汇编开始调用 <code>main_label</code>的分析思路是一样的，这里不在赘述。</p>
<h3 id="han-shu-fan-hui">函数返回</h3>
<p>接下来我们看一看 <code>main_label</code>函数的最后一行 <code>return 0;</code>都做了什么：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125144155014.png" alt="image-20241125144155014"></p>
<p>首先将常量 <code>0</code>（返回值）传输到R3进行临时保存；然后根据ATPCS标准，应该将返回值通过R0来传递，因此又将R3传输到了R0</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125144454192.png" alt="image-20241125144454192" style="zoom:33%;">
<p>接着通过 <code>SUB</code>，将R13(SP)指向R11(FP)向下偏移<code>0xC</code>的位置。如下图，SP指向这个位置后，相当于将函数参数和局部变量出栈释放了（对应图中灰色部分）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125144022274.png" alt="image-20241125144022274"></p>
<p>接着通过 <code>LDMIA</code>将还保存在栈中的调用方的<code>LR, SP, FP</code>恢复到<code>R14, R13, R11</code>中</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125145835783.png" alt="image-20241125145835783"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125145806719.png" alt="image-20241125145806719"></p>
<p>接着通过 <code>BX</code>指令根据LR(R14)跳转回调用方：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125150802906.png" alt="image-20241125150802906"></p>
<blockquote>
<p>为什么通过LR可以跳转回去呢？</p>
</blockquote>
<p>这是因为我们是通过 <code>bl main_label</code>跳转的，<code>l</code>后缀会将当前PC暂存到LR中，因此可以通过 <code>BX R14</code>跳转回去。</p>
<h1 id="hui-bian-yu-c-hun-he-bian-cheng">汇编与C混合编程</h1>
<h2 id="hui-bian-yu-yan-diao-yong-c-yu-yan">汇编语言调用C语言</h2>
<h3 id="zai-kan-c-yu-yan-cheng-xu-ru-kou">再看C语言程序入口</h3>
<blockquote>
<p>C语言程序的入口是main函数吗？</p>
</blockquote>
<p>经过上文的分析，我们知道C语言函数的执行过程是依赖栈的，在函数代码真正执行前需要将调用方程序状态相关的寄存器压栈保护（例如 <code>LR, SP, FP</code>）、函数参数压栈，如果有局部变量则也需要压栈，执行过程中的运算是基于栈和寄存器的配合来完成的。</p>
<p>因此每个函数的在执行前都需要设置栈的起始地址（SP），<code>main</code>当然也不例外，而这需要借助汇编来完成。</p>
<h3 id="mei-you-she-zhi-sp-han-shu-wu-fa-zheng-chang-zhi-xing">没有设置SP，函数无法正常执行</h3>
<p>让我们来看下如下程序：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125154604074.png" alt="image-20241125154604074"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x2			
	mov r1,#0x3
	bl add	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">int add(int a, int b) {
    return a + b;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>调试前需要先禁用编译器优化并重新编译：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125154632764.png" alt="image-20241125154632764" style="zoom:33%;">
<p>调试时会发现，函数执行前的压栈导致SP变成了<code>0xFFFFFFF0</code>，并且接着步进，程序无法按照预期结束。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125155225192.png" alt="image-20241125155225192"></p>
<p>这是因为调用函数时没有设置SP，SP默认为零值：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125155435833.png" alt="image-20241125155435833"></p>
<h3 id="han-shu-diao-yong-qian-xu-yao-zheng-que-she-zhi-sp">函数调用前需要正确设置SP</h3>
<p>于是我们在函数调用前，设置一下栈指针SP，并将相应的内存范围映射一下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x2			
	mov r1,#0x3
    ldr sp,=0x4000FFF0
	bl add	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>注意，这里要将SP设置为4的整数倍</mark></p>
<p><code>0x40000000,0x4000FFFF</code></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125160139087.png" alt="image-20241125160139087" style="zoom: 50%;">
<p>调整后发现可以正常执行到 <code>stop</code>，并且函数返回值 <code>2+3=5</code>也通过R0传递了过来</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125164223712.png" alt="image-20241125164223712"></p>
<p>我们还可以打开函数调用栈窗口来更直观地观察入参压栈的过程：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125164542704.png" alt="image-20241125164542704" style="zoom: 50%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125165001604.png" alt="image-20241125165001604"></p>
<h2 id="c-yu-yan-nei-qian-hui-bian">C语言内嵌汇编</h2>
<h3 id="ge-shi">格式</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125165243027.png" alt="image-20241125165243027" style="zoom: 50%;">
<h3 id="shi-li">示例</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125172126182.png" alt="image-20241125172126182"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
	mov r0,#0x2			
	mov r1,#0x3
    ldr sp,=0x4000FFF0
	bl add	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>
    
    <span class="token keyword">asm</span><span class="token punctuation">(</span>
        <span class="token string">"add r0,%1,%2\n"</span>
        <span class="token string">"mov %0,r0\n"</span>
        <span class="token operator">:</span><span class="token string">"=r"</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        <span class="token operator">:</span><span class="token string">"r"</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
        <span class="token operator">:</span><span class="token string">"r0"</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意：可以通过%n引用输入列表、输出列表中的寄存器，从输出列表开始编号，输出列表的编号接着输入列表的最后一个</p>
</blockquote>
<ul>
<li>
<p>通过 <code>asm</code>关键字内嵌一段汇编代码</p>
</li>
<li>
<p><code>:"r"(a), "r"(b)</code>：<mark>输入列表</mark>，声明将C程序中哪些变量输入到内嵌汇编的通用寄存器中（具体哪个寄存器是无法预知的，可以通过 <code>%</code>进行引用）。<mark>如果没有输入，则留一个空的冒号即可，但不能去掉该行。</mark></p>
</li>
<li>
<p><code>"add r0,%1,%2\n"</code>：<mark>汇编指令</mark>，通过 <code>%1</code>、<code>%2</code>引用输入列表的中的变量 <code>a</code>、<code>b</code>对应的寄存器，并通过 <code>add</code>指令将这两个寄存器相加，结果存入 <code>r0</code>；<mark>注意，换行是不可省略的，标示这条指令结束</mark></p>
</li>
<li>
<p><code>:"=r"(c)</code>：<mark>输出列表</mark>，声明将C程序的哪些变量的值由内嵌汇编输出。<code>=</code>标示了该汇编结束时需要将寄存器写入变量中。</p>
</li>
<li>
<p><code>"mov %0,r0\n"</code>：<mark>汇编指令</mark>，将 <code>r0</code>中的值输入到 <code>%0</code>引用的寄存器中，由于引用编号是从输出列表开始的，因此引用的就是变量 <code>c</code>关联的寄存器</p>
</li>
</ul>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125165906124.png" alt="image-20241125165906124"></p>
<p>调试前别忘了映射下内存 <code>0x40000000,0x4000FFFF</code></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125174751017.png" alt="image-20241125174751017"></p>
<h1 id="volatile-guan-jian-zi">volatile关键字</h1>
<h2 id="gcc-bian-yi-you-hua">gcc编译优化</h2>
<h3 id="shi-li-cheng-xu">示例程序</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125181741845.png" alt="image-20241125181741845"></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.global _start

_start:
    ldr sp,=0x4000FFF0
	bl add	
	
stop:
	b stop				
	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> global_a <span class="token operator">=</span> <span class="token number">0x3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> global_b <span class="token operator">=</span> <span class="token number">0x4</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> global_a <span class="token operator">+</span> global_b<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>global_a <span class="token operator">&gt;</span> global_b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="kai-qi-bian-yi-qi-you-hua">开启编译器优化</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125181830904.png" alt="image-20241125181830904" style="zoom: 50%;">
<h3 id="you-hua-hou-de-hui-bian-zhi-ling-fen-xi">优化后的汇编指令分析</h3>
<p>内存映射：<code>0x40000000,0x4000FFFF</code></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125181717824.png" alt="image-20241125181717824"></p>
<p>可以发现在执行 <code>int c = global_a + global_b;</code>时从内存读取 <code>global_a</code>和 <code>global_b</code>的值到<code>R2, R3</code>中；但是执行 <code>if(global_a &gt; global_b)</code>，并没重新从内存读取 <code>global_a</code>和 <code>global_b</code>的值，而是使用了此前<code>R2, R3</code>的快照。</p>
<h3 id="bian-yi-qi-you-hua-si-xiang-ji-bi-duan">编译器优化思想及弊端</h3>
<blockquote>
<p>[!NOTE]</p>
<p>根据另一篇文章《ARM核学习（三）指令流水线分析及伪指令》的分析，这是因为内存访问操作较低，无法发挥指令流水线的最佳性能，因此编译器优化会使用寄存器快照代替内存访问</p>
</blockquote>
<p>那么在<mark>并发场景</mark>下，如果在执行 <code>if(global_a &gt; global_b)</code>时发生了上下文切换，并且全局变量 <code>global_a</code>和 <code>global_b</code>的值被修改，那么 <code>R2, R3</code>中的值就不是最新的，因而会产生并发问题。</p>
<h2 id="volatile-guan-jian-zi-de-zuo-yong">volatile关键字的作用</h2>
<blockquote>
<p>[!TIP]</p>
<p><code>volatile</code>关键字的语意是易变的，被该关键字修饰的变量在读写时能够禁止编译器优化，从而使得每次读 <code>volatile</code>变量强制从内存读取最新值（在CPU Cache模型中每次写 <code>volatile</code>变量 也会立即将寄存器中的值刷新到内存）</p>
</blockquote>
<p>下面我们给 <code>global_a</code>和 <code>global_b</code>加上 <code>volatile</code>修饰后再来调试下：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241125184042361.png" alt="image-20241125184042361"></p>
<p>可以发现 <code>if(global_a &gt; global_b)</code>时，通过 <code>LDR</code>指令，强制从内存读值了。</p>
<h1 id="the-end">The End</h1>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>ARMv7</tag>
        <tag>ATPS</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32系统时钟初始化源码解析（SPL库，STM32F103ZE）</title>
    <url>/2024/11/23/19447.html</url>
    <content><![CDATA[<h1 id="yi-bei-jing">一、背景</h1>
<h2 id="kai-fa-huan-jing">开发环境</h2>
<ul>
<li>STM32F103ZET6</li>
</ul>
<h2 id="yuan-li-tu">原理图</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123160212385.png" alt="image-20241123160212385"></p>
<h3 id="hse-gao-su-wai-bu-jing-zhen-high-speed-external-oscillator">HSE-高速外部晶振High Speed External oscillator</h3>
<p>通过23、24号引脚接入8M的高速外部晶振。</p>
<h3 id="hsi-di-su-wai-bu-jing-zhen-low-speed-external-oscillator">HSI-低速外部晶振Low Speed External oscillator</h3>
<p>通过GPIO引脚PC14和PC15的复用接入32.768kHz低速外部晶振。</p>
<h2 id="yi-cube-de-tu-xing-hua-pei-zhi-wei-li-shuo-ming">以Cube的图形化配置为例说明</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123160112667.png" alt="image-20241123160112667"></p>
<p>MCU内置了两个RC震荡电路：</p>
<ul>
<li>HSI RC，High Speed Internal RC，8M高速内部RC震荡电路</li>
<li>LSI RC，Low Speed Internal RC，40kHz低速内部RC震荡电路</li>
</ul>
<h3 id="wei-shi-yao-mcu-nei-zhi-liao-huan-xu-yao-wai-jie-jing-zhen">为什么MCU内置了，还需要外接晶振</h3>
<ul>
<li>
<p>RC震荡电路容易受到其他电路干扰，导致信号不稳定，且精度远比晶振低。</p>
</li>
<li>
<p>由于MCU的微小封装，无法内嵌较大的晶振</p>
</li>
<li>
<p>将晶振的灵活选择权交给开发者</p>
</li>
</ul>
<h3 id="cube-pei-zhi-jie-xi">Cube配置解析</h3>
<p>外接晶振通过引脚接入MCU，但由于MCU的主频较高，一般将HSE通过PLL（锁相环，用来倍频）提高频率再作为系统时钟SYSCLK的来源。</p>
<p>图中 <mark>Mux</mark>是多路选择器 <mark>Multiplex</mark>的缩写，可以看到我们的8M HSE经过了1分频（即不分频），连接到了PLL Source Mux，通过这个多路选择器，我们使用HSE而不是HSI作为PLL的时钟来源（HSE在精度和稳定性上要比HSI好很多）。</p>
<p>接着经过了PLLMul，即锁相环倍频（PLL Multiply），将HSE的频率放大了9倍得到PLLCLK（8M * 9 = 72M），并连接到了System Clock Mux（即系统时钟多路选择器），这里我们当然选择稳定、高精度、高频的PLLCLK作为系统时钟。</p>
<h1 id="er-shi-zhong-chu-shi-hua-guo-cheng-yuan-ma-fen-xi-spl-ku">二、时钟初始化过程源码分析（SPL库）</h1>
<h2 id="shang-dian-fu-wei-hou-hui-fa-sheng-shi-yao">上电/复位后会发生什么？</h2>
<p>MCU启动的汇编文件 <code>startup.s</code>会被执行：</p>
<p><code>startup_stm32f10x_hd.s</code></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">Reset_Handler   PROC
                EXPORT  Reset_Handler             [WEAK]
                IMPORT  __main
                IMPORT  SystemInit
                LDR     R0, =SystemInit
                BLX     R0               
                LDR     R0, =__main
                BX      R0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>执行SystemInit函数</mark></p>
<p>将 <code>SystemInit</code> 函数的入口地址加载到寄存器R0，通过 <code>BLX</code>跳转到其对应的代码段执行该函数，其中就包括了系统时钟的初始化过程。</p>
<p><mark>执行main函数</mark></p>
<p>将 <code>main</code> 函数的入口地址加载到寄存器R0，通过 <code>BX</code>跳转到其对应的代码段执行该函数，执行用户代码。</p>
<blockquote>
<p>该初始化顺序遵循ARM的CMSIS（Cortex Microcontroller Software Interface Standard）标准</p>
</blockquote>
<h2 id="system-init">SystemInit</h2>
<p><a href="https://www.st.com/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32F107参考手册</a></p>
<h3 id="qi-yong-hsi-xian-rang-mcu-you-xin-tiao">启用HSI，先让MCU有心跳</h3>
<p>在<code>system_stm32f10x.c</code>中找到 <code>SystemInit</code>函数，条件编译显示灰色的部分可以忽略</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Set HSION bit */</span>
RCC<span class="token operator">-&gt;</span>CR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0x00000001</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>先开启HSI高速内部时钟（时钟相当于MCU心跳，先让MCU有心跳能够工作，后面再将时钟源通过多路选择器切换为我们配置的HSE），将寄存器的第0位设置为1：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123165840693.png" alt="image-20241123165840693"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123165911410.png" alt="image-20241123165911410"></p>
<h3 id="fu-wei-shi-zhong-xiang-guan-ji-cun-qi-bi-te-wei">复位时钟相关寄存器比特位</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xF8FF0000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>该操作会将CFGR（时钟配置）寄存器如下比特位清零：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123170556835.png" alt="image-20241123170556835"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123170704055.png" alt="image-20241123170704055"></p>
<p>选择HSI（上一步已经开启了）作为系统时钟，其他的（HPRE, PPRE1, PPRE2, ADCPRE and MCO）分析过程类似。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Reset HSEON, CSSON and PLLON bits */</span>
RCC<span class="token operator">-&gt;</span>CR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFEF6FFFF</span><span class="token punctuation">;</span>

<span class="token comment">/* Reset HSEBYP bit */</span>
RCC<span class="token operator">-&gt;</span>CR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFFFBFFFF</span><span class="token punctuation">;</span>

<span class="token comment">/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xFF80FFFF</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样的，也是将一些位清零，将系统时钟初始化为仅由HSI作为时钟源的初始状态</p>
<h3 id="set-sys-clock-she-zhi-xi-tong-shi-zhong">SetSysClock设置系统时钟</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Enable HSE */</span>    
RCC<span class="token operator">-&gt;</span>CR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CR_HSEON<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">/* Wait till HSE is ready and if Time out is reached exit */</span>
<span class="token keyword">do</span>
<span class="token punctuation">{</span>
  HSEStatus <span class="token operator">=</span> RCC<span class="token operator">-&gt;</span>CR <span class="token operator">&amp;</span> RCC_CR_HSERDY<span class="token punctuation">;</span>
  StartUpCounter<span class="token operator">++</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>HSEStatus <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>StartUpCounter <span class="token operator">!=</span> HSE_STARTUP_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里开启了HSE外部高速时钟，并等待HSE的状态转变为READY（由硬件置位）。</p>
<h3 id="xi-tong-shi-zhong-shu">系统时钟树</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* HCLK = SYSCLK */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_HPRE_DIV1<span class="token punctuation">;</span>
  
<span class="token comment">/* PCLK2 = HCLK */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_PPRE2_DIV1<span class="token punctuation">;</span>

<span class="token comment">/* PCLK1 = HCLK */</span>
RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_PPRE1_DIV2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将系统时钟作为AHB和APB2的时钟源（对应HCLK和PCLK2），将系统时钟2分频，作为APB1的时钟源（对应PCLK2）。</p>
<blockquote>
<p>AHB挂载了Cortex核、DMA等主动单元</p>
<p>APB2挂载了GPIO、USRAT1、ADC等需要高速率时钟的单元</p>
<p>APB1则挂载了TIMER、I2C等不需要那么高频的单元</p>
</blockquote>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241123172121666.png" alt="image-20241123172121666" style="zoom: 50%;">
<h3 id="pll-bei-pin">PLL倍频</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */</span>
    RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token operator">~</span><span class="token punctuation">(</span>RCC_CFGR_PLLSRC <span class="token operator">|</span> RCC_CFGR_PLLXTPRE <span class="token operator">|</span>
                                        RCC_CFGR_PLLMULL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>RCC_CFGR_PLLSRC_HSE <span class="token operator">|</span> RCC_CFGR_PLLMULL9<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>将PLL时钟来源RCC_CFGR_PLLSRC、HSE进入PLL后的分频RCC_CFGR_PLLXTPRE、PLL倍频系数RCC_CFGR_PLLMULL清零；</li>
<li>选择PLL时钟来源为HSE（RCC_CFGR_PLLSRC_HSE），倍频系数为9（RCC_CFGR_PLLMULL9）</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Enable PLL */</span>
    RCC<span class="token operator">-&gt;</span>CR <span class="token operator">|=</span> RCC_CR_PLLON<span class="token punctuation">;</span>

    <span class="token comment">/* Wait till PLL is ready */</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>RCC<span class="token operator">-&gt;</span>CR <span class="token operator">&amp;</span> RCC_CR_PLLRDY<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动PLL锁相环，并等待它稳定。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Select PLL as system clock source */</span>
   RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token operator">~</span><span class="token punctuation">(</span>RCC_CFGR_SW<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_SW_PLL<span class="token punctuation">;</span>    

   <span class="token comment">/* Wait till PLL is used as system clock source */</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>RCC<span class="token operator">-&gt;</span>CFGR <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>RCC_CFGR_SWS<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0x08</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过系统时钟的多路选择器将PLL选择为系统时钟源，并等待此切换完成。</p>
]]></content>
      <categories>
        <category>STM32</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>SPL</tag>
        <tag>STM32F103ZE</tag>
        <tag>时钟</tag>
      </tags>
  </entry>
  <entry>
    <title>MDK调试之可视化外设&amp;内核寄存器</title>
    <url>/2024/11/30/5535.html</url>
    <content><![CDATA[<h1 id="qian-yan">前言</h1>
<p>我们经常遇到一个困惑：明明感觉代码没有问题，但是运行时就是无法按照预期执行。并且把别人的示例拿过来跑是可以跑通的，确认了硬件没问题，比对代码也找不出差异。</p>
<p>这通常是因为一些细节问题导致的，这类问题在逐检查时常常因为当局者迷难以发现，最常见的就是位运算相关的细节错误例如：</p>
<ul>
<li>
<p>清零错误：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> GPIO_CRH_MODE10<span class="token punctuation">;</span> <span class="token comment">//期望将GPIOA的CRH寄存器中的PA10工作模式清零</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述代码少了 <code>~</code>，正确操作如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_MODE10<span class="token punctuation">;</span> <span class="token comment">//期望将GPIOA的CRH寄存器中的PA10工作模式清零</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>判断某一位是否为1：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    buffer<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过按位与来判断某一位是否为1应该操作如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    buffer<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h1 id="mdk-wai-she-ji-cun-qi-shi-tu">MDK外设寄存器视图</h1>
<p>通过MDK的Debug功能，我们实时查看代码执行到断电时，对应的外设寄存器中的值，从而可视化地分析响应的寄存器是否真的按照预期被设置了，从而避免检查代码时无法察觉细节错误的情况。</p>
<p>以 <code>GPIOA-&gt;CRH &amp;= GPIO_CRH_MODE10</code>为例，我们期望通过这一行代码将 <code>CRH</code>寄存器的第8、9个bit清零</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130112416568.png" alt="image-20241130112416568"></p>
<h2 id="she-zhi-duan-dian">设置断点</h2>
<p>可以在该行代码的左侧点击打上断点：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130112531806.png" alt="image-20241130112531806"></p>
<h2 id="fang-xing-cheng-xu-dao-duan-dian-chu-zan-ting">放行程序到断点处暂停</h2>
<p>然后进入Debug模式并通过Run使程序停在断点处：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130112707073.png" alt="image-20241130112707073"></p>
<h2 id="da-kai-wai-she-xi-tong-shi-tu">打开外设系统视图</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130112746427.png" alt="image-20241130112746427"></p>
<h2 id="zhao-dao-dui-ying-ji-cun-qi">找到对应寄存器</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130112926649.png" alt="image-20241130112926649" style="zoom:50%;">
<h2 id="bu-jin-bing-cha-kan-dui-ying-ji-cun-qi-shi-fou-an-zhao-yu-qi-bei-she-zhi">步进并查看对应寄存器是否按照预期被设置</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130113658038.png" alt="image-20241130113658038"></p>
<p>步进后发现本来预期只设置MODE10，结果发现其他的bit位也被影响了（高亮部分），说明我们的代码有问题</p>
<h1 id="zhi-jie-xiu-gai-ji-cun-qi-bing-sheng-xiao">直接修改寄存器并生效</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130115225062.png" alt="image-20241130115225062"></p>
<p>如上，我们可以通过勾选/取消勾选（相当于ODR置1/0），并实时观察LED的变化。其他寄存器中可编辑的地方应该也都是可以实时手动修改的。</p>
<h1 id="arm-he-xiang-guan-ji-cun-qi">ARM核相关寄存器</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130115446304.png" alt="image-20241130115446304"></p>
]]></content>
      <categories>
        <category>MDK</category>
      </categories>
      <tags>
        <tag>MDK</tag>
        <tag>Debug</tag>
        <tag>寄存器可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>UART接收缓冲区溢出异常（HAL_UART_ERROR_ORE）问题记录</title>
    <url>/2024/11/12/13750.html</url>
    <content><![CDATA[<h1 id="wen-ti-bei-jing">问题背景</h1>
<h2 id="kai-fa-huan-jing">开发环境</h2>
<ul>
<li>硬件：GD32F407VET6开发版</li>
<li>IDE：STM32CubeMX + Clion + ARM GNU</li>
<li>烧录：OpenOCD</li>
</ul>
<h2 id="shi-yan-mu-biao">实验目标</h2>
<p>使用Cube配置串口USART1及其中断，引脚复用PA9/PA10，通过使能接收中断 <code>Receive_IT</code>，实现接收7字节时，在中断回调中处理该7个字节数据（简单回传，即echo），并再次开启接收中断，从而实现不断接收7字节、回传7字节的功能。</p>
<h2 id="yu-dao-wen-ti">遇到问题</h2>
<p>发送字节数为7时，能够正常echo；但是不为7时，本来期望是单次发送字节数：</p>
<ul>
<li>大于7字节时，应该也能每次触发中断，只是多余的字节数被丢弃了而已</li>
<li>少于7字节时（例如5），则通过再次发送也能触发中断</li>
</ul>
<p>但实验过程中发现这两种情况下，会发送echo了一两次之后，后面无论发送多少数据都无法再echo的情况</p>
<h1 id="qing-jing-zai-xian">情景再现</h1>
<h2 id="cube-pei-zhi">Cube配置</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212649840.png" alt="image-20241112212649840"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212742297.png" alt="image-20241112212742297"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212813159.png" alt="image-20241112212813159"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212840656.png" alt="image-20241112212840656"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212935188.png" alt="image-20241112212935188"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212959621.png" alt="image-20241112212959621"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213059038.png" alt="image-20241112213059038"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213254243.png" alt="image-20241112213254243"></p>
<h2 id="dao-ru-clion">导入Clion</h2>
<h3 id="bian-yi-pei-zhi-jiao-cha-bian-yi">编译配置-交叉编译</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213601046.png" alt="image-20241112213601046"></p>
<h3 id="cmake-pei-zhi">Cmake配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213656961.png" alt="image-20241112213656961"></p>
<h3 id="open-ocd-shao-lu-pei-zhi">OpenOCD烧录配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213740944.png" alt="image-20241112213740944"></p>
<p><code>daplink.cfg</code>：</p>
<pre class="line-numbers language-none"><code class="language-none"># choose st-link/j-link/dap-link etc.
adapter driver cmsis-dap
transport select swd

# 0x10000 = 64K Flash Size
# set FLASH_SIZE 0x20000

# 512KB Flash
set FLASH_SIZE 0x80000

source [find target/stm32f4x.cfg]

# download speed = 10MHz
# adapter speed 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="dai-ma-liu-cheng">代码流程</h2>
<ul>
<li>上电后启用接收中断</li>
<li>在接收完毕回调中echo，并再次启用接收中断</li>
</ul>
<p><code>main.c</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 0 */</span>
<span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 0 */</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">/* USER CODE BEGIN 1 */</span>
    <span class="token function">__HAL_RCC_HSI_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__HAL_RCC_SYSCLK_CONFIG</span><span class="token punctuation">(</span>RCC_SYSCLKSOURCE_HSI<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE END 1 */</span>

    <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

    <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* USER CODE BEGIN Init */</span>

    <span class="token comment">/* USER CODE END Init */</span>

    <span class="token comment">/* Configure the system clock */</span>
    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* USER CODE BEGIN SysInit */</span>

    <span class="token comment">/* USER CODE END SysInit */</span>

    <span class="token comment">/* Initialize all configured peripherals */</span>
    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE BEGIN 2 */</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE END 2 */</span>

    <span class="token comment">/* Infinite loop */</span>
    <span class="token comment">/* USER CODE BEGIN WHILE */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//        HAL_UART_Transmit_IT(&amp;huart1, (uint8_t *)"Hello, World!\r\n", 14);</span>
        <span class="token comment">//        HAL_Delay(1000);</span>
        <span class="token comment">/* USER CODE END WHILE */</span>

        <span class="token comment">/* USER CODE BEGIN 3 */</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="yuan-ma-fen-xi">源码分析</h1>
<h2 id="qi-yong-jie-shou-zhong-duan-hal-uart-receive-it">启用接收中断HAL_UART_Receive_IT</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>HAL_UART_Receive_IT -&gt; UART_Start_Receive_IT</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">huart<span class="token operator">-&gt;</span>pRxBuffPtr <span class="token operator">=</span> pData<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxXferSize <span class="token operator">=</span> Size<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxXferCount <span class="token operator">=</span> Size<span class="token punctuation">;</span>

huart<span class="token operator">-&gt;</span>ErrorCode <span class="token operator">=</span> HAL_UART_ERROR_NONE<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxState <span class="token operator">=</span> HAL_UART_STATE_BUSY_RX<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
<span class="token comment">/* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */</span>
<span class="token function">__HAL_UART_ENABLE_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">,</span> UART_IT_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* Enable the UART Data Register not empty Interrupt */</span>
<span class="token function">__HAL_UART_ENABLE_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">,</span> UART_IT_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>pRxBuffPtr</code> ：<strong>保存我们传入的buf指针</strong></li>
<li><code>RxXferSize</code> ：<strong>保存我们传入的buf大小</strong></li>
<li><code>RxXferCount</code>： <strong>初始化待接收数据数量</strong></li>
<li><code>ErrorCode</code>：初始化错误码为 no error</li>
<li><code>RxState</code>：<strong>标识UART处于接收状态（Data Reception process is ongoing）</strong></li>
<li>开启UART异常中断
<ul>
<li>帧异常（Frame error）</li>
<li>噪声异常（noise error）</li>
<li><em><strong>接收缓冲区溢出异常（overrun error）</strong></em></li>
</ul>
</li>
<li>开启接收寄存器非空中断（Enable the UART Data Register not empty Interrupt）</li>
</ul>
<h2 id="uart-zhong-duan-xiang-liang-biao">UART中断向量表</h2>
<p><em><strong>startup_stm32f407vetx.s</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>word     USART1_IRQHandler                 <span class="token comment">/* USART1                       */</span>       <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em><strong>stm32f4xx_it.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* USER CODE BEGIN USART1_IRQn 0 */</span>

  <span class="token comment">/* USER CODE END USART1_IRQn 0 */</span>
  <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN USART1_IRQn 1 */</span>

  <span class="token comment">/* USER CODE END USART1_IRQn 1 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="shu-ju-jie-shou-chu-li">数据接收处理</h2>
<p><em><strong>stm32f4xx_it.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* If no error occurs */</span>
    errorflags <span class="token operator">=</span> <span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>USART_SR_PE <span class="token operator">|</span> USART_SR_FE <span class="token operator">|</span> USART_SR_ORE <span class="token operator">|</span> USART_SR_NE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorflags <span class="token operator">==</span> RESET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* UART in mode Receiver -------------------------------------------------*/</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cr1its <span class="token operator">&amp;</span> USART_CR1_RXNEIE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">UART_Receive_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行接收数据逻辑（UART_Receive_IT）的前置条件：</p>
<ul>
<li>没有UART相关的异常（errorflags）</li>
<li>接收寄存器非空（USART_SR_RXNE）</li>
<li>接收寄存器非空中断使能是开启的（USART_CR1_RXNEIE）</li>
</ul>
<h2 id="zhu-zi-jie-shou-shu-ju-data-register">逐字接收数据（Data Register）</h2>
<p><em><strong>stm32f4xx_hal_uart.c/UART_Receive_IT</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Check that a Rx process is ongoing */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>RxState <span class="token operator">==</span> HAL_UART_STATE_BUSY_RX<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>pdata8bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>Instance<span class="token operator">-&gt;</span>DR <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span> <span class="token number">0x00FF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	huart<span class="token operator">-&gt;</span>pRxBuffPtr <span class="token operator">+=</span> <span class="token number">1U</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>huart<span class="token operator">-&gt;</span>RxXferCount <span class="token operator">==</span> <span class="token number">0U</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*Call legacy weak Rx complete callback*/</span>
		<span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>判断UART是不是处于接收进程中
<ul>
<li>我们之前调用过 <code>HAL_UART_Receive_IT</code>，里面会置位这个状态 <code>huart-&gt;RxState = HAL_UART_STATE_BUSY_RX</code></li>
</ul>
</li>
<li>从DR（UART数据寄存器）中读取一个字节到用户自定义缓冲区中（我们调用 <code>HAL_UART_Receive_IT</code> 时传入过一个7字节的<code>buf</code>）</li>
<li>递减剩余待接收数据数量 <code>huart-&gt;RxXferCount</code>（之前被初始化为7）
<ul>
<li>如果递减为0，则说明接收的字节数填满了用户指定缓冲区大小</li>
<li>然后调用 <code>HAL_UART_RxCpltCallback</code>，这是一个 <code>weak</code>函数（默认是一个空实现），用户可以声明一个对应的非 <code>weak</code>版以实现回调处理。这个理念是经典的<strong>hook钩子函数</strong>。</li>
</ul>
</li>
</ul>
<h2 id="zhong-xie-huan-chong-qu-jie-shou-wan-bi-hui-diao">重写缓冲区接收完毕回调</h2>
<p>原型：</p>
<p><em><strong>stm32f4xx_hal_uart.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__weak <span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Prevent unused argument(s) compilation warning */</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* NOTE: This function should not be modified, when the callback is needed,
             the HAL_UART_RxCpltCallback could be implemented in the user file
     */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重写：</p>
<p><em><strong>main.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 0 */</span>
<span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 0 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>将缓冲区7字节数据通过UART TX发送，采用轮询方式（每发一个字节轮询发送状态），超时时间100ms</li>
<li>重新开启接收中断，以实现下一次的echo</li>
</ul>
<h2 id="ding-chang-7-zi-jie-echo-ce-shi">定长7字节echo测试</h2>
<p>至此，定长7字节数据echo功能就实现了</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241113084959956.png" alt="image-20241113084959956"></p>
<h2 id="chao-7-zi-jie-echo-ce-shi">超7字节echo测试</h2>
<p><img src="C:/Users/86157/AppData/Roaming/Typora/typora-user-images/image-20241113085040298.png" alt="image-20241113085040298"></p>
<p>为什么超过我们指定的缓冲区大小（<code>HAL_UART_Transmit</code>的入参 <code>Size</code>）后，功能就不整行了呢？</p>
<h2 id="uart-zhong-duan-isr-yi-chang-liu-cheng">UART中断ISR-异常流程</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* If no error occurs */</span>
    errorflags <span class="token operator">=</span> <span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>USART_SR_PE <span class="token operator">|</span> USART_SR_FE <span class="token operator">|</span> USART_SR_ORE <span class="token operator">|</span> USART_SR_NE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorflags <span class="token operator">==</span> RESET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">UART_Receive_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
     
     <span class="token comment">/* If some errors occur */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>errorflags <span class="token operator">!=</span> RESET<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cr3its <span class="token operator">&amp;</span> USART_CR3_EIE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>
                                  <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cr1its <span class="token operator">&amp;</span> <span class="token punctuation">(</span>USART_CR1_RXNEIE <span class="token operator">|</span> USART_CR1_PEIE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* UART Over-Run interrupt occurred
         huart-&gt;ErrorCode |= HAL_UART_ERROR_ORE;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>没有异常时，会执行 <code>UART_Receive_IT</code>逐字接收数据并在填满缓冲区后触发接收完毕回调 <code>HAL_UART_RxCpltCallback</code></li>
<li>但是当我们发送8字节时，会触发UART的接收溢出错误，继而转向异常处理流程</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token comment">/* Call UART Error Call back function if need be --------------------------*/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>ErrorCode <span class="token operator">!=</span> HAL_UART_ERROR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">/*Call legacy weak error callback*/</span>
    <span class="token function">HAL_UART_ErrorCallback</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为异常处理流程不会执行我们自定义的 <code>HAL_UART_RxCpltCallback</code>，也就没有重新开启接收中断 <code>HAL_UART_RxCpltCallback</code>，所以就出现了发送8字节时，后续没有回传的现象：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241113085040298.png" alt="image-20241113085040298"></p>
<h1 id="si-kao-yi-liu-wen-ti">思考/遗留问题</h1>
<h2 id="usart-sr-ore-shi-ru-he-bei-she-zhi-de">USART_SR_ORE是如何被设置的</h2>
<p>为什么发送8字节时会触发USART_SR_ORE错误？</p>
]]></content>
      <categories>
        <category>STM32</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>Clion</tag>
        <tag>GD32</tag>
        <tag>HAL</tag>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/11/12/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>从按键控制LED开始深入理解外部中断（基于STM32F103ZE）</title>
    <url>/2024/11/27/59863.html</url>
    <content><![CDATA[<h1 id="qian-yan">前言</h1>
<h2 id="can-kao-shou-ce">参考手册</h2>
<p><a href="https://www.st.com.cn/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32F101xx, STM32F102xx, STM32F103xx, STM32F105xx and STM32F107xx advanced Arm®-based 32-bit MCUs</a></p>
<p><a href="https://www.st.com/resource/en/programming_manual/pm0056-stm32f10xxx20xxx21xxxl1xxxx-cortexm3-programming-manual-stmicroelectronics.pdf">STM32F10xxx/20xxx/21xxx/L1xxxx Cortex®-M3 programming manual</a></p>
<h2 id="wei-shi-yao-xu-yao-wai-bu-zhong-duan">为什么需要外部中断</h2>
<blockquote>
<p>[!NOTE]</p>
<p>按键扫描也可以实现按键控制LED亮灭，为什么需要外部中断呢？</p>
</blockquote>
<p>当我们使用按键扫描的方案时，CPU需要主动的不断轮询查看按键的状态，发现其被按下时就将LED状态反转一下。</p>
<p>如果把我们自己比作CPU，这就相当于我们网购之后，不断去快递点询问快递有没有到，如果没有就一直干等在那里，直到取到快递。在此期间，我们没有办法去做其他事情，时间都被浪费掉了。</p>
<h2 id="hao-lai-wu-yuan-ze-kong-zhi-fan-zhuan">好莱坞原则/控制反转</h2>
<p>还有一个著名的好莱坞原则：当演员去试镜后，剧组会告知演员不要打电话给我们，有结果了我们会通知你。</p>
<p>好莱坞原则是面向对象编程中的一个设计理念，常用来指导模块之间的交互方式。其核心思想是：</p>
<blockquote>
<p>“Don’t call us, we’ll call you.”<br>
“别调用我们，我们会调用你。”</p>
</blockquote>
<p>这意味着，在系统的架构设计中，下层模块不主动调用上层模块，而是通过某种机制（例如回调函数、事件驱动或依赖注入）让上层模块在合适的时候去调用下层模块。</p>
<p>这一原则强调 控制反转（IOC，Inversion of Control），目的是解耦模块，增强代码的可维护性和可扩展性。</p>
<h1 id="yi-chang-xiang-liang-biao">异常向量表</h1>
<h2 id="arm-he-yi-chang-xiang-liang-biao">ARM核异常向量表</h2>
<p>类似的，在按键控制LED案例中，我们无法预知用户会在何时按下按键，因此通过CPU主动地不断轮询这一事件是不明智的。我们应该将控制权交还给用户，希望用户在按下按键时，CPU能够被动地感知到，并执行我们预先编写好的按键事件处理逻辑。</p>
<p>ARM核是支持中断这一机制的，当中断发生时，ARM能够停下手头上的事情、保存工作现场，转而执行对应的中断处理服务程序，完成后再跳转会中断前的地方，恢复工作现场并继续执行既定程序。</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241127224011740.png" alt="image-20241127224011740" style="zoom: 50%;">
<blockquote>
<p><a href="https://www.st.com/resource/en/programming_manual/pm0056-stm32f10xxx20xxx21xxxl1xxxx-cortexm3-programming-manual-stmicroelectronics.pdf">STM32F10xxx/20xxx/21xxx/L1xxxx Cortex®-M3 programming manual</a> P156</p>
<p>The vector table contains the reset value of the stack pointer, and the start addresses, alsocalled exception vectors, for all exception handlers</p>
</blockquote>
<p>上述是ARM核对应异常（中断是异常的一种）向量表的规范：上电后应该初始化SP栈指针，接着执行<code>Reset</code>异常处理函数。我们可以对应STM32提供的标准外设库中的启动汇编程序 <code>startup.s</code>来看下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">__Vectors       DCD     __initial_sp               ; Top of Stack
                DCD     Reset_Handler              ; Reset Handler
                ...
                
; Reset handler
Reset_Handler   PROC
                EXPORT  Reset_Handler             [WEAK]
                IMPORT  __main
                IMPORT  SystemInit
                LDR     R0, =SystemInit
                BLX     R0               
                LDR     R0, =__main
                BX      R0
                ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现<code>Reset</code>异常的执行做了两件事情：</p>
<ol>
<li>执行 <code>SystemInit</code>函数：可以在<code>system_stm32f1xx.c</code>找到定义，其中做了系统时钟的初始化</li>
<li>执行 <code>main</code>函数</li>
</ol>
<h2 id="yi-chang-fen-lei">异常分类</h2>
<p>ARM核规范中提供了84个中断（见上表），但STM32F103只实现了70个：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241127230557526.png" alt="image-20241127230557526"></p>
<blockquote>
<p><a href="https://www.st.com.cn/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32F101xx, STM32F102xx, STM32F103xx, STM32F105xx and STM32F107xx advanced Arm®-based 32-bit MCUs</a> P1136</p>
</blockquote>
<p>这些异常大致可以分为三类：</p>
<ul>
<li>ARM核异常：例如复位异常，用于上电后执行用户程序</li>
<li>外设中断异常：由STM32根据ARM异常规范及SOC（片上外设）实现，例如USART中断、DMA中断、定时器中断等</li>
<li>外部异常：通过服用GPIO引脚输入功能来实现，可以通过片外硬件触发（例如按键）</li>
</ul>
<h2 id="yi-chang-tiao-zhuan">异常跳转</h2>
<p>当具体的异常发生时，ARM核会根据该异常在向量表中的偏移地址找到对应的异常处理指令来执行，例如外部中断10就会找到 <code>startup_stm32f103xe.s</code>中的 <code>DCD     EXTI15_10_IRQHandler</code>。通过<code>DCD</code>指令存放了 <code>EXTI15_10_IRQHandler</code>函数的入口地址（如果我们定义了该函数，则在链接时就能够找到对应的入口地址）</p>
<h1 id="stm-32-wai-bu-zhong-duan-shi-jian">STM32外部中断实践</h1>
<blockquote>
<p>[!NOTE]</p>
<p>这里以STM32F103ZE为例</p>
</blockquote>
<h2 id="stm-32-zhong-duan-ti-xi-jia-gou">STM32中断体系架构</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128082243029.png" alt="image-20241128082243029"></p>
<h2 id="gpio-shu-ru-fu-yong-exti">GPIO输入复用EXTI</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128084910018.png" alt="image-20241128084910018"></p>
<p>可以发现，输入不仅会传输到输入数据寄存器IDR，也会接入到复用功能输入（AF Input）；</p>
<p>如下，EXTI的左边是多个GPIO连接到多路选择器，右边连到中断线，这样就能通过一根中断线处理A-G 7个IO口的引脚。具体中断和其中哪个引脚短接，可以通过设置EXTI中的寄存器（多路选择寄存器）来选择具体的引脚。</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128084718261.png" alt="image-20241128084718261" style="zoom:50%;">
<h2 id="wai-bu-zhong-duan-kong-zhi-qi-kuang-tu">外部中断控制器框图</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128082339103.png" alt="image-20241128082339103" style="zoom:50%;">
<ul>
<li>（falling/rising trigger selection register）边沿触发选择寄存器：可配置触发方式为上升沿、下降沿、还是两者均可</li>
<li>（software interrupt event register）软件中断事件寄存器：和外部中断通过 <mark>或门</mark>相接，我们可以通过在程序中设置该寄存器从而实现软件触发中断的效果，而不是外部硬件设备（例如按键按下）触发</li>
<li>（interrupt mask register）中断屏蔽（<mark>mask</mark>）寄存器：该寄存器与外部中断通过 <mark>与门</mark>相接，当该寄存器设置为1时，表明不要屏蔽该外部中断，当其发生时将其递交给 <mark>NVIC</mark></li>
<li>（pending request register）中断待处理（pending）请求寄存器：如果该外部中断经过了前述寄存器的层层考验，那么该寄存器会被设置（硬件设置）；该寄存器与 <mark>NVIC</mark>对接，<mark>NVIC</mark>检测到该寄存器被设置，那么就会收到中断待处理请求。（相当于EXTI通知NVIC有外部中断了）</li>
</ul>
<h2 id="zhong-duan-you-xian-ji-ceng-ji-hua-fen">中断优先级层级划分</h2>
<p>由于这一部分隶属于ARM核，因此需要查看ARM核相关的参考手册</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128090342846.png" alt="image-20241128090342846"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128090422528.png" alt="image-20241128090422528"></p>
<blockquote>
<p><a href="https://www.st.com/resource/en/programming_manual/pm0056-stm32f10xxx20xxx21xxxl1xxxx-cortexm3-programming-manual-stmicroelectronics.pdf">STM32F10xxx/20xxx/21xxx/L1xxxx Cortex®-M3 programming manual</a></p>
</blockquote>
<p>如果将这三个比特位配置为 <code>011</code>，那么就不划分出子优先级，而只使用抢占优先级</p>
<h2 id="zhong-duan-you-xian-ji-she-zhi">中断优先级设置</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128091551647.png" alt="image-20241128091551647"></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128091800612.png" alt="image-20241128091800612" style="zoom:50%;">
<blockquote>
<p>[!NOTE]</p>
<p>其中八位的高四位（[7:4]）用来表示优先级的值，offset则对应中断号</p>
</blockquote>
<h1 id="dai-ma-shi-xian-ji-cun-qi-ban-ben">代码实现（寄存器版本）</h1>
<h2 id="kai-qi-shi-zhong">开启时钟</h2>
<p>找到GPIO和AFIO外设挂载的总线：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128100638280.png" alt="image-20241128100638280" style="zoom:50%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128100807316.png" alt="image-20241128100807316"></p>
<p>增加芯片型号的定义 <code>#define STM32F10X_HD</code>以开启宏定义<code>RCC_APB2ENR_IOPFEN</code></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#if !defined (STM32F10X_LD) &amp;&amp; !defined (STM32F10X_LD_VL) &amp;&amp; !defined (STM32F10X_MD) &amp;&amp; !defined (STM32F10X_MD_VL) &amp;&amp; !defined (STM32F10X_HD) &amp;&amp; !defined (STM32F10X_HD_VL) &amp;&amp; !defined (STM32F10X_XL) &amp;&amp; !defined (STM32F10X_CL) 
  /* #define STM32F10X_LD */     /*!&lt; STM32F10X_LD: STM32 Low density devices */
  /* #define STM32F10X_LD_VL */  /*!&lt; STM32F10X_LD_VL: STM32 Low density Value Line devices */
  /* #define STM32F10X_MD */     /*!&lt; STM32F10X_MD: STM32 Medium density devices */
  /* #define STM32F10X_MD_VL */  /*!&lt; STM32F10X_MD_VL: STM32 Medium density Value Line devices */
  #define STM32F10X_HD     /*!&lt; STM32F10X_HD: STM32 High density devices */
  /* #define STM32F10X_HD_VL */  /*!&lt; STM32F10X_HD_VL: STM32 High density value line devices */
  /* #define STM32F10X_XL */     /*!&lt; STM32F10X_XL: STM32 XL-density devices */
  /* #define STM32F10X_CL */     /*!&lt; STM32F10X_CL: STM32 Connectivity line devices */
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使能时钟：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// gpio clock</span>
RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_IOPFEN<span class="token punctuation">;</span>
<span class="token comment">// afio clock</span>
RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_AFIOEN<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="gpio-pei-zhi">GPIO配置</h2>
<p>由于一端接3V3，因此GPIO可以配置成输入下拉，这样按下时能够产生一个上升沿：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128092332887.png" alt="image-20241128092332887" style="zoom: 33%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128092630183.png" alt="image-20241128092630183"></p>
<p>并通过ODR将上下拉选择为下拉</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128093513456.png" alt="image-20241128093513456" style="zoom:50%;">
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128093142134.png" alt="image-20241128093142134"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// gpio config for PF10</span>
   GPIOF<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_MODE10<span class="token punctuation">;</span>   <span class="token comment">// input mode</span>
   GPIOF<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF10_1<span class="token punctuation">;</span>   <span class="token comment">// input with pull-up/down</span>
   GPIOF<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF10_0<span class="token punctuation">;</span>
   GPIOF<span class="token operator">-&gt;</span>ODR <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_ODR_ODR10<span class="token punctuation">;</span>   <span class="token comment">// pull-down</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="afio-fu-yong-shu-ru-wei-wai-bu-zhong-duan">AFIO复用输入为外部中断</h2>
<p>接着我们需要打通GPIO输入到EXTI的通路</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128092916951.png" alt="image-20241128092916951"></p>
<p>将外部中断线10（EXTI10）选择为PF10：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128093641646.png" alt="image-20241128093641646"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// afio config</span>
    AFIO<span class="token operator">-&gt;</span>EXTICR<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span>AFIO_EXTICR3_EXTI10<span class="token punctuation">;</span>
    AFIO<span class="token operator">-&gt;</span>EXTICR<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">|=</span> AFIO_EXTICR3_EXTI10_PF<span class="token punctuation">;</span>   <span class="token comment">// select PF as exti10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="exti-pei-zhi">EXTI配置</h2>
<p>对照其内部框图，看下哪些寄存器需要配置</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128094127920.png" alt="image-20241128094127920" style="zoom:50%;">
<h3 id="jie-chu-zhong-duan-ping-bi">解除中断屏蔽</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128094000914.png" alt="image-20241128094000914"></p>
<h3 id="qi-yong-shang-sheng-yan-hong-fa">启用上升沿触发</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128094036359.png" alt="image-20241128094036359"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// exti config</span>
    EXTI<span class="token operator">-&gt;</span>IMR <span class="token operator">|=</span> EXTI_IMR_MR10<span class="token punctuation">;</span>   <span class="token comment">// unmask interrupt</span>
    EXTI<span class="token operator">-&gt;</span>RTSR <span class="token operator">|=</span> EXTI_RTSR_TR10<span class="token punctuation">;</span>   <span class="token comment">// rising edge trigger</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="nvic-pei-zhi">NVIC配置</h2>
<h3 id="you-xian-ji-ceng-ji-she-zhi">优先级层级设置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128094413013.png" alt="image-20241128094413013"></p>
<h3 id="wei-wai-bu-zhong-duan-hao-zhi-ding-you-xian-ji">为外部中断号指定优先级</h3>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128094538150.png" alt="image-20241128094538150" style="zoom:50%;">
<blockquote>
<p>[!NOTE]</p>
<p>这里每8个bit对应一个中断号的优先级，因此使用了21个32bit的IPR寄存器来存储84个中断号对应的优先级</p>
</blockquote>
<h3 id="shi-neng-wai-bu-zhong-duan">使能外部中断</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128094859410.png" alt="image-20241128094859410"></p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>注意EXTI有中断屏蔽开关，NVIC也有中断使能开关；</p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128095539003.png" alt="image-20241128095539003"></p>
<blockquote>
<p>[!NOTE]</p>
<p>一个bit存储一个中断对应的使能开关，使用了3个32bit的ISER寄存器来存储中断号<mark>0~67</mark>的使能开关</p>
</blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// nvic config</span>
    <span class="token function">NVIC_SetPriorityGrouping</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// only pre-priority</span>
    <span class="token function">NVIC_SetPriority</span><span class="token punctuation">(</span>EXTI15_10_IRQn<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">NVIC_EnableIRQ</span><span class="token punctuation">(</span>EXTI15_10_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// response interrupt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ding-yi-zhong-duan-chu-li-han-shu">定义中断处理函数</h2>
<p>在 <code>startup.s</code>中找到 EXTI10对应的中断函数名称的声明 <code>EXTI15_10_IRQHandler</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">__Vectors       DCD     __initial_sp               ; Top of Stack
                DCD     Reset_Handler              ; Reset Handler
                DCD     NMI_Handler                ; NMI Handler
                ...
                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>经过按键抖动判断后反转LED状态：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">EXTI15_10_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    EXTI<span class="token operator">-&gt;</span>PR <span class="token operator">|=</span> EXTI_PR_PR10<span class="token punctuation">;</span>   <span class="token comment">// clear pending flag</span>
    <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIOF<span class="token operator">-&gt;</span>IDR <span class="token operator">&amp;</span> GPIO_IDR_IDR10<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">LED_Toggle</span><span class="token punctuation">(</span>LED1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="the-end">THE END</h1>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>外部中断</tag>
        <tag>EXTI</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解I2C时序（以I2C实时时钟PCF8563为案例）</title>
    <url>/2024/11/16/31289.html</url>
    <content><![CDATA[<h1 id="yi-qian-yan">一、前言</h1>
<h2 id="ying-jian-bei-jing">硬件背景</h2>
<ul>
<li>GD32F407VET6</li>
<li>I2C实时时钟PCF8563</li>
</ul>
<h2 id="yuan-li-tu">原理图</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116194724707.png" alt="image-20241116194724707" style="zoom: 33%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116194750339.png" alt="image-20241116194750339" style="zoom:33%;">
<h2 id="wen-dang-zi-liao">文档资料</h2>
<ul>
<li><a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a></li>
<li><a href="https://atta.szlcsc.com/upload/public/pdf/source/20230921/9DB04F89E1E4336DD7CCB7C268B77442.pdf">I 2 C 实时时钟/日历芯片 PCF8563</a></li>
</ul>
<h1 id="er-en-zhi-pu-nxp-i-2-c-zong-xian-xie-yi-shi-xu-jie-xi">二、恩智浦（NXP）I2C总线协议时序解析</h1>
<blockquote>
<p>参见<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的</p>
<p>**6 Electrical specifications and timing for I/O stages and bus lines  **</p>
<p>**Table 11. Characteristics of the SDA and SCL bus lines for Standard, Fast, and Fast-mode Plus I2C-bus devices **</p>
</blockquote>
<h2 id="overview">Overview</h2>
<h3 id="sda-scl-zong-xian-te-xing">SDA/SCL总线特性</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116195121046.png" alt="image-20241116195121046"></p>
<h3 id="shi-xu-ding-yi">时序定义</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202433638.png" alt="image-20241116202433638"></p>
<h2 id="i-2-c-chuan-shu-kong-zhi">I2C传输控制</h2>
<p>I2C规定单次通信需要遵循如下两个控制</p>
<h3 id="shu-ju-chuan-shu-kong-zhi">数据传输控制</h3>
<p><mark>在SCL为低时可以修改SDA；SCL为高时，SDA应该保持不变。</mark></p>
<p>在SCL为低电平时，准备SDA（发送方）；在SCL为高时，保持SDA（在此期间接送方会读取SDA）。</p>
<p>这一点在<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的 <strong>3.1.3 Data validity</strong>说明如下：</p>
<blockquote>
<p>The data on the SDA line must be stable during the HIGH period of the clock. The HIGH or LOW state of the data line can only change when the clock signal on the SCL line is LOW (see Figure 4). One clock pulse is generated for each data bit transferred.</p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214251742.png" alt="image-20241116214251742"></p>
<h2 id="qi-shi-zhong-zhi-kong-zhi">起始/终止控制</h2>
<p>在SCL为高时，拉低SDA（需要提前准备好SDA为高）；在SCL为低时，拉高SDA（需要提前准备好SDA为低）。</p>
<p><mark>可以发现为了区分数据传输控制，特意在SCL为高时操作SDA。</mark></p>
<p>这一点在<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的 <strong>3.1.4 START and STOP conditions</strong> 说明如下：</p>
<blockquote>
<p>All transactions begin with a START (S) and are terminated by a STOP (P) (see Figure 5). A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition. A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition.</p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214423843.png" alt="image-20241116214423843"></p>
<h2 id="f-sub-scl-sub-shi-zhong-xian-pin-lu-frequency-for-scl">f<sub>SCL</sub>时钟线频率（frequency for SCL）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116201656138.png" alt="image-20241116201656138"></p>
<p>该参数规定了I2C的SCL时钟线的频率，以Fast-mode为例，最大为400kHz。这意味着我们在操作SCL时，将SCL置0的时间+随后将SCL置1的时间之和不能小于 1/400kHz = 2.5us：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116201725124.png" alt="image-20241116201725124"></p>
<h2 id="t-sub-hd-sta-sub-qi-shi-xin-hao-bao-chi-shi-jian-hol-d-time-for-start-condition">t<sub>HD;STA</sub>起始信号保持时间（HolD time for START condition）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202607065.png" alt="image-20241116202607065"></p>
<p>该参数规定了起始信号（START condition）需要保持的时间（在SCL为高电平时，将SDA由高拉低后需要保持的时间）</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202932000.png" alt="image-20241116202932000" style="zoom: 50%;">
<p>这里有两个细节需要注意一下：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204002371.png" alt="image-20241116204002371"></p>
<ol>
<li>hold time (<mark>repeated</mark>) START condition：<mark>repeated</mark>表明第一个起始信号后的重复起始信号都需要遵循这个规则，例如在<a href="https://atta.szlcsc.com/upload/public/pdf/source/20230921/9DB04F89E1E4336DD7CCB7C268B77442.pdf">PCF8563</a>中提到的 <mark>写地址，读数据</mark>模式中，在第一个S（起始信号）之后有一个 <mark>dummy&nbsp;write</mark>（指定后面连续读的起始寄存器地址），然后又有一个S，紧接着才是真正的连续读数据。这里第二个S就属于 <mark>repeated&nbsp;START&nbsp;condition</mark>。</li>
</ol>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116203555124.png" alt="image-20241116203555124" style="zoom: 33%;">
<ol start="2">
<li>
<p><mark>After this period, the first clock pulse is generated</mark>：暗示我们在这个t<sub>HD;STA</sub>周期（相当于I2C通信的准备阶段）过后，主设备应该生成第一个时钟脉冲开始传输数据。因此时序定义里也给出了如下示意图，<strong>暗示我们在延时t<sub>HD;STA</sub>之后，应该将SCL拉低</strong>（图中 <mark>1<sup>st</sup>&nbsp;clock&nbsp;cycle</mark>也进一步印证了这一点）。</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204645958.png" alt="image-20241116204645958" style="zoom:50%;">
</li>
</ol>
<h2 id="t-sub-low-sub-t-sub-high-sub-shi-zhong-xian-gao-di-dian-ping-zhou-qi-kong-zhi-scl-low-high-period">t<sub>LOW</sub>/t<sub>HIGH</sub>时钟线高低电平周期控制（SCL low/high period）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204955105.png" alt="image-20241116204955105"></p>
<p>该参数规定了我们传输数据拉高拉低SCL时，其高低电平应该持续的时间，以Fast-mode为例，SCL低电平最低持续1.3us，高电平则最低0.6us</p>
<h2 id="t-sub-su-sta-sub-qi-shi-xin-hao-jian-li-zhun-bei-shi-jian-set-up-time-for-start">t<sub>SU;STA</sub> 起始信号建立（准备）时间（SetUp time for START）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116205306146.png" alt="image-20241116205306146"></p>
<p>该参数规定了起始信号的建立（准备）时间，这个参数有点难理解。我们参照时序定义来看下：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116205502756.png" alt="image-20241116205502756" style="zoom: 50%;">
<p>和t<sub>HD;STA</sub>对比来看，t<sub>HD;STA</sub>规定了起始信号的保持时间（SCL为高时，拉低SDA并保持）。</p>
<p>t<sub>SU;STA</sub> 则是用于重复起始信号的（每次通信至少对应一个START和STOP，连续的多次通信中紧接着前一次通信STOP之后的START可称为 <mark>repeated START</mark>，前面介绍的 <mark>写地址，连续读模式</mark>对应的START,START,STOP中第二个START也是如此）。</p>
<p>对于重复起始信号而言，SCL可能是以低电平开始的（例如上一次通信将SCL拉低了），为了满足实现起始信号（拉低SDA）的<mark>前置条件（SCL为高，SDA为高）</mark>，该参数规定了在拉低SDA之前，SDA应该在SCL为高期间保持高电平的时间。</p>
<h2 id="qi-shi-zhong-zhi-xin-hao-de-shi-xian">起始/终止信号的实现</h2>
<p>这里我们已经可以写出起始信号的伪代码了（所有延时以 Fast-mode 为例）：</p>
<p><code>I2C_Start()</code></p>
<pre class="line-numbers language-none"><code class="language-none">// 前置条件
SDA = HIGH
SCL = HIGH
// 前置条件建立（准备）时间
delay 0.6us

// 起始信号(SCL,SDA为高时，拉低SDA)
SDA = LOW
// 起始信号保持时间
delay 0.6

// 开始第一个时钟周期低电平阶段
SCL = 0;
delay 1.3us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的C语言实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SCL_PIN</span>    <span class="token expression">GPIO_PIN_6</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SDA_PIN</span>    <span class="token expression">GPIO_PIN_7</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_PORT</span>  <span class="token expression">GPIOB</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_RCU</span>   <span class="token expression">RCU_GPIOB</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start setup</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start hold</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>注意</mark>：这里第22行，并没有和伪代码中的1.3us保持一致，是因为在后续的数据传输中，置位SDA后是需要一个setup时延的（例如1us），无形之间延长了SCL低电平的时间（相当于变成为2us），详见后文分析。</p>
<h2 id="t-sub-hd-dat-sub-shu-ju-bao-chi-shi-jian-hol-d-time-for-data">t<sub>HD;DAT</sub>数据保持时间（HolD time for DATA）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116212042232.png" alt="image-20241116212042232"></p>
<p>可以发现该参数对应两种条件： <mark>CBUS compatible controllers</mark>和 <mark>I2C-bus devices</mark>，我们这里只关心I2C，要求持续的最小时间为0，相当于不需要控制时延，暂时可以忽略该参数。</p>
<h2 id="t-sub-su-dat-sub-shu-ju-jian-li-zhun-bei-shi-jian-set-up-time-for-data">t<sub>SU;DAT</sub>数据建立（准备）时间（SetUp time for DATA）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116212548515.png" alt="image-20241116212548515"></p>
<p>该参数规定了SDA建立（准备）时间，也即在SCL为低时，置位SDA为下一个要发送的数据后，到拉高SCL（以让接收方读取数据）之前应该保持的时间：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214624147.png" alt="image-20241116214624147" style="zoom:50%;">
<p>我们每次发送数据都遵循如下流程</p>
<ul>
<li>拉低SCL，并延时t<sub>LOW</sub></li>
<li>准备SDA（下一次要发送的数据），并延时t<sub>SU;DAT</sub></li>
<li>拉高SCL，并延时/t<sub>HIGH</sub></li>
</ul>
<h2 id="fa-song-yi-ge-zi-jie-de-shi-xian">发送一个字节的实现</h2>
<p>至此，我们可以写出发送一个字节的伪代码了（接着之前的 <code>I2C_Start</code>）：</p>
<p><code>I2C_SendByte</code></p>
<pre class="line-numbers language-none"><code class="language-none">uint8_t byte
// 需要循环8次，发送一个字节8个bit
for(i = 0 ; i &lt; 8 ; i++) {
    // 此前I2C_Start的结尾以将SCL拉低，这里我们可以直接准备SDA
    SDA = (byte &amp; (0x08 &gt;&gt; i)) ? HIGH : LOW
    delay 1us // SDA建立时间，这期间SCL仍未低电平，因此一共持续了2us
    
    SCL = HIGH
    delay 1us // SCL高电平周期
    
    SCL = LOW // 开启下一个时钟周期
    delay 1us // SCL低电平周期
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应GD32F4的C语言实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start setup</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start hold</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>byte <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// data set-up</span>

        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="t-sub-r-sub-t-sub-f-sub-shang-sheng-yan-xia-jiang-yan-shi-jian-rising-falling-edge">t<sub>r</sub> / t<sub>f</sub>上升沿/下降沿时间（Rising/Falling edge）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116220318791.png" alt="image-20241116220318791"></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116220810270.png" alt="image-20241116220810270" style="zoom:33%;">
<p>这两个参数规定了SCL和SDA的上升沿（r-rising edge）、下降沿（f-falling edge）的时间控制。这个参数和GPIO对应电气特性中的压摆率（<mark>Slew&nbsp;Rate</mark>）。</p>
<p>以GD32F4为例，对应标准库函数 <code>gpio_output_options_set</code>中的 <code>speed</code>参数，即控制GPIO引脚跳变时，物理电路电平转换所需的时延（例如电容充放电过程需要一定的时间）。</p>
<h2 id="t-sub-su-sto-sub-zhong-zhi-xin-hao-jian-li-zhun-bei-shi-jian-set-up-time-for-stop">t<sub>SU;STO</sub>终止信号建立（准备）时间（SetUp time for STOP）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116221510344.png" alt="image-20241116221510344"></p>
<p>由于终止信号（拉高SDA）是有前置条件的（SCL为高，SDA为低），该参数规定了在拉高SDA之前，SDA在SCL为高期间保持低电平的时间：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222328620.png" alt="image-20241116222328620"></p>
<h2 id="t-sub-buf-sub-zong-xian-shi-fang-shi-jian-b-us-free-time">t<sub>BUF</sub>总线释放时间（BUs Free time）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222447598.png" alt="image-20241116222447598"></p>
<p>该参数规定了在一个终止信号（P）和下一个起始信号（S）之间，总线应该被释放（SCL/SDA保持高电平）的时间：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222631166.png" alt="image-20241116222631166"></p>
<h2 id="zhong-zhi-xin-hao-de-shi-xian">终止信号的实现</h2>
<p>至此，我们可以实现终止信号的伪代码了：</p>
<p><code>I2C_Stop</code></p>
<pre class="line-numbers language-none"><code class="language-none">// 前置条件：SDA为低，SCL为高
// 此前I2C_SendByte的结尾已将SCL拉低，这里可以直接准备SDA
SDA = 0
delay 1us // 为了确保SCL低电平周期大于1.3us，这里补充一个1us
SCL = HIGH
delay 1us // SCL高电平周期
delay 1us // 补充1us，确保&gt;总线释放时间1.3us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应C语言实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//stop setup</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//bus free time between a STOP and START condition</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="t-sub-vd-dat-sub-t-sub-vd-ack-sub-shu-ju-ack-you-xiao-shi-jian-valid-time-for-data-ack">t<sub>VD;DAT</sub>/t<sub>VD;ACK</sub>数据/ACK有效时间（Valid time for DATA/ACK）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116223438554.png" alt="image-20241116223438554"></p>
<p>个人理解这两个参数是在接收的场景下使用的，在作为接收方释放SDA（拉高SDA）之后，发送方会通过拉高/拉低SDA来准备ACK/数据比特，然后我们需要等待t<sub>VD;DAT</sub>/t<sub>VD;ACK</sub>这样一个时间确保发送方准备好SDA了，然后我们再拉高SCL（让发送方保持SDA），并读取SDA。</p>
<h2 id="jie-shou-ack-shu-ju-zi-jie-dai-ma-shi-xian">接收ACK/数据字节代码实现</h2>
<p>至此，我们可以实现接收ack和数据字节的代码了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_IN</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_OUT</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_READ</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_input_bit_get</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

bool <span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bool success <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// release bus</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    success <span class="token operator">=</span> <span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">;</span> <span class="token comment">// read ack</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl low</span>
    <span class="token keyword">return</span> success<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">receive_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// slave keep data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// read data</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// let slave prepare next data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="san-i-2-c-wan-zheng-dai-ma">三、I2C完整代码</h1>
<h2 id="code-hal-i-2-c-soft-h-code"><code>hal_i2c_soft.h</code></h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/16.</span>
<span class="token comment">//</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HAL_I2C_SOFT_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HAL_I2C_SOFT_H</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"gd32f4xx.h"</span></span>

<span class="token keyword">void</span> <span class="token function">hal_i2c_soft_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bool <span class="token function">hal_i2c_soft_write</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
bool <span class="token function">hal_i2c_soft_read</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">hal_i2c_soft_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">//HAL_I2C_SOFT_H</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="code-hal-i-2-c-soft-c-code"><code>hal_i2c_soft.c</code></h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/16.</span>
<span class="token comment">//</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hal_i2c_soft.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"systick.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"logger.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SCL_PIN</span>    <span class="token expression">GPIO_PIN_6</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SDA_PIN</span>    <span class="token expression">GPIO_PIN_7</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_PORT</span>  <span class="token expression">GPIOB</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_RCU</span>   <span class="token expression">RCU_GPIOB</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_IN</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_OUT</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_READ</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_input_bit_get</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token keyword">void</span> <span class="token function">hal_i2c_soft_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使能GPIOB时钟</span>
    <span class="token function">rcu_periph_clock_enable</span><span class="token punctuation">(</span>I2C_GPIO_RCU<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 配置PB6（SCL）和PB7（SDA）为开漏输出模式</span>
    <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SCL_PIN <span class="token operator">|</span> I2C_SDA_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_output_options_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_OTYPE_OD<span class="token punctuation">,</span> GPIO_OSPEED_50MHZ<span class="token punctuation">,</span> I2C_SCL_PIN <span class="token operator">|</span> I2C_SDA_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将SCL和SDA线拉高</span>
    <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN <span class="token operator">|</span> I2C_SDA_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start setup</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start hold</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//stop setup</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//bus free time between a STOP and START condition</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool <span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bool success <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// release bus</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    success <span class="token operator">=</span> <span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">;</span> <span class="token comment">// read ack</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl low</span>
    <span class="token keyword">return</span> success<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">send_ack</span><span class="token punctuation">(</span>bool ack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// set sda to reponse ack/nack</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sda setup</span>

    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// let slave read ack</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reset scl for next operation</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>byte <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// data set-up</span>

        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">receive_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// slave keep data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// read data</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// let slave prepare next data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool <span class="token function">start_for_write</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">send_byte</span><span class="token punctuation">(</span>dev_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write dev_addr failed"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">send_byte</span><span class="token punctuation">(</span>reg_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write reg_addr failed"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> bool <span class="token function">start_for_read</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">send_byte</span><span class="token punctuation">(</span>dev_addr <span class="token operator">|</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// read from slave</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write dev_addr for read failed"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">hal_i2c_soft_write</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">start_for_write</span><span class="token punctuation">(</span>dev_addr<span class="token punctuation">,</span> reg_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">send_byte</span><span class="token punctuation">(</span><span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"write data[%d] failed"</span><span class="token punctuation">,</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
            <span class="token keyword">return</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        data<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">hal_i2c_soft_read</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// dummy write for register address</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">start_for_write</span><span class="token punctuation">(</span>dev_addr<span class="token punctuation">,</span> reg_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// continuous read</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">start_for_read</span><span class="token punctuation">(</span>dev_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">receive_byte</span><span class="token punctuation">(</span>buf<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">send_ack</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">receive_byte</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">send_ack</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>I2C</tag>
        <tag>时序要求</tag>
        <tag>PCF8563</tag>
      </tags>
  </entry>
  <entry>
    <title>简易版裸机多任务调度框架</title>
    <url>/2024/11/26/21297.html</url>
    <content><![CDATA[<h1 id="kuang-jia-jian-mo">框架建模</h1>
<h2 id="kuang-jia-chou-xiang">框架抽象</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126093047180.png" alt="image-20241126093047180"></p>
<h2 id="mo-kuai-hua-fen">模块划分</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241126094329449.png" alt="image-20241126094329449"></p>
<h1 id="scheduler">Scheduler</h1>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/25.</span>
<span class="token comment">//</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__SCHEDULER_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__SCHEDULER_H</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"gd32f4xx.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdbool.h"</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">task_function_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>
    TASK_READY<span class="token punctuation">,</span>
    TASK_RUNNING<span class="token punctuation">,</span>
    TASK_WAITING
<span class="token punctuation">}</span> <span class="token class-name">task_state_t</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">task_state_t</span>  task_state<span class="token punctuation">;</span>
    <span class="token class-name">uint16_t</span> task_interval_ms<span class="token punctuation">;</span>
    <span class="token class-name">uint16_t</span> task_time_waiting_ms<span class="token punctuation">;</span>
    <span class="token class-name">task_function_t</span> task_function<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">task_t</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">task_update</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">task_execute</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span><span class="token comment">//__SCHEDULER_H</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/25.</span>
<span class="token comment">//</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"scheduler.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"app.h"</span></span>

<span class="token keyword">static</span> <span class="token class-name">task_t</span> tasks<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        TASK_READY<span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> app_ui_led_flow<span class="token punctuation">,</span>
        TASK_READY<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> app_debug_key_scan<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token class-name">uint8_t</span> TASK_SIZE <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>tasks<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">task_update</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> TASK_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>task_time_waiting_ms<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>task_time_waiting_ms <span class="token operator">&gt;=</span> tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>task_interval_ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>task_state <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>
            tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>task_time_waiting_ms <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">task_execute</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> TASK_SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>task_state <span class="token operator">==</span> TASK_READY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>task_state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
            tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">task_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>task_state <span class="token operator">=</span> TASK_WAITING<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="app">App</h1>
<h2 id="ren-wu-jie-kou-guan-li">任务接口管理</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/25.</span>
<span class="token comment">//</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">APP_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">APP_H</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"logger.h"</span></span>

<span class="token keyword">void</span> <span class="token function">app_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">app_ui_led_flow</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">app_debug_key_scan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span><span class="token comment">//APP_H</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ying-yong-chu-shi-hua">应用初始化</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/25.</span>
<span class="token comment">//</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"app.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"int_led.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"int_key.h"</span></span>

<span class="token keyword">void</span> <span class="token function">app_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">int_led_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">int_key_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"app_init done"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="liu-shui-deng-ren-wu-shi-xian">流水灯任务实现</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/25.</span>
<span class="token comment">//</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"app.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"int_led.h"</span></span>

<span class="token keyword">void</span> <span class="token function">app_ui_led_flow</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//    LOG_DEBUG("app_ui_led_flow invoke")</span>
    <span class="token keyword">static</span> <span class="token class-name">uint8_t</span> led_index <span class="token operator">=</span> LED1<span class="token punctuation">;</span>
    <span class="token function">int_led_on</span><span class="token punctuation">(</span>led_index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    led_index<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>led_index <span class="token operator">==</span> LED_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">int_led_off_all</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        led_index <span class="token operator">=</span> LED1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="an-jian-sao-miao-ren-wu-shi-xian">按键扫描任务实现</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/25.</span>
<span class="token comment">//</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"app.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"int_key.h"</span></span>

<span class="token keyword">void</span> <span class="token function">app_debug_key_scan</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">int_key_scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">key_up_callback</span><span class="token punctuation">(</span>KEY_NO key_no<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"key up"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">key_down_callback</span><span class="token punctuation">(</span>KEY_NO key_no<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">LOG_DEBUG</span><span class="token punctuation">(</span><span class="token string">"key down"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="ding-shi-qi-geng-xin-ren-wu-zhuang-tai">定时器更新任务状态</h1>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">hal_timer5_update_callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">task_update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>多任务</tag>
        <tag>调度</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解UART串口通信（基于STM32F103）</title>
    <url>/2024/11/28/38060.html</url>
    <content><![CDATA[<h1 id="can-kao-shou-ce">参考手册</h1>
<ul>
<li><a href="https://www.st.com.cn/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32F101xx, STM32F102xx, STM32F103xx, STM32F105xx and STM32F107xx advanced Arm®-based 32-bit MCUs</a></li>
<li><a href="https://www.zanwen.icu/2024/11/27/59863.html">从按键控制LED开始深入理解外部中断（基于STM32F103ZE）</a></li>
</ul>
<h1 id="usart-kuang-tu-fen-xi">USART框图分析</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128192635013.png" alt="image-20241128192635013"></p>
<blockquote>
<p><a href="https://www.st.com.cn/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">STM32F101xx, STM32F102xx, STM32F103xx, STM32F105xx and STM32F107xx advanced Arm®-based 32-bit MCUs</a> P789</p>
</blockquote>
<h2 id="fa-song-jie-shou-yin-jiao">发送/接收引脚</h2>
<h3 id="fa-song-jie-shou-yin-jiao-shuo-ming">发送/接收引脚说明</h3>
<blockquote>
<p>RX: Receive Data Input is the serial data input. Oversampling techniques are used for data recovery by discriminating between valid incoming data and noise.</p>
<p>TX: Transmit Data Output. When the transmitter is disabled, the output pin returns to its IO port configuration. When the transmitter is enabled and nothing is to be transmitted, the TX pin is at high level. In single-wire and smartcard modes, this IO is used to transmit and receive the data (at USART level, data are then received on SW_RX)</p>
</blockquote>
<ul>
<li>RX：串行数据输入引脚。</li>
<li>TX：发送数据输出引脚。当发送器没有启用时，这个输出引脚充当通用的GPIO引脚；当启用发送器并且没有内容被发送是什时，该引脚保持高电平。在单线核智能卡模式下，该引脚被用来发送和接收数据（虽然物理上是用的一个引脚，但在USART内部，数据接收是通过SW_RX逻辑通道来完成的）。</li>
</ul>
<h3 id="gpio-fu-yong">GPIO复用</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128195845755.png" alt="image-20241128195845755"></p>
<blockquote>
<p>[!NOTE]</p>
<p>值得注意的是：RX复用IO引脚时，IO口的读通道仍然是连通的；但是TX复用IO引脚时，IO口的写通道是断开的，这意味着该IO引脚完全由对应的复用外设（例如USART）来操控了。</p>
</blockquote>
<p>那么我要怎么知道USART复用哪个引脚呢？这个在GPIO复用功能章节（9.3.8 USART alternate function remapping）能够找到相应的说明：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128200513629.png" alt="image-20241128200513629"></p>
<p>默认使用PA9/10作为USART1的TX/RX，如果需要还可以通过AFIO重映射将其配置为PB6/7：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128200656325.png" alt="image-20241128200656325"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128200735197.png" alt="image-20241128200735197"></p>
<h3 id="gpio-mo-shi-pei-zhi">GPIO模式配置</h3>
<p>现在USART使用引脚我们知道了，那么引脚该配置什么工作模式呢，在GPIO外设配置章节（9.1.11 GPIO configurations for device peripherals）也有说明：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128200958021.png" alt="image-20241128200958021"></p>
<p>TX需要配置为复用推挽，RX需要配置为浮动输入或上拉输入</p>
<h2 id="rts-cts-yin-jiao">RTS/CTS引脚</h2>
<blockquote>
<p>The following pins are required in Hardware flow control mode:<br>
 CTS: Clear To Send blocks the data transmission at the end of the current transfer<br>
when high<br>
 RTS: Request to send indicates that the USART is ready to receive a data (when low)</p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128201344123.png" alt="image-20241128201344123"></p>
<p>这两个引脚在硬件流控模式中需要被用到（通信双方通过这两个引脚来互相协调数据的发送，避免一个发送太快，另一个接收不过来）：</p>
<ul>
<li>RTS（请求发送）：箭头方向是从内向外的，和接收控制器相连。当前串口可以通过拉低该引脚来告知对方可以发送数据了（当前MCU准备好接收数据了）。</li>
<li>CTS（清除发送，允许发送的条件已经清除）：箭头方向是由外向内的，和发送控制器相连。对方可以通过拉高该引脚来告知当前串口在完成当前传输后停止数据的发送（对方接收不过来了）</li>
</ul>
<h3 id="ying-jian-liu-kong-zhi-liu-cheng">硬件流控制流程：</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128204540542.png" alt="image-20241128204540542"></p>
<p>下面以串口A要给串口B发送数据为例：</p>
<ul>
<li>串口A要给B发送数据时，首先会通过A的CTS读取B的RTS状态，如果B可以接收数据，那么B会拉低RTS（请求发送），该低电平状态在A需要发送数据时可以通过CTS读取到：
<ul>
<li>读到CTS为高，那么说明B拉高了RTS（对方忙碌）；如果读到CTS为低，那么说明B拉低了RTS（对方空闲）</li>
</ul>
</li>
<li>A通过CTS读到低电平后，就开始向B发送数据了，如果某一时刻发现CTS被拉高了，说明B处理不过来了，因此会在当前帧传输完后停止后续数据的发送，当B重新将RTS置为低电平时继续传输剩余帧，重复这一个过程直到所有帧传输完成。</li>
</ul>
<h2 id="ck-yin-jiao">CK引脚</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128204932608.png" alt="image-20241128204932608"></p>
<p>该引脚在同步传输模式下用于时钟信号的传输。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128205127278.png" alt="image-20241128205127278"></p>
<p>其中UART4和UART5是不支持同步模式的。</p>
<h1 id="usart-shu-ju-zheng-fen-xi">USART数据帧分析</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128205612552.png" alt="image-20241128205612552"></p>
<h2 id="shu-ju-wei-zi-chang">数据位字长</h2>
<blockquote>
<p>Word length may be selected as being either 8 or 9 bits by programming the M bit in the USART_CR1 register (see Figure 280).</p>
</blockquote>
<p>字长可以选择8bit或9bit，可以通过USART_CR1寄存器中的M位来设置：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128205946525.png" alt="image-20241128205946525"></p>
<h2 id="qi-shi-wei-he-ting-zhi-wei">起始位和停止位</h2>
<blockquote>
<p>The TX pin is in low state during the start bit. It is in high state during the stop bit</p>
</blockquote>
<p>发送引脚在起始位保持低电平，在停止位保持高电平</p>
<h2 id="kong-xian-zheng">空闲帧</h2>
<blockquote>
<p>An Idle character is interpreted as an entire frame of “1”s followed by the start bit of the next frame which contains data (The number of “1” ‘s will include the number of stop bits).</p>
</blockquote>
<p>空闲帧是指比特位全为1的帧，帧的长度包括起始比特位、字长、停止位（对应比特位数量不固定）</p>
<h2 id="bo-te-lu-he-shi-zhong">波特率和时钟</h2>
<blockquote>
<p>Transmission and reception are driven by a common baud rate generator, the clock for each is generated when the enable bit is set respectively for the transmitter and receiver.</p>
</blockquote>
<p>发送和接收是由一个通用的波特率发生器来驱动的，</p>
<h1 id="fa-song-qi">发送器</h1>
<h2 id="di-wei-you-xian-amp-di-ceng-fa-song-liu-cheng">低位优先&amp;底层发送流程</h2>
<blockquote>
<p>[!IMPORTANT]</p>
<p>During a USART transmission, data shifts out least significant bit first on the TX pin.</p>
<p>In thismode, the USART_DR register consists of a buffer (TDR) between the internal bus and the transmit shift register (see Figure 279)</p>
</blockquote>
<p>在一次USART传输中，数据通过TX引脚低位优先移位发送出去的。在这个场景下，USART_DR表现为一个位于内部总线和移位寄存器之间的发送缓冲区（TDR），写入USART_DR的数据会先被写入TDR，然后在硬件的支持下通过移位寄存器逐位发送出去。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128212821427.png" alt="image-20241128212821427"></p>
<h2 id="ke-pei-zhi-de-ting-zhi-wei-kuan-du">可配置的停止位宽度</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128213716372.png" alt="image-20241128213716372"></p>
<p>停止位默认占一个bit，可以通过USART_CR2寄存器配置为其他的比特位宽，以支持不同的串口通信模式（例如单线、调制解调器、智能卡等）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128213822036.png" alt="image-20241128213822036"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128214412870.png" alt="image-20241128214412870"></p>
<h2 id="txe-biao-zhi-chuan-shu-huan-chong-qu-wei-kong">TXE标志（传输缓冲区为空）</h2>
<blockquote>
<p>The TXE bit is always cleared by a write to the data register.The TXE bit is set by hardware and it indicates:<br>
 The data has been moved from TDR to the shift register and the data transmission has<br>
started.<br>
 The TDR register is empty.<br>
 The next data can be written in the USART_DR register without overwriting the<br>
previous data.</p>
<p>This flag generates an interrupt if the TXEIE bit is set.</p>
</blockquote>
<p>USART_SR寄存器中TXE标志（Tranmist Buffer Empty）总是由一个写USART_DR 寄存器的操作来清除的。TXE由硬件置位，用于指示：</p>
<ul>
<li>数据已经从TDR传送到了移位寄存器并且该数据的发送已经开始</li>
<li>TDR寄存器为空</li>
<li>可以将写一个数据写入USART_DR寄存器，并且先前写入的数据不会被覆盖（可能正在通过移位寄存器逐位发送，也可能已经发送完毕）</li>
</ul>
<p>该标志被置位时会产生一个TXEIE中断（如果使能了该中断）。</p>
<blockquote>
<p>When a transmission is taking place, a write instruction to the USART_DR register stores the data in the TDR register and which is copied in the shift register at the end of the current transmission</p>
</blockquote>
<p>当正在进行一个数据的发送时，向USART_DR写入数据会将数据存储到TDR寄存器中，并在当前传输结束后将其拷贝到移位寄存器中。</p>
<blockquote>
<p>When no transmission is taking place, a write instruction to the USART_DR register places the data directly in the shift register, the data transmission starts, and the TXE bit is immediately set.</p>
</blockquote>
<p>如果当前没有发送数据，向USART_DR写入数据会直接将数据放到移位寄存器中，并且开始该数据的传输，同时TXE会被置位。</p>
<h2 id="tc-biao-zhi-ying-jian-chuan-shu-wan-cheng-amp-chuan-shu-huan-chong-qu-wei-kong">TC标志（硬件传输完成&amp;传输缓冲区为空）</h2>
<blockquote>
<p>If a frame is transmitted (after the stop bit) and the TXE bit is set, the TC bit goes high. An interrupt is generated if the TCIE bit is set in the USART_CR1 register.</p>
</blockquote>
<p>如果一个数据帧传输完成（包括停止位）并且TXE被置位，此时表明了两点：</p>
<ul>
<li>硬件没有正在通过移位寄存器传输数据</li>
<li>TDR缓冲区也没有带发送的数据</li>
</ul>
<p>此时，TC标志会被置位，同时产生一个TCIE中断（如果使能了该中断）。这通常标志着一连串数据发送的完成。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128221900956.png" alt="image-20241128221900956"></p>
<blockquote>
<p>[!WARNING]</p>
<p>After writing the last data into the USART_DR register, it is mandatory to wait for TC=1 before disabling the USART or causing the microcontroller to enter the low-power mode</p>
</blockquote>
<p>在写入最后一个数据到DR寄存器后，如果要禁用USART或使MCU进入低功耗模式之前，应该要等TC被置位，这样才能确保底层的硬件真的将所有递交到DR的数据发送出去了。</p>
<blockquote>
<p>The TC bit is cleared by the following software sequence:</p>
<ol>
<li>A read from the USART_SR register</li>
<li>A write to the USART_DR register</li>
</ol>
</blockquote>
<p>TC标志会被如下的软件操作序列清除：</p>
<ol>
<li>读USART_SR寄存器</li>
<li>写USART_DR 寄存器</li>
</ol>
<p>例如我们需要一次性发送多个数据帧，会使用如下轮询的方式：</p>
<ol>
<li>等待USART_SR中的TXE被置位（需要轮询读取USART_SR中的TXE位并判断）</li>
<li>TXE被置位后，向DR递交下一个待发送的数据</li>
</ol>
<h2 id="kong-xian-zheng-1">空闲帧</h2>
<blockquote>
<p>Setting the TE bit drives the USART to send an idle frame before the first data frame.</p>
</blockquote>
<p><strong>TE bit</strong> 是 <strong>USART_CR1</strong>（USART控制寄存器1）中的一个控制位，全称为 <strong>Transmitter Enable</strong>，其作用是启用 USART 的发送功能。具体来说，设置 <strong>TE bit</strong> 会使 USART 进入发送模式，并且在开始传输第一个数据帧之前，它会先发送一个空闲帧（idle frame）。</p>
<h3 id="strong-shi-yao-shi-kong-xian-zheng-idle-frame-strong"><strong>什么是空闲帧（Idle Frame）？</strong></h3>
<p>空闲帧指的是一种 <strong>没有有效数据</strong> 的帧，通常它是由逻辑 <strong>“1”</strong> 组成的。在 USART 中，这个空闲帧起到 <strong>信号稳定</strong> 和 <strong>传输准备</strong> 的作用。空闲帧的存在确保了接收端能够正确同步到即将开始的有效数据传输。</p>
<h3 id="strong-ju-ti-gong-zuo-yuan-li-strong"><strong>具体工作原理</strong></h3>
<ol>
<li><strong>设置 TE 位</strong>：当你通过软件设置 <strong>TE bit</strong>（即 <strong>Transmitter Enable</strong> 位）时，USART 将被启用为 <strong>发送模式</strong>，并准备开始传输数据。</li>
<li><strong>发送空闲帧</strong>：在开始传输数据之前，USART 会首先发送一个 <strong>空闲帧</strong>（一个全为“1”的逻辑帧），这个空闲帧可以被视为“开始”信号，告诉接收方接下来会有数据传输。</li>
<li><strong>发送数据帧</strong>：一旦空闲帧发送完成，USART 就开始传输第一个有效的数据帧。</li>
</ol>
<h3 id="strong-wei-shi-yao-yao-fa-song-kong-xian-zheng-strong"><strong>为什么要发送空闲帧？</strong></h3>
<ul>
<li><strong>同步作用</strong>：在某些情况下，接收设备需要一定的时间来同步到发送设备的时钟。空闲帧为接收端提供了同步的信号，确保接收设备能够准备好接收即将传输的数据。</li>
<li><strong>信号稳定</strong>：在数据传输开始之前，空闲帧有助于确保信号线处于稳定状态，以便接收设备能够准确地捕获数据。</li>
<li><strong>时序准备</strong>：通过发送空闲帧，发送器给接收器一个明确的指示，表明接下来的数据是有效的，而不是噪声或无效数据。</li>
</ul>
<h1 id="jie-shou-qi">接收器</h1>
<blockquote>
<p>The USART can receive data words of either 8 or 9 bits depending on the M bit in the USART_CR1 register.</p>
</blockquote>
<p>USRAT可以接收8或9个bit字长的数据，这取决于USART_CR1中M位的配置。</p>
<h2 id="qi-shi-wei-jian-ce">起始位检测</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129091530313.png" alt="image-20241129091530313"></p>
<blockquote>
<p>In the USART, the start bit is detected when a specific sequence of samples is recognized. This sequence is: 1 1 1 0 X 0 X 0 X 0 0 0 0.</p>
<p>If the sequence is not complete, the start bit detection aborts and the receiver returns to the<br>
idle state (no flag is set) where it waits for a falling edge.</p>
</blockquote>
<p>在USART中，如果识别到 <code>1 1 1 0 X 0 X 0 X 0 0 0 0</code>模式的特定采样序列（X表示不关心是0还是1），则表明检测到一个有效起始位。（<code>1 1 1 0</code>表明产生了一个下降沿，其中 <code>0</code>可能是一个数据帧的起始位）</p>
<p>如果发生下降沿时得到的采样序列和上述模式相比不完整，那么该起始位会被丢弃，并且接收器返回到空闲状态继续等待下降沿。</p>
<blockquote>
<p>The start bit is confirmed (RXNE flag set, interrupt generated if RXNEIE=1) if the 3 sampled bits are at 0 (first sampling on the 3rd, 5th and 7th bits finds the 3 bits at 0 and second sampling on the 8th, 9th and 10th bits also finds the 3 bits at 0).</p>
</blockquote>
<p>如图，USART通过过采样（波特率的16倍）在一个bit时间内进行了16次采样，如果将下降沿序列（ <code>1 1 1 0</code>）中的 <code>0</code>作为一个起始位中的第一个样本点，那么如果随后的第3、5、7样本点为0，且第8、9、10样本点为0，那么该起始位被确认为有效起始位，RXNE标志（接收缓冲区不为空，RDR有数据可读）会被置位，并且产生RXNEIE中断（如果使能了该中断）</p>
<blockquote>
<p>[!IMPORTANT]</p>
<p>这里值得注意的是：实际上RXNE置位应该是在硬件完成数据的传输之后（数据通过硬件传入移位寄存器并递交到RDR寄存器）</p>
</blockquote>
<blockquote>
<p>The start bit is validated (RXNE flag set, interrupt generated if RXNEIE=1) but the NE noise flag is set if, for both samplings, at least 2 out of the 3 sampled bits are at 0 (sampling on the 3rd, 5th and 7th bits and sampling on the 8th, 9th and 10th bits). If this condition is not met, the start detection aborts and the receiver returns to the idle state (no flag is set).</p>
</blockquote>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129093604361.png" alt="image-20241129093604361" style="zoom:50%;">
<h2 id="shu-ju-zheng-de-jie-shou">数据帧的接收</h2>
<blockquote>
<p>During a USART reception, data shifts in least significant bit first through the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) between the internal bus and the<br>
received shift register.</p>
</blockquote>
<p>在一个USART数据帧接收过程中，数据以LSB低位优先模式传输到RX引脚。在这个场景下，USART_DR寄存器表现为位于内部总线和移位寄存器之间的接收缓冲区（RDR，Receive Data Register）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129094459395.png" alt="image-20241129094459395"></p>
<blockquote>
<p>Procedure:</p>
<ol>
<li>Enable the USART by writing the UE bit in USART_CR1 register to 1.</li>
<li>Program the M bit in USART_CR1 to define the word length.</li>
<li>Program the number of stop bits in USART_CR2.</li>
<li>Select DMA enable (DMAR) in USART_CR3 if multibuffer communication is to take<br>
place. Configure the DMA register as explained in multibuffer communication. STEP 3</li>
<li>Select the desired baud rate using the baud rate register USART_BRR</li>
<li>Set the RE bit USART_CR1. This enables the receiver which begins searching for a<br>
start bit.</li>
</ol>
</blockquote>
<p>接收程序如下：</p>
<ol>
<li>启用USART：设置USART_CR1中的UE为1</li>
<li>通过USART_CR1中的M设置字长</li>
<li>通过USART_CR2设置停止位占用的bit数量</li>
<li>多缓冲DMA相关</li>
<li>通过USART_BRR选择期望的波特率</li>
<li>通过USART_CR1的RE启用接收器</li>
</ol>
<blockquote>
<p>When a character is received<br>
 The RXNE bit is set. It indicates that the content of the shift register is transferred to the<br>
RDR. In other words, data has been received and can be read (as well as its<br>
associated error flags).<br>
 An interrupt is generated if the RXNEIE bit is set.<br>
 The error flags can be set if a frame error, noise or an overrun error has been detected<br>
during reception.<br>
 In multibuffer, RXNE is set after every byte received and is cleared by the DMA read to<br>
the Data register.<br>
 In single buffer mode, clearing the RXNE bit is performed by a software read to the<br>
USART_DR register. The RXNE flag can also be cleared by writing a zero to it. The<br>
RXNE bit must be cleared before the end of the reception of the next character to avoid<br>
an overrun error.</p>
</blockquote>
<p>当收到了一个数据帧后：</p>
<ul>
<li>RXNE会被置位：有数据被传输到了RDR中，可以通过DR来读取它</li>
<li>产生RXNEIE中断（如果使能了该中断）</li>
<li>如果接收过程中发生了帧错误、噪声错误、缓冲区溢出错误，状态寄存器USART_SR中的相关错误标志位会被设置</li>
<li>在多缓冲DMA中，RXNE在每个字节接收完成后由DMA的读DR操作来清除</li>
<li>单缓冲模式下，RXNE的清除可由软件的读DR操作来清除，也可以通过向RXNE写0来清除。<mark>RXNE必须要在下一个数据帧接收完成之前被清除，以避免产生缓冲区溢出错误</mark></li>
</ul>
<blockquote>
<p>[!IMPORTANT]</p>
<p>这里值得注意的是：如何确保在下一个数据帧之前清除RXNE？</p>
</blockquote>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129100957026.png" alt="image-20241129100957026" style="zoom:50%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129101031527.png" alt="image-20241129101031527" style="zoom:50%;">
<h2 id="kong-xian-zheng-2">空闲帧</h2>
<blockquote>
<p>When an idle frame is detected, there is the same procedure as a data received character plus an interrupt if the IDLEIE bit is set.</p>
</blockquote>
<p>当检测到空闲帧（<mark>注意这里是指跟在数据帧后的第一个空闲帧</mark>）时，硬件会执行与接收到一个数据帧类似的流程（参考上一节）：</p>
<ol>
<li>设置USART_SR 寄存器的 <strong>IDLE（空闲帧检测）</strong> 标志位（接收到数据帧则是设置RXNE标志位）。</li>
<li>如果 <strong>IDLEIE 位=1</strong>（空闲帧中断使能），会触发中断。</li>
</ol>
<p>但是，<strong>空闲帧</strong>不会影响接收数据缓冲区的内容，因此不会产生 RXNE 标志，也不会修改接收数据寄存器（RDR）。</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129193651750.png" alt="image-20241129193651750"></p>
<blockquote>
<p>It is cleared by a software sequence (an read to the USART_SR register followed by a read to the USART_DR register).</p>
</blockquote>
<p>这里值得注意的是，IDLE标志位可以通过如下软件操作序列来清除：</p>
<ol>
<li>读USART_SR寄存器（例如轮询IDLE标志位）</li>
<li>读USART_DR（例如轮询到IDLE被置后，执行一个USART_DR读到的空操作）</li>
</ol>
<blockquote>
<p>[!NOTE]</p>
<p>Note: The IDLE bit will not be set again until the RXNE bit has been set itself (i.e. a new idle<br>
line occurs).</p>
<p>这里需要注意的是，在RXNE被置位后（接收到了数据）如果检测到了空闲帧才会将IDLE置位，并且如果有多个空闲帧不会多次将IDLE置位，即每次接收数据后的第一个空闲帧（指示一次不定长数据传输已经完成）才会置位IDLE</p>
</blockquote>
<h1 id="bo-te-lu-she-zhi">波特率设置</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129105108831.png" alt="image-20241129105108831"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129102353746.png" alt="image-20241129102353746"></p>
<p>接收器和发送器的波特率由外设时钟f<sub>CK</sub>和可编程的USART分频参数USARTDIV来计算。</p>
<p>其中USARTDIV又可以通过波特率配置寄存器USART_BRR中的DIV_Mantissa（配置USARTDIV的整数部分）和DIV_Fraction  （配置USARTDIV的小数部分，通过DIV_Fraction/16来计算对应的小数）</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129102223806.png" alt="image-20241129102223806"></p>
<h1 id="xiao-yan-kong-zhi">校验控制</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128210319460.png" alt="image-20241128210319460"></p>
<blockquote>
<p>[!NOTE]</p>
<p>校验位是包含在字长里面的，作为字长的最后一个bit</p>
</blockquote>
<p>可以通过如下寄存器配置是否开启校验位，以及选择奇偶校验模式</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128210525491.png" alt="image-20241128210525491"></p>
<h1 id="lun-xun-fang-shi-shou-fa-dan-zi-jie-shi-jian">轮询方式收发单字节实践</h1>
<h2 id="yuan-li-tu">原理图</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129103540732.png" alt="image-20241129103540732"></p>
<h2 id="shi-neng-shi-zhong">使能时钟</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129111334989.png" alt="image-20241129111334989"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129111749460.png" alt="image-20241129111749460"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// enable clock</span>
RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_IOPAEN<span class="token punctuation">;</span>
RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_AFIOEN<span class="token punctuation">;</span>
RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_USART1EN<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="gpio-pei-zhi">GPIO配置</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129104039053.png" alt="image-20241129104039053"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// GPIO CONFIG</span>
    <span class="token comment">// PA9 TX  alternate pp output</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_MODE9<span class="token punctuation">;</span>   <span class="token comment">// output</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF9_1<span class="token punctuation">;</span>   <span class="token comment">// alternate pp</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF9_0<span class="token punctuation">;</span>
    <span class="token comment">// PA10 RX alternate float input</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_MODE10<span class="token punctuation">;</span>   <span class="token comment">// input mode</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF10_1<span class="token punctuation">;</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF10_0<span class="token punctuation">;</span>   <span class="token comment">// float input</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="afio-pei-zhi">AFIO配置</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129104211418.png" alt="image-20241129104211418"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129104116889.png" alt="image-20241129104116889"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129114655724.png" alt="image-20241129114655724"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// AFIO CONFIG</span>
    AFIO<span class="token operator">-&gt;</span>MAPR <span class="token operator">&amp;=</span> <span class="token operator">~</span>AFIO_MAPR_USART1_REMAP<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="usart-pei-zhi">USART配置</h2>
<h3 id="bo-te-lu-pei-zhi">波特率配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129104313401.png" alt="image-20241129104313401"></p>
<p>如果我们想得到115200的波特率，以72M外设时钟为例计算USARTDIV：<code>72000000/(16 * 115200) = 39.0625</code></p>
<p>因此整数部分可以配置为 <code>0x27</code>（39），小数部分可以配置为 <code>0x1</code>（1/16=0.625）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// baud rate</span>
 USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_BRR_DIV_Mantissa<span class="token punctuation">;</span>
 USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_BRR_DIV_Fraction<span class="token punctuation">;</span>
 USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x27</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>进一步可以优化为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">=</span> <span class="token number">0x271</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="usart-kong-zhi-qi-pei-zhi">USART控制器配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129105601999.png" alt="image-20241129105601999"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129110700834.png" alt="image-20241129110700834"></p>
<h3 id="shu-ju-zheng-xiang-guan">数据帧相关</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129110611145.png" alt="image-20241129110611145"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// data frame</span>
   USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR1_M<span class="token punctuation">;</span>   <span class="token comment">// 8 bit word length</span>
   USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR1_PCE<span class="token punctuation">;</span> <span class="token comment">// diable parity</span>
   USART1<span class="token operator">-&gt;</span>CR2 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR2_STOP<span class="token punctuation">;</span> <span class="token comment">// 1 stop bit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="shi-neng-xiang-guan">使能相关</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129110403540.png" alt="image-20241129110403540"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// enable</span>
USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">|=</span> <span class="token punctuation">(</span>USART_CR1_UE <span class="token operator">|</span> USART_CR1_RE <span class="token operator">|</span> USART_CR1_TE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="lun-xun-shou-fa">轮询收发</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uart_send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// waits until transmit buffer is empty</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_TXE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    USART1<span class="token operator">-&gt;</span>DR <span class="token operator">=</span> byte<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">uint8_t</span> <span class="token function">uart_receive_byte</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// waits until receive buffer is not empty</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">return</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="wan-zheng-dai-ma">完整代码</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__UART_H__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__UART_H__</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span>

<span class="token keyword">void</span> <span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">uart_send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">uint8_t</span> <span class="token function">uart_receive_byte</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* __UART_H__ */</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"uart.h"</span></span>

<span class="token keyword">void</span> <span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// enable clock</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_IOPAEN<span class="token punctuation">;</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_AFIOEN<span class="token punctuation">;</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_USART1EN<span class="token punctuation">;</span>

    <span class="token comment">// GPIO CONFIG</span>
    <span class="token comment">// PA9 TX  alternate pp output</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_MODE9<span class="token punctuation">;</span>   <span class="token comment">// output</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF9_1<span class="token punctuation">;</span>   <span class="token comment">// alternate pp</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF9_0<span class="token punctuation">;</span>
    <span class="token comment">// PA10 RX alternate float input</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_MODE10<span class="token punctuation">;</span>   <span class="token comment">// input mode</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF10_1<span class="token punctuation">;</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF10_0<span class="token punctuation">;</span>   <span class="token comment">// float input</span>

    <span class="token comment">// AFIO CONFIG</span>
    AFIO<span class="token operator">-&gt;</span>MAPR <span class="token operator">&amp;=</span> <span class="token operator">~</span>AFIO_MAPR_USART1_REMAP<span class="token punctuation">;</span>

    <span class="token comment">// USART CONFIG</span>
    <span class="token comment">// baud rate</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_BRR_DIV_Mantissa<span class="token punctuation">;</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_BRR_DIV_Fraction<span class="token punctuation">;</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x27</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//USART1-&gt;BRR = 0x271;</span>
    <span class="token comment">// data frame</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR1_M<span class="token punctuation">;</span>   <span class="token comment">// 8 bit word length</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR1_PCE<span class="token punctuation">;</span> <span class="token comment">// diable parity</span>
    USART1<span class="token operator">-&gt;</span>CR2 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR2_STOP<span class="token punctuation">;</span> <span class="token comment">// 1 stop bit</span>
    <span class="token comment">// enable</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">|=</span> <span class="token punctuation">(</span>USART_CR1_UE <span class="token operator">|</span> USART_CR1_RE <span class="token operator">|</span> USART_CR1_TE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">uart_send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// waits until transmit buffer is empty</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_TXE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    USART1<span class="token operator">-&gt;</span>DR <span class="token operator">=</span> byte<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">uint8_t</span> <span class="token function">uart_receive_byte</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// waits until receive buffer is not empty</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">return</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">uart_send_byte</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="lun-xun-fang-shi-shou-fa-duo-zi-jie-shi-jian">轮询方式收发多字节实践</h1>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uart_send_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> bytes<span class="token punctuation">,</span> u16 size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>u16 i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">uart_send_byte</span><span class="token punctuation">(</span>bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">uart_receive_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> bytes_buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span><span class="token operator">*</span> sizebuf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
                <span class="token operator">*</span>sizebuf <span class="token operator">=</span> i<span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        bytes_buf<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里既要通过轮询来检测RXNE从而实现多字节的读取，又要轮询IDLE来实现在检测到空闲帧后（发送方发送完了最后一个字节）终止轮询读取的逻辑。</p>
<blockquote>
<p>[!NOTE]</p>
<p>这里在检测到IDLE标志位（通过读USART1-&gt;SR）后，追加了一个USART1-&gt;DR读操作，这是为了遵循手册对于IDLE标志位描述中的规范：</p>
<p>It is cleared by a software sequence (an read to theUSART_SR register followed by a read to the USART_DR register).</p>
</blockquote>
<p>值得注意的是，<mark>轮询RXNE和IDLE应该配合使用</mark>，如下代码试图通过在每次从DR读取到一个字节后检测一次IDLE，如果IDLE刚好在这个 <code>if (USART1-&gt;SR &amp; USART_SR_IDLE) </code>执行后被置位，那么程序就会卡在第4行</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uart_receive_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> bytes_buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span><span class="token operator">*</span> sizebuf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        bytes_buf<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
            <span class="token operator">*</span>sizebuf <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>[!WARNING]</p>
<p>可以发现，对于硬件置位的标志位（例如RXNE、IDLE），应该不断轮询去检测，而不要期望在某个时机检测仅仅一次。</p>
<p>例如上述程序期望在收到最后一个字节后通过一次 <code>if</code>判断来检测IDLE，虽然对于接收最后一个字节而言，IDLE置位确实发生在 <code>bytes_buf[i++] = USART1-&gt;DR</code>之后，但是程序的执行速度是很快的，而空闲帧的检测需要硬件检测到一个帧长的所有bit全为1时才会将IDLE置1。因此上述程序中的 <code>if (USART1-&gt;SR &amp; USART_SR_IDLE)</code> 并不能在接收完最后一个字节后如期检测到IDLE被置位，接着又回到了 <code>while ((USART1-&gt;SR &amp; USART_SR_RXNE) == 0)</code>空转无法跳出。</p>
</blockquote>
<p>因此如下代码将RXNE和IDLE的轮询结合到了一起，在RXNE被置位时执行数据的读取 <code>bytes_buf[i++] = USART1-&gt;DR</code>，在IDLE被置位时执行函数的返回</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uart_receive_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> bytes_buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span><span class="token operator">*</span> sizebuf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
                <span class="token operator">*</span>sizebuf <span class="token operator">=</span> i<span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        bytes_buf<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="you-hua">优化</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint8_t</span> <span class="token function">uart_receive_byte</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// waits until receive buffer is not empty</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 如果检测到了空闲帧则停止接收数据</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">uart_receive_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> bytes_buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span><span class="token operator">*</span> sizebuf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*     uint16_t i = 0;
    while (1) {
        while ((USART1-&gt;SR &amp; USART_SR_RXNE) == 0) {
            if (USART1-&gt;SR &amp; USART_SR_IDLE) {
                USART1-&gt;DR;
                *sizebuf = i;
                return;
            }
        }
        bytes_buf[i++] = USART1-&gt;DR;
    } */</span>
    <span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果没有检测到空闲帧，则轮询接收数据</span>
        bytes_buf<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uart_receive_byte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span> <span class="token comment">// 通过USART_SR读操作之后跟随一个USART_DR读来清除IDLE标志</span>
    <span class="token operator">*</span>sizebuf <span class="token operator">=</span> <span class="token operator">--</span>i<span class="token punctuation">;</span> <span class="token comment">// uart_receive_byte返回的最后一个字节是因为空闲帧返回的无效数据</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="zai-kan-txe-tc-rxne-idel-qing-chu-luo-ji">再看TXE/TC、RXNE、IDEL清除逻辑</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129220628220.png" alt="image-20241129220628220"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129220926870.png" alt="image-20241129220926870"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129221419149.png" alt="image-20241129221419149"></p>
<blockquote>
<p>[!NOTE]</p>
<p>这里需要注意的是，在RXNE被置位后（接收到了数据）如果检测到了空闲帧才会将IDLE置位，并且如果有多个空闲帧不会多次将IDLE置位，即每次接收数据后的第一个空闲帧（指示一次不定长数据传输已经完成）才会置位IDLE</p>
</blockquote>
<h2 id="wan-zheng-dai-ma-1">完整代码</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"uart.h"</span></span>

<span class="token keyword">void</span> <span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// enable clock</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_IOPAEN<span class="token punctuation">;</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_AFIOEN<span class="token punctuation">;</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_USART1EN<span class="token punctuation">;</span>

    <span class="token comment">// GPIO CONFIG</span>
    <span class="token comment">// PA9 TX  alternate pp output</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_MODE9<span class="token punctuation">;</span>   <span class="token comment">// output</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF9_1<span class="token punctuation">;</span>   <span class="token comment">// alternate pp</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF9_0<span class="token punctuation">;</span>
    <span class="token comment">// PA10 RX alternate float input</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_MODE10<span class="token punctuation">;</span>   <span class="token comment">// input mode</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF10_1<span class="token punctuation">;</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF10_0<span class="token punctuation">;</span>   <span class="token comment">// float input</span>

    <span class="token comment">// AFIO CONFIG</span>
    AFIO<span class="token operator">-&gt;</span>MAPR <span class="token operator">&amp;=</span> <span class="token operator">~</span>AFIO_MAPR_USART1_REMAP<span class="token punctuation">;</span>

    <span class="token comment">// USART CONFIG</span>
    <span class="token comment">// baud rate</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_BRR_DIV_Mantissa<span class="token punctuation">;</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_BRR_DIV_Fraction<span class="token punctuation">;</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x27</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//USART1-&gt;BRR = 0x271;</span>
    <span class="token comment">// data frame</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR1_M<span class="token punctuation">;</span>   <span class="token comment">// 8 bit word length</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR1_PCE<span class="token punctuation">;</span>   <span class="token comment">// diable parity</span>
    USART1<span class="token operator">-&gt;</span>CR2 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR2_STOP<span class="token punctuation">;</span>   <span class="token comment">// 1 stop bit</span>
    <span class="token comment">// enable</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">|=</span> <span class="token punctuation">(</span>USART_CR1_UE <span class="token operator">|</span> USART_CR1_RE <span class="token operator">|</span> USART_CR1_TE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">uart_send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// waits until transmit buffer is empty</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_TXE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    USART1<span class="token operator">-&gt;</span>DR <span class="token operator">=</span> byte<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">uint8_t</span> <span class="token function">uart_receive_byte</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// waits until receive buffer is not empty</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 如果检测到了空闲帧则停止接收数据</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">uart_send_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> bytes<span class="token punctuation">,</span> u16 size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>u16 i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">uart_send_byte</span><span class="token punctuation">(</span>bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">uart_receive_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> bytes_buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span><span class="token operator">*</span> sizebuf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*     uint16_t i = 0;
    while (1) {
        while ((USART1-&gt;SR &amp; USART_SR_RXNE) == 0) {
            if (USART1-&gt;SR &amp; USART_SR_IDLE) {
                USART1-&gt;DR;
                *sizebuf = i;
                return;
            }
        }
        bytes_buf[i++] = USART1-&gt;DR;
    } */</span>
    <span class="token class-name">uint16_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果没有检测到空闲帧，则轮询接收数据</span>
        bytes_buf<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">uart_receive_byte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span> <span class="token comment">// 通过USART_SR读操作之后跟随一个USART_DR读来清除IDLE标志</span>
    <span class="token operator">*</span>sizebuf <span class="token operator">=</span> <span class="token operator">--</span>i<span class="token punctuation">;</span> <span class="token comment">// uart_receive_byte返回的最后一个字节是因为空闲帧返回的无效数据</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="zhong-duan-fang-shi-jie-shou-dan-zi-jie-he-bian-chang-shu-ju">中断方式接收单字节和变长数据</h1>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129223248999.png" alt="image-20241129223248999"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129223318399.png" alt="image-20241129223318399"></p>
<h2 id="shi-neng-zhong-duan">使能中断</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241129223405148.png" alt="image-20241129223405148"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// interrupt config</span>
   USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">|=</span> USART_CR1_RXNEIE<span class="token punctuation">;</span>
   USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">|=</span> USART_CR1_IDLEIE<span class="token punctuation">;</span>
   <span class="token function">NVIC_SetPriorityGrouping</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// only group priority</span>
   <span class="token function">NVIC_SetPriority</span><span class="token punctuation">(</span>USART1_IRQn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">NVIC_EnableIRQ</span><span class="token punctuation">(</span>USART1_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ding-yi-zhong-duan-chu-li-han-shu">定义中断处理函数</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint8_t</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">uint8_t</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

__weak <span class="token keyword">void</span> <span class="token function">uart1_received_callback</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        buffer<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span> <span class="token comment">// dummy read for clearing IDLE flag</span>
        <span class="token function">uart1_received_callback</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="shi-yong-fang-zhong-xie-hui-diao-han-shu">使用方重写回调函数</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uart1_received_callback</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">uart_send_bytes</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//uart_send_byte('a');</span>
    <span class="token class-name">uint8_t</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"hello world!\n"</span><span class="token punctuation">;</span>
    <span class="token function">uart_send_bytes</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="wan-zheng-dai-ma-2">完整代码</h2>
<p><code>uart.h</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__UART_H__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__UART_H__</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f10x.h"</span></span>

<span class="token keyword">void</span> <span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">uart_send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">uart_send_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>bytes<span class="token punctuation">,</span> u16 size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">uart1_received_callback</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* __UART_H__ */</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>uart.c</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"uart.h"</span></span>

<span class="token keyword">void</span> <span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// enable clock</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_IOPAEN<span class="token punctuation">;</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_AFIOEN<span class="token punctuation">;</span>
    RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|=</span> RCC_APB2ENR_USART1EN<span class="token punctuation">;</span>

    <span class="token comment">// GPIO CONFIG</span>
    <span class="token comment">// PA9 TX  alternate pp output</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_MODE9<span class="token punctuation">;</span>   <span class="token comment">// output</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF9_1<span class="token punctuation">;</span>   <span class="token comment">// alternate pp</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF9_0<span class="token punctuation">;</span>
    <span class="token comment">// PA10 RX alternate float input</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_MODE10<span class="token punctuation">;</span>   <span class="token comment">// input mode</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">&amp;=</span> <span class="token operator">~</span>GPIO_CRH_CNF10_1<span class="token punctuation">;</span>
    GPIOA<span class="token operator">-&gt;</span>CRH <span class="token operator">|=</span> GPIO_CRH_CNF10_0<span class="token punctuation">;</span>   <span class="token comment">// float input</span>

    <span class="token comment">// AFIO CONFIG</span>
    AFIO<span class="token operator">-&gt;</span>MAPR <span class="token operator">&amp;=</span> <span class="token operator">~</span>AFIO_MAPR_USART1_REMAP<span class="token punctuation">;</span>

    <span class="token comment">// USART CONFIG</span>
    <span class="token comment">// baud rate</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_BRR_DIV_Mantissa<span class="token punctuation">;</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_BRR_DIV_Fraction<span class="token punctuation">;</span>
    USART1<span class="token operator">-&gt;</span>BRR <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">0x27</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//USART1-&gt;BRR = 0x271;</span>
    <span class="token comment">// data frame</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR1_M<span class="token punctuation">;</span>   <span class="token comment">// 8 bit word length</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR1_PCE<span class="token punctuation">;</span>   <span class="token comment">// diable parity</span>
    USART1<span class="token operator">-&gt;</span>CR2 <span class="token operator">&amp;=</span> <span class="token operator">~</span>USART_CR2_STOP<span class="token punctuation">;</span>   <span class="token comment">// 1 stop bit</span>
    <span class="token comment">// enable</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">|=</span> <span class="token punctuation">(</span>USART_CR1_UE <span class="token operator">|</span> USART_CR1_RE <span class="token operator">|</span> USART_CR1_TE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// interrupt config</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">|=</span> USART_CR1_RXNEIE<span class="token punctuation">;</span>
    USART1<span class="token operator">-&gt;</span>CR1 <span class="token operator">|=</span> USART_CR1_IDLEIE<span class="token punctuation">;</span>
    <span class="token function">NVIC_SetPriorityGrouping</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// only group priority</span>
    <span class="token function">NVIC_SetPriority</span><span class="token punctuation">(</span>USART1_IRQn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">NVIC_EnableIRQ</span><span class="token punctuation">(</span>USART1_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">uint8_t</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">uint8_t</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        buffer<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_IDLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        USART1<span class="token operator">-&gt;</span>DR<span class="token punctuation">;</span> <span class="token comment">// dummy read for clearing IDLE flag</span>
        <span class="token function">uart1_received_callback</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

__weak <span class="token keyword">void</span> <span class="token function">uart1_received_callback</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">uart_send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// waits until transmit buffer is empty</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>USART1<span class="token operator">-&gt;</span>SR <span class="token operator">&amp;</span> USART_SR_TXE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    USART1<span class="token operator">-&gt;</span>DR <span class="token operator">=</span> byte<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">uart_send_bytes</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span> bytes<span class="token punctuation">,</span> u16 size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>u16 i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">uart_send_byte</span><span class="token punctuation">(</span>bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>main.c</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uart1_received_callback</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">uart_send_bytes</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">uart_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//uart_send_byte('a');</span>
    <span class="token class-name">uint8_t</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"hello world!\n"</span><span class="token punctuation">;</span>
    <span class="token function">uart_send_bytes</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="stm-32-cube-mx-hal-ku-shi-jian">STM32CubeMX/HAL库实践</h1>
<h2 id="lun-xun-fang-shi-shou-fa-ding-chang-shu-ju">轮询方式收发定长数据</h2>
<h3 id="cube-pei-zhi-qi-yong-usart-xiang-guan-de-gpio-hui-bei-zi-dong-pei-zhi">Cube配置启用USART，相关的GPIO会被自动配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130085637544.png" alt="image-20241130085637544"></p>
<h3 id="afio-zhong-ying-she-wen-ti">AFIO重映射问题</h3>
<p>需要注意的是，如果希望PB6/7作为TX/RX，可以直接点击图中的可视化引脚视图中的PB6选择USART1_TX，那么PA9/10就会被切换为PB6/7，并且自动在生成的代码中做好AFIO的remap配置</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130085714543.png" alt="image-20241130085714543"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130090020406.png" alt="image-20241130090020406"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241130090037660.png" alt="image-20241130090037660"></p>
<p>同样的，再次点击PA9引脚选择USART1_TX则可以切换回PA9/10</p>
<h3 id="lun-xun-shou-fa-ding-chang-han-shu-diao-yong">轮询收发定长函数调用</h3>
<p><code>stm32f1xx_hal_uart.c</code></p>
<pre class="line-numbers language-none"><code class="language-none">*** Polling mode IO operation ***
=================================
[..]
  (+) Send an amount of data in blocking mode using HAL_UART_Transmit()
  (+) Receive an amount of data in blocking mode using HAL_UART_Receive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>HAL_UART_Transmit</code>：轮询发送指定数量数据，需要指定超时时间（ms）</li>
<li><code>HAL_UART_Receive</code>：轮询接收指定数量的数据，需要指定超时时间（ms）</li>
<li><code>HAL_StatusTypeDef</code>：上述两个函数的返回值，如果成功则返回 <code>HAL_OK</code>，如果超时则返回 <code>HAL_TIMEOUT</code></li>
</ul>
<p>如下示例实现了不断接收8个数据并原样发送8个数据</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main(void) {
    ...

    /* Initialize all configured peripherals */
    MX_GPIO_Init();
    MX_USART1_UART_Init();
    /* USER CODE BEGIN 2 */
    uint8_t* str = "hello world\n";
    HAL_UART_Transmit(&amp;huart1, str, strlen((char*)str), 10);

    uint8_t buffer[100] = { 0 };
    /* USER CODE END 2 */

    /* Infinite loop */
    /* USER CODE BEGIN WHILE */
    while (1) {
        if (HAL_UART_Receive(&amp;huart1, buffer, 8, 10) == HAL_OK) {
            HAL_UART_Transmit(&amp;huart1, buffer, 8, 10);
            /* code */
        }
        /* USER CODE END WHILE */
        
        if (HAL_UART_Receive(&amp;huart1, buffer, 8, 10) == HAL_OK) {
            HAL_UART_Transmit(&amp;huart1, buffer, 8, 10);
            /* code */
        }

        /* USER CODE BEGIN 3 */
    }
    /* USER CODE END 3 */
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lun-xun-fang-shi-jie-shou-bian-chang-shu-ju">轮询方式接收变长数据</h2>
<p><code>stm32f1xx_hal_uart.c</code></p>
<pre class="line-numbers language-none"><code class="language-none">(+) Blocking mode: The reception is performed in polling mode, until either expected number of data is received,
   or till IDLE event occurs. Reception is handled only during function execution.
   When function exits, no data reception could occur. HAL status and number of actually received data elements,
   are returned by function after finishing transfer.
   
(#) Blocking mode API:
    (+) HAL_UARTEx_ReceiveToIdle()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>HAL_UARTEx_ReceiveToIdle</code>：轮询接收数据直到检测到空闲帧</p>
<ul>
<li><code>uint8_t *pData</code>：指定缓冲区的地址</li>
<li><code>uint16_t Size</code>：指定需要接收多少数量数据到缓冲区，通常可以设置为缓冲区的大小</li>
<li><code>uint16_t *RxLen</code>：检测到空闲帧时实际接收到的数据数量，调用方需要准备一个 <code>uint16_t</code>变量并将其地址通过该参数传入，函数会根据实际情况来设置该变量的值</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint8_t</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">uint16_t</span> received_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">/* USER CODE END 2 */</span>

<span class="token comment">/* Infinite loop */</span>
<span class="token comment">/* USER CODE BEGIN WHILE */</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HAL_UARTEx_ReceiveToIdle</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>received_size<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> HAL_OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> received_size<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* code */</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 3 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="zhong-duan-fang-shi-jie-shou-ding-chang-shu-ju">中断方式接收定长数据</h2>
<p><code>stm32f1xx_hal_uart.c</code></p>
<pre class="line-numbers language-none"><code class="language-none">*** Interrupt mode IO operation ***
    ===================================
    [..]
      (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT()
      (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can
           add his own code by customization of function pointer HAL_UART_TxCpltCallback
      (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT()
      (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can
           add his own code by customization of function pointer HAL_UART_RxCpltCallback
      (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can
           add his own code by customization of function pointer HAL_UART_ErrorCallback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p><code>HAL_UART_Receive_IT</code>：以中断方式接收指定数量的数据到接收缓冲区中（由用户定义），调用该函数不会阻塞当前程序</p>
</li>
<li>
<p><code>HAL_UART_RxCpltCallback</code>：接收完成回调，在接收了指定数量（底层通过RXNE中断逐个接收）数据并放到接收缓冲区中（由用户定义）后，该函数会被调用，我们可以通过重写改函数来处理接收到的数据</p>
</li>
</ul>
<blockquote>
<p>[!TIP]</p>
<p><code>stm32f1xx_hal_uart.c</code>提供了 <code>HAL_UART_RxCpltCallback</code>函数的弱定义形式（相当于提供了一个接口），用户可以重写该函数（去掉 <code>__weak</code>关键字）以实现自定义逻辑。</p>
<p>该设计和钩子函数是一脉相承的。</p>
</blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
  * @brief  Rx Transfer completed callbacks.
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */</span>
__weak <span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* Prevent unused argument(s) compilation warning */</span>
  <span class="token function">UNUSED</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxCpltCallback could be implemented in the user file
   */</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 0 */</span>
<span class="token class-name">uint8_t</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">uint16_t</span> fixed_data_size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token class-name">uint8_t</span> is_over <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>huart <span class="token operator">==</span> <span class="token operator">&amp;</span>huart1<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    is_over <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 0 */</span>

<span class="token comment">/**
 * @brief  The application entry point.
 * @retval int
 */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

  <span class="token comment">/* USER CODE BEGIN 1 */</span>

  <span class="token comment">/* USER CODE END 1 */</span>

  <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

  <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN Init */</span>

  <span class="token comment">/* USER CODE END Init */</span>

  <span class="token comment">/* Configure the system clock */</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN SysInit */</span>

  <span class="token comment">/* USER CODE END SysInit */</span>

  <span class="token comment">/* Initialize all configured peripherals */</span>
  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>

  <span class="token comment">/* USER CODE END 2 */</span>

  <span class="token comment">/* Infinite loop */</span>
  <span class="token comment">/* USER CODE BEGIN WHILE */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> fixed_data_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_over<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> fixed_data_size<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      is_over <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>由于是接收定长数据，如果发送方发送的数据不等于既定的<code>fixed_data_size</code>，那么该程序的echo回传逻辑会有问题</p>
</blockquote>
<h2 id="zhong-duan-fang-shi-jie-shou-bian-chang-shu-ju">中断方式接收变长数据</h2>
<p><code>stm32f1xx_hal_uart.c</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> Non<span class="token operator">-</span>Blocking mode<span class="token operator">:</span> The reception is performed using Interrupts or DMA<span class="token punctuation">.</span>
       These API's <span class="token keyword">return</span> the HAL status<span class="token punctuation">.</span>
       The end of the data processing will be indicated through the
       dedicated UART IRQ when using Interrupt mode or the DMA IRQ when using DMA mode<span class="token punctuation">.</span>
       The <span class="token function">HAL_UARTEx_RxEventCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> user callback will be executed during Receive process
       The <span class="token function">HAL_UART_ErrorCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>user callback will be executed when a reception error is detected<span class="token punctuation">.</span>

<span class="token punctuation">(</span>#<span class="token punctuation">)</span> Non<span class="token operator">-</span>Blocking mode API with Interrupt<span class="token operator">:</span>
    <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token function">HAL_UARTEx_ReceiveToIdle_IT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>HAL_UARTEx_ReceiveToIdle_IT</code>：以中断方式接收变长数据，接收数据到缓冲区（由用户定义）直到检测到空闲帧，，该函数不会阻塞当前程序</p>
<ul>
<li><code>uint8_t *pData</code>：接收缓冲区</li>
<li><code>uint16_t Size</code>：需要接收的字结束，通常可以给定为缓冲区的大小</li>
</ul>
<p><code>HAL_UARTEx_RxEventCallback</code>：接收变长数据完成回调，可以通过入参 <code>Size</code>获取实际接收到的数据数量</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
  * @brief  Reception Event Callback (Rx event notification called after use of advanced reception service).
  * @param  huart UART handle
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */</span>
__weak <span class="token keyword">void</span> <span class="token function">HAL_UARTEx_RxEventCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> Size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* Prevent unused argument(s) compilation warning */</span>
  <span class="token function">UNUSED</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">UNUSED</span><span class="token punctuation">(</span>Size<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 0 */</span>
<span class="token class-name">uint8_t</span> buffer<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">uint8_t</span> is_over <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token class-name">uint8_t</span> received_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UARTEx_RxEventCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> Size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>huart <span class="token operator">==</span> <span class="token operator">&amp;</span>huart1<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    is_over <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    received_size <span class="token operator">=</span> Size<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 0 */</span>

<span class="token comment">/**
 * @brief  The application entry point.
 * @retval int
 */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

  <span class="token comment">/* USER CODE BEGIN 1 */</span>

  <span class="token comment">/* USER CODE END 1 */</span>

  <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

  <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
  <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN Init */</span>

  <span class="token comment">/* USER CODE END Init */</span>

  <span class="token comment">/* Configure the system clock */</span>
  <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* USER CODE BEGIN SysInit */</span>

  <span class="token comment">/* USER CODE END SysInit */</span>

  <span class="token comment">/* Initialize all configured peripherals */</span>
  <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN 2 */</span>

  <span class="token comment">/* USER CODE END 2 */</span>

  <span class="token comment">/* Infinite loop */</span>
  <span class="token comment">/* USER CODE BEGIN WHILE */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">HAL_UARTEx_ReceiveToIdle_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_over<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> received_size<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      is_over <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* USER CODE END WHILE */</span>

    <span class="token comment">/* USER CODE BEGIN 3 */</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="cube-sheng-cheng-dai-ma-zi-dong-pei-zhi-fen-xi">Cube生成代码自动配置分析</h2>
<p><code>main.c</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Initialize all configured peripherals */</span>
<span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>MX_GPIO_Init</code>开启了GPIO时钟</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

  <span class="token comment">/* GPIO Ports Clock Enable */</span>
  <span class="token function">__HAL_RCC_GPIOC_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__HAL_RCC_GPIOA_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>MX_USART1_UART_Init</code>将UART相关参数保存到了 <code>huart1</code>结构体中</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">UART_HandleTypeDef huart1<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

  <span class="token comment">/* USER CODE BEGIN USART1_Init 0 */</span>

  <span class="token comment">/* USER CODE END USART1_Init 0 */</span>

  <span class="token comment">/* USER CODE BEGIN USART1_Init 1 */</span>

  <span class="token comment">/* USER CODE END USART1_Init 1 */</span>
  huart1<span class="token punctuation">.</span>Instance <span class="token operator">=</span> USART1<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>BaudRate <span class="token operator">=</span> <span class="token number">115200</span><span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>WordLength <span class="token operator">=</span> UART_WORDLENGTH_8B<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>StopBits <span class="token operator">=</span> UART_STOPBITS_1<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>Parity <span class="token operator">=</span> UART_PARITY_NONE<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>Mode <span class="token operator">=</span> UART_MODE_TX_RX<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>HwFlowCtl <span class="token operator">=</span> UART_HWCONTROL_NONE<span class="token punctuation">;</span>
  huart1<span class="token punctuation">.</span>Init<span class="token punctuation">.</span>OverSampling <span class="token operator">=</span> UART_OVERSAMPLING_16<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">HAL_UART_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">)</span> <span class="token operator">!=</span> HAL_OK<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">Error_Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* USER CODE BEGIN USART1_Init 2 */</span>

  <span class="token comment">/* USER CODE END USART1_Init 2 */</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>HAL_UART_Init</code>主要关注一下两个函数的调用</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">HAL_StatusTypeDef <span class="token function">HAL_UART_Init</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">HAL_UART_MspInit</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">UART_SetConfig</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>usart.c</code>重写了 <code>HAL_UART_MspInit</code>函数</p>
<ul>
<li>对USART1依赖的GPIO进行配置</li>
<li>使能USART1中断</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_MspInit</span><span class="token punctuation">(</span>UART_HandleTypeDef<span class="token operator">*</span> uartHandle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

  GPIO_InitTypeDef GPIO_InitStruct <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>uartHandle<span class="token operator">-&gt;</span>Instance<span class="token operator">==</span>USART1<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
  <span class="token comment">/* USER CODE BEGIN USART1_MspInit 0 */</span>

  <span class="token comment">/* USER CODE END USART1_MspInit 0 */</span>
    <span class="token comment">/* USART1 clock enable */</span>
    <span class="token function">__HAL_RCC_USART1_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">__HAL_RCC_GPIOA_CLK_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**USART1 GPIO Configuration
    PA9     ------&gt; USART1_TX
    PA10     ------&gt; USART1_RX
    */</span>
    GPIO_InitStruct<span class="token punctuation">.</span>Pin <span class="token operator">=</span> GPIO_PIN_9<span class="token punctuation">;</span>
    GPIO_InitStruct<span class="token punctuation">.</span>Mode <span class="token operator">=</span> GPIO_MODE_AF_PP<span class="token punctuation">;</span>
    GPIO_InitStruct<span class="token punctuation">.</span>Speed <span class="token operator">=</span> GPIO_SPEED_FREQ_HIGH<span class="token punctuation">;</span>
    <span class="token function">HAL_GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span>

    GPIO_InitStruct<span class="token punctuation">.</span>Pin <span class="token operator">=</span> GPIO_PIN_10<span class="token punctuation">;</span>
    GPIO_InitStruct<span class="token punctuation">.</span>Mode <span class="token operator">=</span> GPIO_MODE_INPUT<span class="token punctuation">;</span>
    GPIO_InitStruct<span class="token punctuation">.</span>Pull <span class="token operator">=</span> GPIO_NOPULL<span class="token punctuation">;</span>
    <span class="token function">HAL_GPIO_Init</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStruct<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* USART1 interrupt Init */</span>
    <span class="token function">HAL_NVIC_SetPriority</span><span class="token punctuation">(</span>USART1_IRQn<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_NVIC_EnableIRQ</span><span class="token punctuation">(</span>USART1_IRQn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN USART1_MspInit 1 */</span>

  <span class="token comment">/* USER CODE END USART1_MspInit 1 */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="the-end">THE END</h1>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>UART</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title>算法之美</title>
    <url>/2024/11/26/23674.html</url>
    <content><![CDATA[<h1 id="chun-bian-cheng-ti">纯编程题</h1>
<h1 id="zhao-gui-lu-ti">找规律题</h1>
<h1 id="lian-biao">链表</h1>
<h1 id="zhan-he-dui-lie">栈和队列</h1>
<h1 id="di-gui-he-fen-zhi">递归和分治</h1>
<h1 id="pai-xu">排序</h1>
<h1 id="er-fen-cha-zhao">二分查找</h1>
<h1 id="ha-xi">哈希</h1>
<h1 id="er-cha-shu">二叉树</h1>
<h2 id="qian-zhong-hou-xu-bian-li-dfs">前中后序遍历（DFS）</h2>
<h3 id="di-gui-shi-xian">递归实现</h3>
<h3 id="fei-di-gui-shi-xian">非递归实现</h3>
<h4 id="a-href-https-leetcode-cn-problems-binary-tree-preorder-traversal-144-er-cha-shu-de-qian-xu-bian-li-a"><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */</span>
<span class="token comment">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_STACK_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>
    LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">,</span>
    RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">,</span>
    SUBTREE_PROCESSED
<span class="token punctuation">}</span> TraverseState<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>
    TraverseState state<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Frame<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Frame<span class="token operator">*</span> frames<span class="token punctuation">[</span>MAX_STACK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Stack<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">,</span> Frame<span class="token operator">*</span> frame<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> MAX_STACK_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    stack<span class="token operator">-&gt;</span>frames<span class="token punctuation">[</span>stack<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> frame<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> MAX_STACK_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">--</span>stack<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">isEmpty</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

Frame<span class="token operator">*</span> <span class="token function">peek</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> stack<span class="token operator">-&gt;</span>frames<span class="token punctuation">[</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">pushNode</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Frame<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Frame<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tmp<span class="token operator">-&gt;</span>node <span class="token operator">=</span> node<span class="token punctuation">;</span>
        tmp<span class="token operator">-&gt;</span>state <span class="token operator">=</span> LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">;</span>
        <span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> returnSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> MAX_STACK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Stack<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stack<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Frame <span class="token operator">*</span>frame <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token operator">-&gt;</span>state <span class="token operator">==</span> LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">*</span>returnSize<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
            <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            frame<span class="token operator">-&gt;</span>state <span class="token operator">=</span> RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token operator">-&gt;</span>state <span class="token operator">==</span> RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            frame<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SUBTREE_PROCESSED<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">pop</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="a-href-https-leetcode-cn-problems-binary-tree-inorder-traversal-94-er-cha-shu-de-zhong-xu-bian-li-a"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */</span>
<span class="token comment">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_STACK_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>
    LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">,</span>
    RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">,</span>
    SUBTREE_PROCESSED
<span class="token punctuation">}</span> TraverseState<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>
    TraverseState state<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Frame<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Frame<span class="token operator">*</span> frames<span class="token punctuation">[</span>MAX_STACK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Stack<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">,</span> Frame<span class="token operator">*</span> frame<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> MAX_STACK_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    stack<span class="token operator">-&gt;</span>frames<span class="token punctuation">[</span>stack<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> frame<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> MAX_STACK_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">--</span>stack<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">isEmpty</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

Frame<span class="token operator">*</span> <span class="token function">peek</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> stack<span class="token operator">-&gt;</span>frames<span class="token punctuation">[</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">pushNode</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Frame<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Frame<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tmp<span class="token operator">-&gt;</span>node <span class="token operator">=</span> node<span class="token punctuation">;</span>
        tmp<span class="token operator">-&gt;</span>state <span class="token operator">=</span> LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">;</span>
        <span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> returnSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> MAX_STACK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Stack<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stack<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Frame <span class="token operator">*</span>frame <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token operator">-&gt;</span>state <span class="token operator">==</span> LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            frame<span class="token operator">-&gt;</span>state <span class="token operator">=</span> RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token operator">-&gt;</span>state <span class="token operator">==</span> RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">*</span>returnSize<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
            <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            frame<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SUBTREE_PROCESSED<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">pop</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="a-href-https-leetcode-cn-problems-binary-tree-postorder-traversal-145-er-cha-shu-de-hou-xu-bian-li-a"><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */</span>
<span class="token comment">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_STACK_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>
    LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">,</span>
    RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">,</span>
    SUBTREE_PROCESSED
<span class="token punctuation">}</span> TraverseState<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>node<span class="token punctuation">;</span>
    TraverseState state<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Frame<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Frame<span class="token operator">*</span> frames<span class="token punctuation">[</span>MAX_STACK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Stack<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">,</span> Frame<span class="token operator">*</span> frame<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> MAX_STACK_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    stack<span class="token operator">-&gt;</span>frames<span class="token punctuation">[</span>stack<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> frame<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> MAX_STACK_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">--</span>stack<span class="token operator">-&gt;</span>size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">isEmpty</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> stack<span class="token operator">-&gt;</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

Frame<span class="token operator">*</span> <span class="token function">peek</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> stack<span class="token operator">-&gt;</span>frames<span class="token punctuation">[</span>stack<span class="token operator">-&gt;</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">pushNode</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> stack<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Frame<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Frame<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tmp<span class="token operator">-&gt;</span>node <span class="token operator">=</span> node<span class="token punctuation">;</span>
        tmp<span class="token operator">-&gt;</span>state <span class="token operator">=</span> LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">;</span>
        <span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> returnSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> MAX_STACK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Stack<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stack<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Frame <span class="token operator">*</span>frame <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token operator">-&gt;</span>state <span class="token operator">==</span> LEFT_SUBTREE_UNPROCESSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            frame<span class="token operator">-&gt;</span>state <span class="token operator">=</span> RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token operator">-&gt;</span>state <span class="token operator">==</span> RIGHT_SUBTREE_UNPROCESSED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">pushNode</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            frame<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SUBTREE_PROCESSED<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">*</span>returnSize<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> frame<span class="token operator">-&gt;</span>node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
            <span class="token function">pop</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="a-href-https-leetcode-cn-problems-n-ary-tree-preorder-traversal-589-n-cha-shu-de-qian-xu-bian-li-a"><a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></h4>
<h4 id="a-href-https-leetcode-cn-problems-n-ary-tree-postorder-traversal-590-n-cha-shu-de-hou-xu-bian-li-a"><a href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></h4>
<h2 id="an-ceng-bian-li-bfs">按层遍历（BFS）</h2>
<h4 id="a-href-https-leetcode-cn-problems-binary-tree-level-order-traversal-102-er-cha-shu-de-ceng-xu-bian-li-a"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241128141110383.png" alt="image-20241128141110383"></p>
<h4 id="fang-fa-yi-you-size-lai-zuo-mei-yi-ceng-de-fen-ge">🌟方法一：由size来做每一层的分隔</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */</span>
<span class="token comment">/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> returnSize<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> returnColumnSizes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>returnColumnSizes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> queue<span class="token punctuation">[</span><span class="token number">2000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> head<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>
    head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// enqueue root</span>

    <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> ans <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>levelSizes <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>tail <span class="token operator">-</span> head <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        levelSizes<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> tail <span class="token operator">-</span> head<span class="token punctuation">;</span>
        ans<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> levelSizes<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> levelSizes<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>node <span class="token operator">=</span> queue<span class="token punctuation">[</span>head<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// dequeue</span>
            ans<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        level<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">*</span>returnSize <span class="token operator">=</span> level<span class="token punctuation">;</span>
    <span class="token operator">*</span>returnColumnSizes <span class="token operator">=</span> levelSizes<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="fang-fa-er-ji-lu-ceng-hao">方法二：记录层号</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdlib.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdbool.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../tree.h"</span></span>
<span class="token comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */</span>
<span class="token comment">/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> TreeNode_t<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">_ListNode</span> <span class="token punctuation">{</span>
    TreeNode_t <span class="token operator">*</span>treeNode<span class="token punctuation">;</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">_ListNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_ListNode</span> ListNode_t<span class="token punctuation">;</span>


<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ListNode_t<span class="token operator">*</span> head<span class="token punctuation">;</span>
    ListNode_t<span class="token operator">*</span> tail<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span> Queue<span class="token punctuation">;</span>

Queue<span class="token operator">*</span> <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode_t<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ListNode_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummy<span class="token operator">-&gt;</span>treeNode <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    dummy<span class="token operator">-&gt;</span>level <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    dummy<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    Queue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token operator">-&gt;</span>head <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
    queue<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> queue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

bool <span class="token function">isEmpty</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> queue<span class="token operator">-&gt;</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">offer</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>queue<span class="token punctuation">,</span> TreeNode_t<span class="token operator">*</span> treeNode<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ListNode_t<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ListNode_t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>treeNode <span class="token operator">=</span> treeNode<span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>level <span class="token operator">=</span> level<span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    queue<span class="token operator">-&gt;</span>tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
    queue<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> node<span class="token punctuation">;</span>
    queue<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

ListNode_t<span class="token operator">*</span> <span class="token function">poll</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token operator">-&gt;</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ListNode_t <span class="token operator">*</span>node <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    queue<span class="token operator">-&gt;</span>head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    queue<span class="token operator">-&gt;</span>size<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        queue<span class="token operator">-&gt;</span>tail <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> returnSize<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> returnColumnSizes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>returnColumnSizes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>levelSizes <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>returnColumnSizes <span class="token operator">=</span> levelSizes<span class="token punctuation">;</span>

    Queue<span class="token operator">*</span> queue <span class="token operator">=</span> <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>level <span class="token operator">=</span>  <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 出队元素</span>
        ListNode_t <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果元素所在层级不等于当前要收集的层级，将之前已收集的层级保存到结果中</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>level <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> level<span class="token punctuation">;</span>
            levelSizes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 记录这一层的节点数量</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">// 开始下一层级的收集</span>
            level <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        TreeNode_t <span class="token operator">*</span>treeNode <span class="token operator">=</span> node<span class="token operator">-&gt;</span>treeNode<span class="token punctuation">;</span>
        <span class="token comment">// 收集数值</span>
        level<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> treeNode<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
        <span class="token comment">// 将子节点入队</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>treeNode<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> treeNode<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>treeNode<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">offer</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> treeNode<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> level<span class="token punctuation">;</span>
    levelSizes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 记录这一层的节点数量</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="fang-fa-san-you-null-lai-zuo-mei-ceng-de-fen-ge">方法三：由null来做每层的分隔</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> returnSize<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> returnColumnSizes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>returnColumnSizes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> ans <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>levelSizes <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> queue<span class="token punctuation">[</span><span class="token number">4000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> head<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>
    head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// enqueue root</span>
    queue<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// enqueue level separator</span>

    <span class="token keyword">int</span> <span class="token operator">*</span>levelVals <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>tail <span class="token operator">-</span> head <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>node <span class="token operator">=</span> queue<span class="token punctuation">[</span>head<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            levelVals<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            levelSizes<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>  <span class="token comment">// record level size</span>
            ans<span class="token punctuation">[</span>level<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> levelVals<span class="token punctuation">;</span>   <span class="token comment">// record level values</span>
            levelVals <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>tail <span class="token operator">-</span> head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// store next level</span>
            j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// index of next level</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tail <span class="token operator">&gt;</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue<span class="token punctuation">[</span>tail<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// separator for next level</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token operator">*</span>returnSize <span class="token operator">=</span> level<span class="token punctuation">;</span>
    <span class="token operator">*</span>returnColumnSizes <span class="token operator">=</span> levelSizes<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="the-end">THE END</h1>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>论时序要求的重要性（移位寄存器控制数码管）</title>
    <url>/2024/11/15/31801.html</url>
    <content><![CDATA[<h1 id="1-wen-ti-bei-jing">1. 问题背景</h1>
<h2 id="ying-jian-bei-jing">硬件背景</h2>
<ul>
<li>移位寄存器：<a href="https://item.szlcsc.com/79848.html?fromZone=s_s__%2274HC595N%22">SN74HC595N</a></li>
<li>两个4位共阳数码管</li>
</ul>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/20241115163627.png" alt=""></p>
<h2 id="yi-wei-suo-cun-luo-ji-set-reset">移位/锁存逻辑——set/reset</h2>
<p>在学习GD32F407VET时，将学习STC8实现的数码管模块移植过来，发现了一个很奇怪的问题。其中移位操作的实现如下（封装了对两个串联移位寄存器的移位操作，控制8个数码管中显示哪一个，以及控制数码管显示内容）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现单独指定某个数码管显示某个数是没有问题的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 要显示1~8对应的码表</span>
<span class="token class-name">uint8_t</span> code<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0xF9</span><span class="token punctuation">,</span> <span class="token number">0xA4</span><span class="token punctuation">,</span> <span class="token number">0xB0</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">,</span> <span class="token number">0x92</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0xF8</span><span class="token punctuation">,</span> <span class="token number">0x80</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">Int_NixieTube_DisplaySingle</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> code<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但是想使用 <code>for</code>控制数码管轮流显示1~8时，就发现显示的内容并不符合预期：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Int_NixieTube_DisplaySingle</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> code<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="yi-wei-suo-cun-luo-ji-write">移位/锁存逻辑——write</h2>
<p>但是将其中 <code>gpio_bit</code> 的 <code>set/reset</code>换成 <code>write</code>之后，发现数码管能够按照预期显示了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">,</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">,</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">,</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">,</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看这些函数的实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">GPIO_BOP</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">GPIO_BC</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">,</span> bit_status bit_value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>RESET <span class="token operator">!=</span> bit_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">GPIO_BOP</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">GPIO_BC</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现 <code>write</code>只不过将 <code>set/reset</code>包成了一个函数，唯一不同的就是多了一个 <code>if</code>判断。</p>
<p>但是，一个<code>if</code> 的耗时又能对程序产生什么影响呢？我百思不得其解。</p>
<h1 id="2-shi-xu-yao-qiu-yin-fa-de-xie-an">2. 时序要求引发的血案</h1>
<h2 id="xiao-xiao-if-an-cang-xuan-ji">小小if暗藏玄机</h2>
<p>在各种 <code>Google, GPT</code>之后，结合代码上下文，发现代码中使用了 <code>nop</code>来增加时延，再结合移位寄存器需要根据我们通过GPIO发送的SRCLK（移位时钟）、RCLK（锁存时钟）的上升沿来进行移位操作和锁存操作（将移位寄存器更新到锁存寄存器 storage register）。</p>
<p>我设置的GD32F407的主频是168MHz，这个比STC8时的24MHz还是要快几倍的，计算一下<code>nop</code>对应一个时钟周期的时间为 <code>1/168MHz</code>约为 <code>5.95ns</code>、<code>1/24MHz</code>约为 <code>41.67ns</code>。</p>
<p>这样看来，一个 <code>if</code>判断还真有可能引发了血案，其所消耗的时钟周期（增加的时延）可能正好满足了移位寄存器的<strong>时序要求</strong>，从而使得数码管能够正常显示。</p>
<h2 id="shu-ju-shou-ce-bu-ke-shao">数据手册不可少</h2>
<p>在想到可能时时延导致的问题后，不妨看一下芯片对应的官方手册，看能否找到答案。</p>
<p>这里要注意的是，一定要找与芯片型号、品牌一致的：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241115170556369.png" alt="image-20241115170556369"></p>
<h2 id="timing-requirements">Timing Requirements</h2>
<p>这里我们主要看时序要求（Timing Requirements ）相关的章节</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241115170729345.png" alt="image-20241115170729345"></p>
<h3 id="set-up-time">Set-up time</h3>
<p>其中描述了，我们在使用串行信号线 <code>SER</code>、移位寄存器时钟线 <code>SRCLK</code>、锁存器时钟线 <code>RCLK</code> 来操作 <a href="https://item.szlcsc.com/79848.html?fromZone=s_s__%2274HC595N%22">SN74HC595N</a> 时，需要的准备时间，例如</p>
<h4 id="ser-before-srclk">SER before SRCLK↑</h4>
<p>在操作SRCLK上升沿将SER存入移位寄存器之前，SER应该预备的时间，以125ns为例，伪代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
SRCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="srclk-before-rclk">SRCLK↑ before RCLK↑</h4>
<p>在操作完所有的移位后，将移位寄存器更新到锁存寄存器（即更新到电路，控制数码管的段选和片选），需要操作RCLK上升沿。</p>
<p>该参数规定了，RCLK上升沿应该与SRCLK上升沿保持的时间间隔</p>
<h3 id="pulse-duration">Pulse duration</h3>
<p>其中描述了SRCLK、RCLK被置位后应该持续一段时间，所以我们还需要在上述基础上增加两个延时（以100ns为例）</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
wait 100ns
SRCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再加上锁存的操作：</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
wait 100ns
SRCLK = 1;

wait 100ns
RCLK = 0;
wait 100ns
RCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="zai-kan-if-he-nop">再看if和nop</h2>
<p>之前对于时序控制的理解并不深刻，简单的以为使用 <code>nop</code>停顿一下就好。现在看来，无论是不同主频对应的 <code>nop</code>时延不同，还是 <code>if</code>耗时也能影响数码管的生死，都在提醒我们时序控制不可小觑。</p>
<p>在使用MCU对外围设备/芯片交互</p>
<p>、控制时，一定要严格按照芯片要求的时序控制，结合MCU自身指令耗时来编写程序。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里宁愿多等一点，也不要让 SN74HC595N 无法准确移位、锁存数据。</p>
]]></content>
      <categories>
        <category>GD32</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>GD32</tag>
        <tag>时序要求</tag>
        <tag>SN74HC595NSR</tag>
        <tag>移位寄存器</tag>
      </tags>
  </entry>
</search>
