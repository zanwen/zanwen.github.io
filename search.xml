<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/11/12/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>深入理解I2C时序（以I2C实时时钟PCF8563为案例）</title>
    <url>/2024/11/16/31289.html</url>
    <content><![CDATA[<h1 id="yi-qian-yan">一、前言</h1>
<h2 id="ying-jian-bei-jing">硬件背景</h2>
<ul>
<li>GD32F407VET6</li>
<li>I2C实时时钟PCF8563</li>
</ul>
<h2 id="yuan-li-tu">原理图</h2>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116194724707.png" alt="image-20241116194724707" style="zoom: 33%;">
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116194750339.png" alt="image-20241116194750339" style="zoom:33%;">
<h2 id="wen-dang-zi-liao">文档资料</h2>
<ul>
<li><a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a></li>
<li><a href="https://atta.szlcsc.com/upload/public/pdf/source/20230921/9DB04F89E1E4336DD7CCB7C268B77442.pdf">I 2 C 实时时钟/日历芯片 PCF8563</a></li>
</ul>
<h1 id="er-en-zhi-pu-nxp-i-2-c-zong-xian-xie-yi-shi-xu-jie-xi">二、恩智浦（NXP）I2C总线协议时序解析</h1>
<blockquote>
<p>参见<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的</p>
<p>**6 Electrical specifications and timing for I/O stages and bus lines  **</p>
<p>**Table 11. Characteristics of the SDA and SCL bus lines for Standard, Fast, and Fast-mode Plus I2C-bus devices **</p>
</blockquote>
<h2 id="overview">Overview</h2>
<h3 id="sda-scl-zong-xian-te-xing">SDA/SCL总线特性</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116195121046.png" alt="image-20241116195121046"></p>
<h3 id="shi-xu-ding-yi">时序定义</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202433638.png" alt="image-20241116202433638"></p>
<h2 id="i-2-c-chuan-shu-kong-zhi">I2C传输控制</h2>
<p>I2C规定单次通信需要遵循如下两个控制</p>
<h3 id="shu-ju-chuan-shu-kong-zhi">数据传输控制</h3>
<p><mark>在SCL为低时可以修改SDA；SCL为高时，SDA应该保持不变。</mark></p>
<p>在SCL为低电平时，准备SDA（发送方）；在SCL为高时，保持SDA（在此期间接送方会读取SDA）。</p>
<p>这一点在<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的 <strong>3.1.3 Data validity</strong>说明如下：</p>
<blockquote>
<p>The data on the SDA line must be stable during the HIGH period of the clock. The HIGH or LOW state of the data line can only change when the clock signal on the SCL line is LOW (see Figure 4). One clock pulse is generated for each data bit transferred.</p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214251742.png" alt="image-20241116214251742"></p>
<h2 id="qi-shi-zhong-zhi-kong-zhi">起始/终止控制</h2>
<p>在SCL为高时，拉低SDA（需要提前准备好SDA为高）；在SCL为低时，拉高SDA（需要提前准备好SDA为低）。</p>
<p><mark>可以发现为了区分数据传输控制，特意在SCL为高时操作SDA。</mark></p>
<p>这一点在<a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">NXP（恩智浦）I2C总线协议说明书和用户手册</a>中的 <strong>3.1.4 START and STOP conditions</strong> 说明如下：</p>
<blockquote>
<p>All transactions begin with a START (S) and are terminated by a STOP (P) (see Figure 5). A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition. A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition.</p>
</blockquote>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214423843.png" alt="image-20241116214423843"></p>
<h2 id="f-sub-scl-sub-shi-zhong-xian-pin-lu-frequency-for-scl">f<sub>SCL</sub>时钟线频率（frequency for SCL）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116201656138.png" alt="image-20241116201656138"></p>
<p>该参数规定了I2C的SCL时钟线的频率，以Fast-mode为例，最大为400kHz。这意味着我们在操作SCL时，将SCL置0的时间+随后将SCL置1的时间之和不能小于 1/400kHz = 2.5us：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116201725124.png" alt="image-20241116201725124"></p>
<h2 id="t-sub-hd-sta-sub-qi-shi-xin-hao-bao-chi-shi-jian-hol-d-time-for-start-condition">t<sub>HD;STA</sub>起始信号保持时间（HolD time for START condition）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202607065.png" alt="image-20241116202607065"></p>
<p>该参数规定了起始信号（START condition）需要保持的时间（在SCL为高电平时，将SDA由高拉低后需要保持的时间）</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116202932000.png" alt="image-20241116202932000" style="zoom: 50%;">
<p>这里有两个细节需要注意一下：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204002371.png" alt="image-20241116204002371"></p>
<ol>
<li>hold time (<mark>repeated</mark>) START condition：<mark>repeated</mark>表明第一个起始信号后的重复起始信号都需要遵循这个规则，例如在<a href="https://atta.szlcsc.com/upload/public/pdf/source/20230921/9DB04F89E1E4336DD7CCB7C268B77442.pdf">PCF8563</a>中提到的 <mark>写地址，读数据</mark>模式中，在第一个S（起始信号）之后有一个 <mark>dummy&nbsp;write</mark>（指定后面连续读的起始寄存器地址），然后又有一个S，紧接着才是真正的连续读数据。这里第二个S就属于 <mark>repeated&nbsp;START&nbsp;condition</mark>。</li>
</ol>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116203555124.png" alt="image-20241116203555124" style="zoom: 33%;">
<ol start="2">
<li>
<p><mark>After this period, the first clock pulse is generated</mark>：暗示我们在这个t<sub>HD;STA</sub>周期（相当于I2C通信的准备阶段）过后，主设备应该生成第一个时钟脉冲开始传输数据。因此时序定义里也给出了如下示意图，<strong>暗示我们在延时t<sub>HD;STA</sub>之后，应该将SCL拉低</strong>（图中 <mark>1<sup>st</sup>&nbsp;clock&nbsp;cycle</mark>也进一步印证了这一点）。</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204645958.png" alt="image-20241116204645958" style="zoom:50%;">
</li>
</ol>
<h2 id="t-sub-low-sub-t-sub-high-sub-shi-zhong-xian-gao-di-dian-ping-zhou-qi-kong-zhi-scl-low-high-period">t<sub>LOW</sub>/t<sub>HIGH</sub>时钟线高低电平周期控制（SCL low/high period）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116204955105.png" alt="image-20241116204955105"></p>
<p>该参数规定了我们传输数据拉高拉低SCL时，其高低电平应该持续的时间，以Fast-mode为例，SCL低电平最低持续1.3us，高电平则最低0.6us</p>
<h2 id="t-sub-su-sta-sub-qi-shi-xin-hao-jian-li-zhun-bei-shi-jian-set-up-time-for-start">t<sub>SU;STA</sub> 起始信号建立（准备）时间（SetUp time for START）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116205306146.png" alt="image-20241116205306146"></p>
<p>该参数规定了起始信号的建立（准备）时间，这个参数有点难理解。我们参照时序定义来看下：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116205502756.png" alt="image-20241116205502756" style="zoom: 50%;">
<p>和t<sub>HD;STA</sub>对比来看，t<sub>HD;STA</sub>规定了起始信号的保持时间（SCL为高时，拉低SDA并保持）。</p>
<p>t<sub>SU;STA</sub> 则是用于重复起始信号的（每次通信至少对应一个START和STOP，连续的多次通信中紧接着前一次通信STOP之后的START可称为 <mark>repeated START</mark>，前面介绍的 <mark>写地址，连续读模式</mark>对应的START,START,STOP中第二个START也是如此）。</p>
<p>对于重复起始信号而言，SCL可能是以低电平开始的（例如上一次通信将SCL拉低了），为了满足实现起始信号（拉低SDA）的<mark>前置条件（SCL为高，SDA为高）</mark>，该参数规定了在拉低SDA之前，SDA应该在SCL为高期间保持高电平的时间。</p>
<h2 id="qi-shi-zhong-zhi-xin-hao-de-shi-xian">起始/终止信号的实现</h2>
<p>这里我们已经可以写出起始信号的伪代码了（所有延时以 Fast-mode 为例）：</p>
<p><code>I2C_Start()</code></p>
<pre class="line-numbers language-none"><code class="language-none">// 前置条件
SDA = HIGH
SCL = HIGH
// 前置条件建立（准备）时间
delay 0.6us

// 起始信号(SCL,SDA为高时，拉低SDA)
SDA = LOW
// 起始信号保持时间
delay 0.6

// 开始第一个时钟周期低电平阶段
SCL = 0;
delay 1.3us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的C语言实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SCL_PIN</span>    <span class="token expression">GPIO_PIN_6</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_SDA_PIN</span>    <span class="token expression">GPIO_PIN_7</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_PORT</span>  <span class="token expression">GPIOB</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">I2C_GPIO_RCU</span>   <span class="token expression">RCU_GPIOB</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_HIGH</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SCL_LOW</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SCL_PIN<span class="token punctuation">)</span></span></span>

<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start setup</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start hold</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>注意</mark>：这里第22行，并没有和伪代码中的1.3us保持一致，是因为在后续的数据传输中，置位SDA后是需要一个setup时延的（例如1us），无形之间延长了SCL低电平的时间（相当于变成为2us），详见后文分析。</p>
<h2 id="t-sub-hd-dat-sub-shu-ju-bao-chi-shi-jian-hol-d-time-for-data">t<sub>HD;DAT</sub>数据保持时间（HolD time for DATA）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116212042232.png" alt="image-20241116212042232"></p>
<p>可以发现该参数对应两种条件： <mark>CBUS compatible controllers</mark>和 <mark>I2C-bus devices</mark>，我们这里只关心I2C，要求持续的最小时间为0，相当于不需要控制时延，暂时可以忽略该参数。</p>
<h2 id="t-sub-su-dat-sub-shu-ju-jian-li-zhun-bei-shi-jian-set-up-time-for-data">t<sub>SU;DAT</sub>数据建立（准备）时间（SetUp time for DATA）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116212548515.png" alt="image-20241116212548515"></p>
<p>该参数规定了SDA建立（准备）时间，也即在SCL为低时，置位SDA为下一个要发送的数据后，到拉高SCL（以让接收方读取数据）之前应该保持的时间：</p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116214624147.png" alt="image-20241116214624147" style="zoom:50%;">
<p>我们每次发送数据都遵循如下流程</p>
<ul>
<li>拉低SCL，并延时t<sub>LOW</sub></li>
<li>准备SDA（下一次要发送的数据），并延时t<sub>SU;DAT</sub></li>
<li>拉高SCL，并延时/t<sub>HIGH</sub></li>
</ul>
<h2 id="fa-song-yi-ge-zi-jie-de-shi-xian">发送一个字节的实现</h2>
<p>至此，我们可以写出发送一个字节的伪代码了（接着之前的 <code>I2C_Start</code>）：</p>
<p><code>I2C_SendByte</code></p>
<pre class="line-numbers language-none"><code class="language-none">uint8_t byte
// 需要循环8次，发送一个字节8个bit
for(i = 0 ; i &lt; 8 ; i++) {
    // 此前I2C_Start的结尾以将SCL拉低，这里我们可以直接准备SDA
    SDA = (byte &amp; (0x08 &gt;&gt; i)) ? HIGH : LOW
    delay 1us // SDA建立时间，这期间SCL仍未低电平，因此一共持续了2us
    
    SCL = HIGH
    delay 1us // SCL高电平周期
    
    SCL = LOW // 开启下一个时钟周期
    delay 1us // SCL低电平周期
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应GD32F4的C语言实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start setup</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//start hold</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">send_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> byte<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>byte <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// data set-up</span>

        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="t-sub-r-sub-t-sub-f-sub-shang-sheng-yan-xia-jiang-yan-shi-jian-rising-falling-edge">t<sub>r</sub> / t<sub>f</sub>上升沿/下降沿时间（Rising/Falling edge）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116220318791.png" alt="image-20241116220318791"></p>
<img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116220810270.png" alt="image-20241116220810270" style="zoom:33%;">
<p>这两个参数规定了SCL和SDA的上升沿（r-rising edge）、下降沿（f-falling edge）的时间控制。我理解是和我们的MCU GIPO输出速率有关的。以GD32F4为例，对应标准库函数 <code>gpio_output_options_set</code>中的 <code>speed</code>参数。</p>
<p>如下，我们将SCL和SDA的输出速率设定为50MHz，也即控制GPIO引脚高低变化，由高到低/由低到高，这个转变（transition）需要的时间（1/50MHz = 20ns）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">gpio_output_options_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_OTYPE_OD<span class="token punctuation">,</span> 
	GPIO_OSPEED_50MHZ<span class="token punctuation">,</span> I2C_SCL_PIN <span class="token operator">|</span> I2C_SDA_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>而上述表格中 Fast-mode，20ns到300ns对应3.33MHz到50MHz。</p>
<p>==存疑：==当我使用 <code>GPIO_OSPEED_50MHZ</code>时，也可以正常运行，可能与我的延时 <code>1us</code>大于 <code>0.6us</code>有关。</p>
<h2 id="t-sub-su-sto-sub-zhong-zhi-xin-hao-jian-li-zhun-bei-shi-jian-set-up-time-for-stop">t<sub>SU;STO</sub>终止信号建立（准备）时间（SetUp time for STOP）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116221510344.png" alt="image-20241116221510344"></p>
<p>由于终止信号（拉高SDA）是有前置条件的（SCL为高，SDA为低），该参数规定了在拉高SDA之前，SDA在SCL为高期间保持低电平的时间：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222328620.png" alt="image-20241116222328620"></p>
<h2 id="t-sub-buf-sub-zong-xian-shi-fang-shi-jian-b-us-free-time">t<sub>BUF</sub>总线释放时间（BUs Free time）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222447598.png" alt="image-20241116222447598"></p>
<p>该参数规定了在一个终止信号（P）和下一个起始信号（S）之间，总线应该被释放（SCL/SDA保持高电平）的时间：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116222631166.png" alt="image-20241116222631166"></p>
<h2 id="zhong-zhi-xin-hao-de-shi-xian">终止信号的实现</h2>
<p>至此，我们可以实现终止信号的伪代码了：</p>
<p><code>I2C_Stop</code></p>
<pre class="line-numbers language-none"><code class="language-none">// 前置条件：SDA为低，SCL为高
// 此前I2C_SendByte的结尾已将SCL拉低，这里可以直接准备SDA
SDA = 0
delay 1us // 为了确保SCL低电平周期大于1.3us，这里补充一个1us
SCL = HIGH
delay 1us // SCL高电平周期
delay 1us // 补充1us，确保&gt;总线释放时间1.3us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应C语言实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//stop setup</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//bus free time between a STOP and START condition</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="t-sub-vd-dat-sub-t-sub-vd-ack-sub-shu-ju-ack-you-xiao-shi-jian-valid-time-for-data-ack">t<sub>VD;DAT</sub>/t<sub>VD;ACK</sub>数据/ACK有效时间（Valid time for DATA/ACK）</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241116223438554.png" alt="image-20241116223438554"></p>
<p>个人理解这两个参数是在接收的场景下使用的，在作为接收方释放SDA（拉高SDA）之后，发送方会通过拉高/拉低SDA来准备ACK/数据比特，然后我们需要等待t<sub>VD;DAT</sub>/t<sub>VD;ACK</sub>这样一个时间确保发送方准备好SDA了，然后我们再拉高SCL（让发送方保持SDA），并读取SDA。</p>
<h2 id="jie-shou-ack-shu-ju-zi-jie-dai-ma-shi-xian">接收ACK/数据字节代码实现</h2>
<p>至此，我们可以实现接收ack和数据字节的代码了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_IN</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_INPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_OUT</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_mode_set</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> GPIO_MODE_OUTPUT<span class="token punctuation">,</span> GPIO_PUPD_PULLUP<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SDA_READ</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">gpio_input_bit_get</span><span class="token punctuation">(</span>I2C_GPIO_PORT<span class="token punctuation">,</span> I2C_SDA_PIN<span class="token punctuation">)</span></span></span>

bool <span class="token function">wait_ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bool success <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token function">SDA_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// release bus</span>
    <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl high</span>

    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    success <span class="token operator">=</span> <span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RESET<span class="token punctuation">;</span> <span class="token comment">// read ack</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// scl low</span>
    <span class="token keyword">return</span> success<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">receive_byte</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">SDA_IN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">SCL_HIGH</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// slave keep data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// read data</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">SDA_READ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> SET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>buf<span class="token punctuation">)</span> <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">SCL_LOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// let slave prepare next data</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">SDA_OUT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="san-i-2-c-wan-zheng-dai-ma">三、I2C完整代码</h1>
<h2 id="code-hal-i-2-c-soft-h-code"><code>hal_i2c_soft.h</code></h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//</span>
<span class="token comment">// Created by 86157 on 2024/11/16.</span>
<span class="token comment">//</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HAL_I2C_SOFT_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HAL_I2C_SOFT_H</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"gd32f4xx.h"</span></span>

<span class="token keyword">void</span> <span class="token function">hal_i2c_soft_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bool <span class="token function">hal_i2c_soft_write</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
bool <span class="token function">hal_i2c_soft_read</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> dev_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> reg_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint16_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">hal_i2c_soft_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">//HAL_I2C_SOFT_H</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="code-hal-i-2-c-soft-c-code"><code>hal_i2c_soft.c</code></h2>
<pre class="line-numbers language-none"><code class="language-none">//
// Created by 86157 on 2024/11/16.
//
#include &lt;stdbool.h&gt;
#include "hal_i2c_soft.h"
#include "systick.h"
#include "logger.h"

#define I2C_SCL_PIN    GPIO_PIN_6
#define I2C_SDA_PIN    GPIO_PIN_7
#define I2C_GPIO_PORT  GPIOB
#define I2C_GPIO_RCU   RCU_GPIOB

#define SDA_HIGH() gpio_bit_set(I2C_GPIO_PORT, I2C_SDA_PIN)

#define SDA_LOW() gpio_bit_reset(I2C_GPIO_PORT, I2C_SDA_PIN)

#define SCL_HIGH() gpio_bit_set(I2C_GPIO_PORT, I2C_SCL_PIN)

#define SCL_LOW() gpio_bit_reset(I2C_GPIO_PORT, I2C_SCL_PIN)

#define SDA_IN() gpio_mode_set(I2C_GPIO_PORT, GPIO_MODE_INPUT, GPIO_PUPD_PULLUP, I2C_SDA_PIN)
#define SDA_OUT() gpio_mode_set(I2C_GPIO_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_PULLUP, I2C_SDA_PIN)
#define SDA_READ() gpio_input_bit_get(I2C_GPIO_PORT, I2C_SDA_PIN)

void hal_i2c_soft_init() {
    // 使能GPIOB时钟
    rcu_periph_clock_enable(I2C_GPIO_RCU);

    // 配置PB6（SCL）和PB7（SDA）为开漏输出模式
    gpio_mode_set(I2C_GPIO_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_PULLUP, I2C_SCL_PIN | I2C_SDA_PIN);
    gpio_output_options_set(I2C_GPIO_PORT, GPIO_OTYPE_OD, GPIO_OSPEED_50MHZ, I2C_SCL_PIN | I2C_SDA_PIN);

    // 将SCL和SDA线拉高
    gpio_bit_set(I2C_GPIO_PORT, I2C_SCL_PIN | I2C_SDA_PIN);
}

static void start() {
    SDA_HIGH();
    SCL_HIGH();
    delay_1us(1); //start setup
    SDA_LOW();
    delay_1us(1); //start hold

    SCL_LOW();
    delay_1us(1);
}

static void stop() {
    SDA_LOW();
    SCL_HIGH();
    delay_1us(1); //stop setup
    SDA_HIGH();
    delay_1us(2); //bus free time between a STOP and START condition
}

static bool wait_ack() {
    bool success = false;
    SDA_HIGH(); // release bus
    SCL_HIGH();
    delay_1us(1); // scl high

    SDA_IN();
    success = SDA_READ() == RESET; // read ack
    SDA_OUT();

    SCL_LOW();
    delay_1us(1); // scl low
    return success;
}

static void send_ack(bool ack) {
    // set sda to reponse ack/nack
    if (ack) {
        SDA_LOW();
    } else {
        SDA_HIGH();
    }
    delay_1us(1); // sda setup

    SCL_HIGH(); // let slave read ack
    delay_1us(1);

    SCL_LOW();
    delay_1us(1); // reset scl for next operation
}

static void send_byte(uint8_t byte) {
    for (int i = 0; i &lt; 8; ++i) {
        if (byte &amp; (0x80 &gt;&gt; i)) {
            SDA_HIGH();
        } else {
            SDA_LOW();
        }
        delay_1us(1); // data set-up

        SCL_HIGH();
        delay_1us(1); // scl high

        SCL_LOW();
        delay_1us(1);
    }
}

static void receive_byte(uint8_t *buf) {
    SDA_IN();
    for (int i = 0; i &lt; 8; ++i) {
        SCL_HIGH(); // slave keep data
        delay_1us(1);

        // read data
        (*buf) &lt;&lt;= 1;
        if(SDA_READ() == SET) {
            (*buf) |= 0x01;
        }

        SCL_LOW(); // let slave prepare next data
        delay_1us(1);
    }
    SDA_OUT();
}

static bool start_for_write(uint8_t dev_addr, uint8_t reg_addr) {
    start();

    send_byte(dev_addr);
    if (!wait_ack()) {
        stop();
        LOG_DEBUG("write dev_addr failed")
        return false;
    }

    send_byte(reg_addr);
    if (!wait_ack()) {
        stop();
        LOG_DEBUG("write reg_addr failed")
        return false;
    }
    return true;
}

static bool start_for_read(uint8_t dev_addr) {
    start();
    send_byte(dev_addr | 0x01); // read from slave
    if (!wait_ack()) {
        stop();
        LOG_DEBUG("write dev_addr for read failed")
        return false;
    }
    return true;
}

bool hal_i2c_soft_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *data, uint16_t size) {
    if (!start_for_write(dev_addr, reg_addr)) {
        return false;
    }
    for (uint16_t i = 0; i &lt; size; ++i) {
        send_byte(*data);
        if (!wait_ack()) {
            stop();
            LOG_DEBUG("write data[%d] failed", *data)
            return false;
        }
        data++;
    }
    stop();
    return true;
}

bool hal_i2c_soft_read(uint8_t dev_addr, uint8_t reg_addr, uint8_t *buf, uint16_t size) {
    // dummy write for register address
    if (!start_for_write(dev_addr, reg_addr)) {
        return false;
    }
    // continuous read
    if (!start_for_read(dev_addr)) {
        return false;
    }
    for (uint16_t i = 0; i &lt; size - 1; ++i) {
        receive_byte(buf++);
        send_ack(true);
    }
    receive_byte(buf);
    send_ack(false);

    stop();
    return true;
}

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>I2C</tag>
        <tag>时序要求</tag>
        <tag>PCF8563</tag>
      </tags>
  </entry>
  <entry>
    <title>论时序要求的重要性（移位寄存器控制数码管）</title>
    <url>/2024/11/15/31801.html</url>
    <content><![CDATA[<h1 id="1-wen-ti-bei-jing">1. 问题背景</h1>
<h2 id="ying-jian-bei-jing">硬件背景</h2>
<ul>
<li>移位寄存器：<a href="https://item.szlcsc.com/79848.html?fromZone=s_s__%2274HC595N%22">SN74HC595N</a></li>
<li>两个4位共阳数码管</li>
</ul>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/20241115163627.png" alt=""></p>
<h2 id="yi-wei-suo-cun-luo-ji-set-reset">移位/锁存逻辑——set/reset</h2>
<p>在学习GD32F407VET时，将学习STC8实现的数码管模块移植过来，发现了一个很奇怪的问题。其中移位操作的实现如下（封装了对两个串联移位寄存器的移位操作，控制8个数码管中显示哪一个，以及控制数码管显示内容）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现单独指定某个数码管显示某个数是没有问题的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 要显示1~8对应的码表</span>
<span class="token class-name">uint8_t</span> code<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0xF9</span><span class="token punctuation">,</span> <span class="token number">0xA4</span><span class="token punctuation">,</span> <span class="token number">0xB0</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">,</span> <span class="token number">0x92</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0xF8</span><span class="token punctuation">,</span> <span class="token number">0x80</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">Int_NixieTube_DisplaySingle</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> code<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但是想使用 <code>for</code>控制数码管轮流显示1~8时，就发现显示的内容并不符合预期：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Int_NixieTube_DisplaySingle</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> code<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="yi-wei-suo-cun-luo-ji-write">移位/锁存逻辑——write</h2>
<p>但是将其中 <code>gpio_bit</code> 的 <code>set/reset</code>换成 <code>write</code>之后，发现数码管能够按照预期显示了：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">,</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">,</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">,</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">,</span> SET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__NOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看这些函数的实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">GPIO_BOP</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">GPIO_BC</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> gpio_periph<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pin<span class="token punctuation">,</span> bit_status bit_value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>RESET <span class="token operator">!=</span> bit_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">GPIO_BOP</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">GPIO_BC</span><span class="token punctuation">(</span>gpio_periph<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现 <code>write</code>只不过将 <code>set/reset</code>包成了一个函数，唯一不同的就是多了一个 <code>if</code>判断。</p>
<p>但是，一个<code>if</code> 的耗时又能对程序产生什么影响呢？我百思不得其解。</p>
<h1 id="2-shi-xu-yao-qiu-yin-fa-de-xie-an">2. 时序要求引发的血案</h1>
<h2 id="xiao-xiao-if-an-cang-xuan-ji">小小if暗藏玄机</h2>
<p>在各种 <code>Google, GPT</code>之后，结合代码上下文，发现代码中使用了 <code>nop</code>来增加时延，再结合移位寄存器需要根据我们通过GPIO发送的SRCLK（移位时钟）、RCLK（锁存时钟）的上升沿来进行移位操作和锁存操作（将移位寄存器更新到锁存寄存器 storage register）。</p>
<p>我设置的GD32F407的主频是168MHz，这个比STC8时的24MHz还是要快几倍的，计算一下<code>nop</code>对应一个时钟周期的时间为 <code>1/168MHz</code>约为 <code>5.95ns</code>、<code>1/24MHz</code>约为 <code>41.67ns</code>。</p>
<p>这样看来，一个 <code>if</code>判断还真有可能引发了血案，其所消耗的时钟周期（增加的时延）可能正好满足了移位寄存器的<strong>时序要求</strong>，从而使得数码管能够正常显示。</p>
<h2 id="shu-ju-shou-ce-bu-ke-shao">数据手册不可少</h2>
<p>在想到可能时时延导致的问题后，不妨看一下芯片对应的官方手册，看能否找到答案。</p>
<p>这里要注意的是，一定要找与芯片型号、品牌一致的：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241115170556369.png" alt="image-20241115170556369"></p>
<h2 id="timing-requirements">Timing Requirements</h2>
<p>这里我们主要看时序要求（Timing Requirements ）相关的章节</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241115170729345.png" alt="image-20241115170729345"></p>
<h3 id="set-up-time">Set-up time</h3>
<p>其中描述了，我们在使用串行信号线 <code>SER</code>、移位寄存器时钟线 <code>SRCLK</code>、锁存器时钟线 <code>RCLK</code> 来操作 <a href="https://item.szlcsc.com/79848.html?fromZone=s_s__%2274HC595N%22">SN74HC595N</a> 时，需要的准备时间，例如</p>
<h4 id="ser-before-srclk">SER before SRCLK↑</h4>
<p>在操作SRCLK上升沿将SER存入移位寄存器之前，SER应该预备的时间，以125ns为例，伪代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
SRCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="srclk-before-rclk">SRCLK↑ before RCLK↑</h4>
<p>在操作完所有的移位后，将移位寄存器更新到锁存寄存器（即更新到电路，控制数码管的段选和片选），需要操作RCLK上升沿。</p>
<p>该参数规定了，RCLK上升沿应该与SRCLK上升沿保持的时间间隔</p>
<h3 id="pulse-duration">Pulse duration</h3>
<p>其中描述了SRCLK、RCLK被置位后应该持续一段时间，所以我们还需要在上述基础上增加两个延时（以100ns为例）</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
wait 100ns
SRCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再加上锁存的操作：</p>
<pre class="line-numbers language-none"><code class="language-none">set SER
wait 125ns
SRCLK = 0;
wait 100ns
SRCLK = 1;

wait 100ns
RCLK = 0;
wait 100ns
RCLK = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="zai-kan-if-he-nop">再看if和nop</h2>
<p>之前对于时序控制的理解并不深刻，简单的以为使用 <code>nop</code>停顿一下就好。现在看来，无论是不同主频对应的 <code>nop</code>时延不同，还是 <code>if</code>耗时也能影响数码管的生死，都在提醒我们时序控制不可小觑。</p>
<p>在使用MCU对外围设备/芯片交互</p>
<p>、控制时，一定要严格按照芯片要求的时序控制，结合MCU自身指令耗时来编写程序。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shift</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">gpio_bit_write</span><span class="token punctuation">(</span>NIX_DI_PORT<span class="token punctuation">,</span> NIX_DI_PIN<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">&gt;&gt;</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> SET <span class="token operator">:</span> RESET<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_SCK_PORT<span class="token punctuation">,</span> NIX_SCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rck_action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">gpio_bit_reset</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">gpio_bit_set</span><span class="token punctuation">(</span>NIX_RCK_PORT<span class="token punctuation">,</span> NIX_RCK_PIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">delay_1us</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里宁愿多等一点，也不要让 SN74HC595N 无法准确移位、锁存数据。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>时序要求</tag>
        <tag>SN74HC595NSR</tag>
        <tag>移位寄存器</tag>
        <tag>数码管</tag>
      </tags>
  </entry>
  <entry>
    <title>UART接收缓冲区溢出异常（HAL_UART_ERROR_ORE）问题记录</title>
    <url>/2024/11/12/13750.html</url>
    <content><![CDATA[<h1 id="wen-ti-bei-jing">问题背景</h1>
<h2 id="kai-fa-huan-jing">开发环境</h2>
<ul>
<li>硬件：GD32F407VET6开发版</li>
<li>IDE：STM32CubeMX + Clion + ARM GNU</li>
<li>烧录：OpenOCD</li>
</ul>
<h2 id="shi-yan-mu-biao">实验目标</h2>
<p>使用Cube配置串口USART1及其中断，引脚复用PA9/PA10，通过使能接收中断 <code>Receive_IT</code>，实现接收7字节时，在中断回调中处理该7个字节数据（简单回传，即echo），并再次开启接收中断，从而实现不断接收7字节、回传7字节的功能。</p>
<h2 id="yu-dao-wen-ti">遇到问题</h2>
<p>发送字节数为7时，能够正常echo；但是不为7时，本来期望是单次发送字节数：</p>
<ul>
<li>大于7字节时，应该也能每次触发中断，只是多余的字节数被丢弃了而已</li>
<li>少于7字节时（例如5），则通过再次发送也能触发中断</li>
</ul>
<p>但实验过程中发现这两种情况下，会发送echo了一两次之后，后面无论发送多少数据都无法再echo的情况</p>
<h1 id="qing-jing-zai-xian">情景再现</h1>
<h2 id="cube-pei-zhi">Cube配置</h2>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212649840.png" alt="image-20241112212649840"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212742297.png" alt="image-20241112212742297"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212813159.png" alt="image-20241112212813159"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212840656.png" alt="image-20241112212840656"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212935188.png" alt="image-20241112212935188"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112212959621.png" alt="image-20241112212959621"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213059038.png" alt="image-20241112213059038"></p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213254243.png" alt="image-20241112213254243"></p>
<h2 id="dao-ru-clion">导入Clion</h2>
<h3 id="bian-yi-pei-zhi-jiao-cha-bian-yi">编译配置-交叉编译</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213601046.png" alt="image-20241112213601046"></p>
<h3 id="cmake-pei-zhi">Cmake配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213656961.png" alt="image-20241112213656961"></p>
<h3 id="open-ocd-shao-lu-pei-zhi">OpenOCD烧录配置</h3>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241112213740944.png" alt="image-20241112213740944"></p>
<p><code>daplink.cfg</code>：</p>
<pre class="line-numbers language-none"><code class="language-none"># choose st-link/j-link/dap-link etc.
adapter driver cmsis-dap
transport select swd

# 0x10000 = 64K Flash Size
# set FLASH_SIZE 0x20000

# 512KB Flash
set FLASH_SIZE 0x80000

source [find target/stm32f4x.cfg]

# download speed = 10MHz
# adapter speed 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="dai-ma-liu-cheng">代码流程</h2>
<ul>
<li>上电后启用接收中断</li>
<li>在接收完毕回调中echo，并再次启用接收中断</li>
</ul>
<p><code>main.c</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 0 */</span>
<span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 0 */</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">/* USER CODE BEGIN 1 */</span>
    <span class="token function">__HAL_RCC_HSI_ENABLE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__HAL_RCC_SYSCLK_CONFIG</span><span class="token punctuation">(</span>RCC_SYSCLKSOURCE_HSI<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE END 1 */</span>

    <span class="token comment">/* MCU Configuration--------------------------------------------------------*/</span>

    <span class="token comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span>
    <span class="token function">HAL_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* USER CODE BEGIN Init */</span>

    <span class="token comment">/* USER CODE END Init */</span>

    <span class="token comment">/* Configure the system clock */</span>
    <span class="token function">SystemClock_Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* USER CODE BEGIN SysInit */</span>

    <span class="token comment">/* USER CODE END SysInit */</span>

    <span class="token comment">/* Initialize all configured peripherals */</span>
    <span class="token function">MX_GPIO_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">MX_USART1_UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE BEGIN 2 */</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* USER CODE END 2 */</span>

    <span class="token comment">/* Infinite loop */</span>
    <span class="token comment">/* USER CODE BEGIN WHILE */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//        HAL_UART_Transmit_IT(&amp;huart1, (uint8_t *)"Hello, World!\r\n", 14);</span>
        <span class="token comment">//        HAL_Delay(1000);</span>
        <span class="token comment">/* USER CODE END WHILE */</span>

        <span class="token comment">/* USER CODE BEGIN 3 */</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* USER CODE END 3 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="yuan-ma-fen-xi">源码分析</h1>
<h2 id="qi-yong-jie-shou-zhong-duan-hal-uart-receive-it">启用接收中断HAL_UART_Receive_IT</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>HAL_UART_Receive_IT -&gt; UART_Start_Receive_IT</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">huart<span class="token operator">-&gt;</span>pRxBuffPtr <span class="token operator">=</span> pData<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxXferSize <span class="token operator">=</span> Size<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxXferCount <span class="token operator">=</span> Size<span class="token punctuation">;</span>

huart<span class="token operator">-&gt;</span>ErrorCode <span class="token operator">=</span> HAL_UART_ERROR_NONE<span class="token punctuation">;</span>
huart<span class="token operator">-&gt;</span>RxState <span class="token operator">=</span> HAL_UART_STATE_BUSY_RX<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
<span class="token comment">/* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */</span>
<span class="token function">__HAL_UART_ENABLE_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">,</span> UART_IT_ERR<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* Enable the UART Data Register not empty Interrupt */</span>
<span class="token function">__HAL_UART_ENABLE_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">,</span> UART_IT_RXNE<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>pRxBuffPtr</code> ：<strong>保存我们传入的buf指针</strong></li>
<li><code>RxXferSize</code> ：<strong>保存我们传入的buf大小</strong></li>
<li><code>RxXferCount</code>： <strong>初始化待接收数据数量</strong></li>
<li><code>ErrorCode</code>：初始化错误码为 no error</li>
<li><code>RxState</code>：<strong>标识UART处于接收状态（Data Reception process is ongoing）</strong></li>
<li>开启UART异常中断
<ul>
<li>帧异常（Frame error）</li>
<li>噪声异常（noise error）</li>
<li><em><strong>接收缓冲区溢出异常（overrun error）</strong></em></li>
</ul>
</li>
<li>开启接收寄存器非空中断（Enable the UART Data Register not empty Interrupt）</li>
</ul>
<h2 id="uart-zhong-duan-xiang-liang-biao">UART中断向量表</h2>
<p><em><strong>startup_stm32f407vetx.s</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>word     USART1_IRQHandler                 <span class="token comment">/* USART1                       */</span>       <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em><strong>stm32f4xx_it.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* USER CODE BEGIN USART1_IRQn 0 */</span>

  <span class="token comment">/* USER CODE END USART1_IRQn 0 */</span>
  <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* USER CODE BEGIN USART1_IRQn 1 */</span>

  <span class="token comment">/* USER CODE END USART1_IRQn 1 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="shu-ju-jie-shou-chu-li">数据接收处理</h2>
<p><em><strong>stm32f4xx_it.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* If no error occurs */</span>
    errorflags <span class="token operator">=</span> <span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>USART_SR_PE <span class="token operator">|</span> USART_SR_FE <span class="token operator">|</span> USART_SR_ORE <span class="token operator">|</span> USART_SR_NE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorflags <span class="token operator">==</span> RESET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* UART in mode Receiver -------------------------------------------------*/</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> USART_SR_RXNE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cr1its <span class="token operator">&amp;</span> USART_CR1_RXNEIE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">UART_Receive_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行接收数据逻辑（UART_Receive_IT）的前置条件：</p>
<ul>
<li>没有UART相关的异常（errorflags）</li>
<li>接收寄存器非空（USART_SR_RXNE）</li>
<li>接收寄存器非空中断使能是开启的（USART_CR1_RXNEIE）</li>
</ul>
<h2 id="zhu-zi-jie-shou-shu-ju-data-register">逐字接收数据（Data Register）</h2>
<p><em><strong>stm32f4xx_hal_uart.c/UART_Receive_IT</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Check that a Rx process is ongoing */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>RxState <span class="token operator">==</span> HAL_UART_STATE_BUSY_RX<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">*</span>pdata8bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>Instance<span class="token operator">-&gt;</span>DR <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span> <span class="token number">0x00FF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	huart<span class="token operator">-&gt;</span>pRxBuffPtr <span class="token operator">+=</span> <span class="token number">1U</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>huart<span class="token operator">-&gt;</span>RxXferCount <span class="token operator">==</span> <span class="token number">0U</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*Call legacy weak Rx complete callback*/</span>
		<span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>判断UART是不是处于接收进程中
<ul>
<li>我们之前调用过 <code>HAL_UART_Receive_IT</code>，里面会置位这个状态 <code>huart-&gt;RxState = HAL_UART_STATE_BUSY_RX</code></li>
</ul>
</li>
<li>从DR（UART数据寄存器）中读取一个字节到用户自定义缓冲区中（我们调用 <code>HAL_UART_Receive_IT</code> 时传入过一个7字节的<code>buf</code>）</li>
<li>递减剩余待接收数据数量 <code>huart-&gt;RxXferCount</code>（之前被初始化为7）
<ul>
<li>如果递减为0，则说明接收的字节数填满了用户指定缓冲区大小</li>
<li>然后调用 <code>HAL_UART_RxCpltCallback</code>，这是一个 <code>weak</code>函数（默认是一个空实现），用户可以声明一个对应的非 <code>weak</code>版以实现回调处理。这个理念是经典的<strong>hook钩子函数</strong>。</li>
</ul>
</li>
</ul>
<h2 id="zhong-xie-huan-chong-qu-jie-shou-wan-bi-hui-diao">重写缓冲区接收完毕回调</h2>
<p>原型：</p>
<p><em><strong>stm32f4xx_hal_uart.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__weak <span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Prevent unused argument(s) compilation warning */</span>
    <span class="token function">UNUSED</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* NOTE: This function should not be modified, when the callback is needed,
             the HAL_UART_RxCpltCallback could be implemented in the user file
     */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重写：</p>
<p><em><strong>main.c</strong></em></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* USER CODE BEGIN 0 */</span>
<span class="token class-name">uint8_t</span> rxbuf<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span> rxbuf<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/* USER CODE END 0 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>将缓冲区7字节数据通过UART TX发送，采用轮询方式（每发一个字节轮询发送状态），超时时间100ms</li>
<li>重新开启接收中断，以实现下一次的echo</li>
</ul>
<h2 id="ding-chang-7-zi-jie-echo-ce-shi">定长7字节echo测试</h2>
<p>至此，定长7字节数据echo功能就实现了</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241113084959956.png" alt="image-20241113084959956"></p>
<h2 id="chao-7-zi-jie-echo-ce-shi">超7字节echo测试</h2>
<p><img src="C:/Users/86157/AppData/Roaming/Typora/typora-user-images/image-20241113085040298.png" alt="image-20241113085040298"></p>
<p>为什么超过我们指定的缓冲区大小（<code>HAL_UART_Transmit</code>的入参 <code>Size</code>）后，功能就不整行了呢？</p>
<h2 id="uart-zhong-duan-isr-yi-chang-liu-cheng">UART中断ISR-异常流程</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* If no error occurs */</span>
    errorflags <span class="token operator">=</span> <span class="token punctuation">(</span>isrflags <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>USART_SR_PE <span class="token operator">|</span> USART_SR_FE <span class="token operator">|</span> USART_SR_ORE <span class="token operator">|</span> USART_SR_NE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errorflags <span class="token operator">==</span> RESET<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">UART_Receive_IT</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
     
     <span class="token comment">/* If some errors occur */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>errorflags <span class="token operator">!=</span> RESET<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cr3its <span class="token operator">&amp;</span> USART_CR3_EIE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>
                                  <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cr1its <span class="token operator">&amp;</span> <span class="token punctuation">(</span>USART_CR1_RXNEIE <span class="token operator">|</span> USART_CR1_PEIE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* UART Over-Run interrupt occurred
         huart-&gt;ErrorCode |= HAL_UART_ERROR_ORE;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>没有异常时，会执行 <code>UART_Receive_IT</code>逐字接收数据并在填满缓冲区后触发接收完毕回调 <code>HAL_UART_RxCpltCallback</code></li>
<li>但是当我们发送8字节时，会触发UART的接收溢出错误，继而转向异常处理流程</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token comment">/* Call UART Error Call back function if need be --------------------------*/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>ErrorCode <span class="token operator">!=</span> HAL_UART_ERROR_NONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">/*Call legacy weak error callback*/</span>
    <span class="token function">HAL_UART_ErrorCallback</span><span class="token punctuation">(</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为异常处理流程不会执行我们自定义的 <code>HAL_UART_RxCpltCallback</code>，也就没有重新开启接收中断 <code>HAL_UART_RxCpltCallback</code>，所以就出现了发送8字节时，后续没有回传的现象：</p>
<p><img src="https://hexo-blog-anwen.oss-cn-beijing.aliyuncs.com/image/image-20241113085040298.png" alt="image-20241113085040298"></p>
<h1 id="si-kao-yi-liu-wen-ti">思考/遗留问题</h1>
<h2 id="usart-sr-ore-shi-ru-he-bei-she-zhi-de">USART_SR_ORE是如何被设置的</h2>
<p>为什么发送8字节时会触发USART_SR_ORE错误？</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Clion</tag>
        <tag>ARM</tag>
        <tag>STM32</tag>
        <tag>GD32</tag>
        <tag>HAL</tag>
        <tag>UART</tag>
      </tags>
  </entry>
</search>
